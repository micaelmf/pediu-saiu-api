
/**
 * Client
**/

import * as runtime from './runtime/library';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Category
 * 
 */
export type Category = $Result.DefaultSelection<Prisma.$CategoryPayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model Accompaniment
 * 
 */
export type Accompaniment = $Result.DefaultSelection<Prisma.$AccompanimentPayload>
/**
 * Model Additional
 * 
 */
export type Additional = $Result.DefaultSelection<Prisma.$AdditionalPayload>
/**
 * Model Order
 * 
 */
export type Order = $Result.DefaultSelection<Prisma.$OrderPayload>
/**
 * Model OrderItem
 * 
 */
export type OrderItem = $Result.DefaultSelection<Prisma.$OrderItemPayload>
/**
 * Model OrderHistory
 * 
 */
export type OrderHistory = $Result.DefaultSelection<Prisma.$OrderHistoryPayload>
/**
 * Model Enterprise
 * 
 */
export type Enterprise = $Result.DefaultSelection<Prisma.$EnterprisePayload>
/**
 * Model Configuration
 * 
 */
export type Configuration = $Result.DefaultSelection<Prisma.$ConfigurationPayload>
/**
 * Model Tag
 * 
 */
export type Tag = $Result.DefaultSelection<Prisma.$TagPayload>
/**
 * Model ProductTag
 * 
 */
export type ProductTag = $Result.DefaultSelection<Prisma.$ProductTagPayload>
/**
 * Model PromotionTag
 * 
 */
export type PromotionTag = $Result.DefaultSelection<Prisma.$PromotionTagPayload>
/**
 * Model Promotion
 * 
 */
export type Promotion = $Result.DefaultSelection<Prisma.$PromotionPayload>
/**
 * Model Combo
 * 
 */
export type Combo = $Result.DefaultSelection<Prisma.$ComboPayload>
/**
 * Model ComboProducts
 * 
 */
export type ComboProducts = $Result.DefaultSelection<Prisma.$ComboProductsPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<ExtArgs>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs>;

  /**
   * `prisma.accompaniment`: Exposes CRUD operations for the **Accompaniment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accompaniments
    * const accompaniments = await prisma.accompaniment.findMany()
    * ```
    */
  get accompaniment(): Prisma.AccompanimentDelegate<ExtArgs>;

  /**
   * `prisma.additional`: Exposes CRUD operations for the **Additional** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Additionals
    * const additionals = await prisma.additional.findMany()
    * ```
    */
  get additional(): Prisma.AdditionalDelegate<ExtArgs>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **Order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): Prisma.OrderDelegate<ExtArgs>;

  /**
   * `prisma.orderItem`: Exposes CRUD operations for the **OrderItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderItems
    * const orderItems = await prisma.orderItem.findMany()
    * ```
    */
  get orderItem(): Prisma.OrderItemDelegate<ExtArgs>;

  /**
   * `prisma.orderHistory`: Exposes CRUD operations for the **OrderHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderHistories
    * const orderHistories = await prisma.orderHistory.findMany()
    * ```
    */
  get orderHistory(): Prisma.OrderHistoryDelegate<ExtArgs>;

  /**
   * `prisma.enterprise`: Exposes CRUD operations for the **Enterprise** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Enterprises
    * const enterprises = await prisma.enterprise.findMany()
    * ```
    */
  get enterprise(): Prisma.EnterpriseDelegate<ExtArgs>;

  /**
   * `prisma.configuration`: Exposes CRUD operations for the **Configuration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Configurations
    * const configurations = await prisma.configuration.findMany()
    * ```
    */
  get configuration(): Prisma.ConfigurationDelegate<ExtArgs>;

  /**
   * `prisma.tag`: Exposes CRUD operations for the **Tag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tags
    * const tags = await prisma.tag.findMany()
    * ```
    */
  get tag(): Prisma.TagDelegate<ExtArgs>;

  /**
   * `prisma.productTag`: Exposes CRUD operations for the **ProductTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductTags
    * const productTags = await prisma.productTag.findMany()
    * ```
    */
  get productTag(): Prisma.ProductTagDelegate<ExtArgs>;

  /**
   * `prisma.promotionTag`: Exposes CRUD operations for the **PromotionTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PromotionTags
    * const promotionTags = await prisma.promotionTag.findMany()
    * ```
    */
  get promotionTag(): Prisma.PromotionTagDelegate<ExtArgs>;

  /**
   * `prisma.promotion`: Exposes CRUD operations for the **Promotion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Promotions
    * const promotions = await prisma.promotion.findMany()
    * ```
    */
  get promotion(): Prisma.PromotionDelegate<ExtArgs>;

  /**
   * `prisma.combo`: Exposes CRUD operations for the **Combo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Combos
    * const combos = await prisma.combo.findMany()
    * ```
    */
  get combo(): Prisma.ComboDelegate<ExtArgs>;

  /**
   * `prisma.comboProducts`: Exposes CRUD operations for the **ComboProducts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ComboProducts
    * const comboProducts = await prisma.comboProducts.findMany()
    * ```
    */
  get comboProducts(): Prisma.ComboProductsDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.3.1
   * Query Engine version: 61e140623197a131c2a6189271ffee05a7aa9a59
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Category: 'Category',
    Product: 'Product',
    Accompaniment: 'Accompaniment',
    Additional: 'Additional',
    Order: 'Order',
    OrderItem: 'OrderItem',
    OrderHistory: 'OrderHistory',
    Enterprise: 'Enterprise',
    Configuration: 'Configuration',
    Tag: 'Tag',
    ProductTag: 'ProductTag',
    PromotionTag: 'PromotionTag',
    Promotion: 'Promotion',
    Combo: 'Combo',
    ComboProducts: 'ComboProducts'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.Args}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'user' | 'category' | 'product' | 'accompaniment' | 'additional' | 'order' | 'orderItem' | 'orderHistory' | 'enterprise' | 'configuration' | 'tag' | 'productTag' | 'promotionTag' | 'promotion' | 'combo' | 'comboProducts'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>,
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Category: {
        payload: Prisma.$CategoryPayload<ExtArgs>
        fields: Prisma.CategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findFirst: {
            args: Prisma.CategoryFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findMany: {
            args: Prisma.CategoryFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          create: {
            args: Prisma.CategoryCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          createMany: {
            args: Prisma.CategoryCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CategoryDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          update: {
            args: Prisma.CategoryUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          deleteMany: {
            args: Prisma.CategoryDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CategoryUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.CategoryGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoryCountArgs<ExtArgs>,
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>,
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      Accompaniment: {
        payload: Prisma.$AccompanimentPayload<ExtArgs>
        fields: Prisma.AccompanimentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccompanimentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccompanimentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccompanimentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccompanimentPayload>
          }
          findFirst: {
            args: Prisma.AccompanimentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccompanimentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccompanimentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccompanimentPayload>
          }
          findMany: {
            args: Prisma.AccompanimentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccompanimentPayload>[]
          }
          create: {
            args: Prisma.AccompanimentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccompanimentPayload>
          }
          createMany: {
            args: Prisma.AccompanimentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AccompanimentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccompanimentPayload>
          }
          update: {
            args: Prisma.AccompanimentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccompanimentPayload>
          }
          deleteMany: {
            args: Prisma.AccompanimentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AccompanimentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AccompanimentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccompanimentPayload>
          }
          aggregate: {
            args: Prisma.AccompanimentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAccompaniment>
          }
          groupBy: {
            args: Prisma.AccompanimentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AccompanimentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccompanimentCountArgs<ExtArgs>,
            result: $Utils.Optional<AccompanimentCountAggregateOutputType> | number
          }
        }
      }
      Additional: {
        payload: Prisma.$AdditionalPayload<ExtArgs>
        fields: Prisma.AdditionalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdditionalFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdditionalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdditionalFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdditionalPayload>
          }
          findFirst: {
            args: Prisma.AdditionalFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdditionalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdditionalFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdditionalPayload>
          }
          findMany: {
            args: Prisma.AdditionalFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdditionalPayload>[]
          }
          create: {
            args: Prisma.AdditionalCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdditionalPayload>
          }
          createMany: {
            args: Prisma.AdditionalCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AdditionalDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdditionalPayload>
          }
          update: {
            args: Prisma.AdditionalUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdditionalPayload>
          }
          deleteMany: {
            args: Prisma.AdditionalDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AdditionalUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AdditionalUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdditionalPayload>
          }
          aggregate: {
            args: Prisma.AdditionalAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAdditional>
          }
          groupBy: {
            args: Prisma.AdditionalGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AdditionalGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdditionalCountArgs<ExtArgs>,
            result: $Utils.Optional<AdditionalCountAggregateOutputType> | number
          }
        }
      }
      Order: {
        payload: Prisma.$OrderPayload<ExtArgs>
        fields: Prisma.OrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findFirst: {
            args: Prisma.OrderFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findMany: {
            args: Prisma.OrderFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          create: {
            args: Prisma.OrderCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          createMany: {
            args: Prisma.OrderCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.OrderDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          update: {
            args: Prisma.OrderUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          deleteMany: {
            args: Prisma.OrderDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.OrderUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.OrderUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          aggregate: {
            args: Prisma.OrderAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOrder>
          }
          groupBy: {
            args: Prisma.OrderGroupByArgs<ExtArgs>,
            result: $Utils.Optional<OrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderCountArgs<ExtArgs>,
            result: $Utils.Optional<OrderCountAggregateOutputType> | number
          }
        }
      }
      OrderItem: {
        payload: Prisma.$OrderItemPayload<ExtArgs>
        fields: Prisma.OrderItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderItemFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderItemFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          findFirst: {
            args: Prisma.OrderItemFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderItemFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          findMany: {
            args: Prisma.OrderItemFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          create: {
            args: Prisma.OrderItemCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          createMany: {
            args: Prisma.OrderItemCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.OrderItemDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          update: {
            args: Prisma.OrderItemUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          deleteMany: {
            args: Prisma.OrderItemDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.OrderItemUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.OrderItemUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          aggregate: {
            args: Prisma.OrderItemAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOrderItem>
          }
          groupBy: {
            args: Prisma.OrderItemGroupByArgs<ExtArgs>,
            result: $Utils.Optional<OrderItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderItemCountArgs<ExtArgs>,
            result: $Utils.Optional<OrderItemCountAggregateOutputType> | number
          }
        }
      }
      OrderHistory: {
        payload: Prisma.$OrderHistoryPayload<ExtArgs>
        fields: Prisma.OrderHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderHistoryFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderHistoryFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderHistoryPayload>
          }
          findFirst: {
            args: Prisma.OrderHistoryFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderHistoryFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderHistoryPayload>
          }
          findMany: {
            args: Prisma.OrderHistoryFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderHistoryPayload>[]
          }
          create: {
            args: Prisma.OrderHistoryCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderHistoryPayload>
          }
          createMany: {
            args: Prisma.OrderHistoryCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.OrderHistoryDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderHistoryPayload>
          }
          update: {
            args: Prisma.OrderHistoryUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderHistoryPayload>
          }
          deleteMany: {
            args: Prisma.OrderHistoryDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.OrderHistoryUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.OrderHistoryUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderHistoryPayload>
          }
          aggregate: {
            args: Prisma.OrderHistoryAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOrderHistory>
          }
          groupBy: {
            args: Prisma.OrderHistoryGroupByArgs<ExtArgs>,
            result: $Utils.Optional<OrderHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderHistoryCountArgs<ExtArgs>,
            result: $Utils.Optional<OrderHistoryCountAggregateOutputType> | number
          }
        }
      }
      Enterprise: {
        payload: Prisma.$EnterprisePayload<ExtArgs>
        fields: Prisma.EnterpriseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EnterpriseFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EnterprisePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EnterpriseFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EnterprisePayload>
          }
          findFirst: {
            args: Prisma.EnterpriseFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EnterprisePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EnterpriseFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EnterprisePayload>
          }
          findMany: {
            args: Prisma.EnterpriseFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EnterprisePayload>[]
          }
          create: {
            args: Prisma.EnterpriseCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EnterprisePayload>
          }
          createMany: {
            args: Prisma.EnterpriseCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.EnterpriseDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EnterprisePayload>
          }
          update: {
            args: Prisma.EnterpriseUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EnterprisePayload>
          }
          deleteMany: {
            args: Prisma.EnterpriseDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EnterpriseUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EnterpriseUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EnterprisePayload>
          }
          aggregate: {
            args: Prisma.EnterpriseAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEnterprise>
          }
          groupBy: {
            args: Prisma.EnterpriseGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EnterpriseGroupByOutputType>[]
          }
          count: {
            args: Prisma.EnterpriseCountArgs<ExtArgs>,
            result: $Utils.Optional<EnterpriseCountAggregateOutputType> | number
          }
        }
      }
      Configuration: {
        payload: Prisma.$ConfigurationPayload<ExtArgs>
        fields: Prisma.ConfigurationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConfigurationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConfigurationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConfigurationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConfigurationPayload>
          }
          findFirst: {
            args: Prisma.ConfigurationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConfigurationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConfigurationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConfigurationPayload>
          }
          findMany: {
            args: Prisma.ConfigurationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConfigurationPayload>[]
          }
          create: {
            args: Prisma.ConfigurationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConfigurationPayload>
          }
          createMany: {
            args: Prisma.ConfigurationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ConfigurationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConfigurationPayload>
          }
          update: {
            args: Prisma.ConfigurationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConfigurationPayload>
          }
          deleteMany: {
            args: Prisma.ConfigurationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ConfigurationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ConfigurationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConfigurationPayload>
          }
          aggregate: {
            args: Prisma.ConfigurationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateConfiguration>
          }
          groupBy: {
            args: Prisma.ConfigurationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ConfigurationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConfigurationCountArgs<ExtArgs>,
            result: $Utils.Optional<ConfigurationCountAggregateOutputType> | number
          }
        }
      }
      Tag: {
        payload: Prisma.$TagPayload<ExtArgs>
        fields: Prisma.TagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TagFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TagFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findFirst: {
            args: Prisma.TagFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TagFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findMany: {
            args: Prisma.TagFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          create: {
            args: Prisma.TagCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          createMany: {
            args: Prisma.TagCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.TagDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          update: {
            args: Prisma.TagUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          deleteMany: {
            args: Prisma.TagDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.TagUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.TagUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          aggregate: {
            args: Prisma.TagAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTag>
          }
          groupBy: {
            args: Prisma.TagGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TagGroupByOutputType>[]
          }
          count: {
            args: Prisma.TagCountArgs<ExtArgs>,
            result: $Utils.Optional<TagCountAggregateOutputType> | number
          }
        }
      }
      ProductTag: {
        payload: Prisma.$ProductTagPayload<ExtArgs>
        fields: Prisma.ProductTagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductTagFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductTagFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductTagPayload>
          }
          findFirst: {
            args: Prisma.ProductTagFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductTagFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductTagPayload>
          }
          findMany: {
            args: Prisma.ProductTagFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductTagPayload>[]
          }
          create: {
            args: Prisma.ProductTagCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductTagPayload>
          }
          createMany: {
            args: Prisma.ProductTagCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ProductTagDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductTagPayload>
          }
          update: {
            args: Prisma.ProductTagUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductTagPayload>
          }
          deleteMany: {
            args: Prisma.ProductTagDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ProductTagUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ProductTagUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductTagPayload>
          }
          aggregate: {
            args: Prisma.ProductTagAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProductTag>
          }
          groupBy: {
            args: Prisma.ProductTagGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ProductTagGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductTagCountArgs<ExtArgs>,
            result: $Utils.Optional<ProductTagCountAggregateOutputType> | number
          }
        }
      }
      PromotionTag: {
        payload: Prisma.$PromotionTagPayload<ExtArgs>
        fields: Prisma.PromotionTagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PromotionTagFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PromotionTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PromotionTagFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PromotionTagPayload>
          }
          findFirst: {
            args: Prisma.PromotionTagFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PromotionTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PromotionTagFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PromotionTagPayload>
          }
          findMany: {
            args: Prisma.PromotionTagFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PromotionTagPayload>[]
          }
          create: {
            args: Prisma.PromotionTagCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PromotionTagPayload>
          }
          createMany: {
            args: Prisma.PromotionTagCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PromotionTagDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PromotionTagPayload>
          }
          update: {
            args: Prisma.PromotionTagUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PromotionTagPayload>
          }
          deleteMany: {
            args: Prisma.PromotionTagDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PromotionTagUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PromotionTagUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PromotionTagPayload>
          }
          aggregate: {
            args: Prisma.PromotionTagAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePromotionTag>
          }
          groupBy: {
            args: Prisma.PromotionTagGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PromotionTagGroupByOutputType>[]
          }
          count: {
            args: Prisma.PromotionTagCountArgs<ExtArgs>,
            result: $Utils.Optional<PromotionTagCountAggregateOutputType> | number
          }
        }
      }
      Promotion: {
        payload: Prisma.$PromotionPayload<ExtArgs>
        fields: Prisma.PromotionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PromotionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PromotionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>
          }
          findFirst: {
            args: Prisma.PromotionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PromotionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>
          }
          findMany: {
            args: Prisma.PromotionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>[]
          }
          create: {
            args: Prisma.PromotionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>
          }
          createMany: {
            args: Prisma.PromotionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PromotionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>
          }
          update: {
            args: Prisma.PromotionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>
          }
          deleteMany: {
            args: Prisma.PromotionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PromotionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PromotionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>
          }
          aggregate: {
            args: Prisma.PromotionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePromotion>
          }
          groupBy: {
            args: Prisma.PromotionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PromotionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PromotionCountArgs<ExtArgs>,
            result: $Utils.Optional<PromotionCountAggregateOutputType> | number
          }
        }
      }
      Combo: {
        payload: Prisma.$ComboPayload<ExtArgs>
        fields: Prisma.ComboFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ComboFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ComboPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ComboFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ComboPayload>
          }
          findFirst: {
            args: Prisma.ComboFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ComboPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ComboFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ComboPayload>
          }
          findMany: {
            args: Prisma.ComboFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ComboPayload>[]
          }
          create: {
            args: Prisma.ComboCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ComboPayload>
          }
          createMany: {
            args: Prisma.ComboCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ComboDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ComboPayload>
          }
          update: {
            args: Prisma.ComboUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ComboPayload>
          }
          deleteMany: {
            args: Prisma.ComboDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ComboUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ComboUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ComboPayload>
          }
          aggregate: {
            args: Prisma.ComboAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCombo>
          }
          groupBy: {
            args: Prisma.ComboGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ComboGroupByOutputType>[]
          }
          count: {
            args: Prisma.ComboCountArgs<ExtArgs>,
            result: $Utils.Optional<ComboCountAggregateOutputType> | number
          }
        }
      }
      ComboProducts: {
        payload: Prisma.$ComboProductsPayload<ExtArgs>
        fields: Prisma.ComboProductsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ComboProductsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ComboProductsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ComboProductsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ComboProductsPayload>
          }
          findFirst: {
            args: Prisma.ComboProductsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ComboProductsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ComboProductsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ComboProductsPayload>
          }
          findMany: {
            args: Prisma.ComboProductsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ComboProductsPayload>[]
          }
          create: {
            args: Prisma.ComboProductsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ComboProductsPayload>
          }
          createMany: {
            args: Prisma.ComboProductsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ComboProductsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ComboProductsPayload>
          }
          update: {
            args: Prisma.ComboProductsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ComboProductsPayload>
          }
          deleteMany: {
            args: Prisma.ComboProductsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ComboProductsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ComboProductsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ComboProductsPayload>
          }
          aggregate: {
            args: Prisma.ComboProductsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateComboProducts>
          }
          groupBy: {
            args: Prisma.ComboProductsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ComboProductsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ComboProductsCountArgs<ExtArgs>,
            result: $Utils.Optional<ComboProductsCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    orders: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    orders?: boolean | UserCountOutputTypeCountOrdersArgs
  }

  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }



  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    products: number
    promotions: number
    combos: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    products?: boolean | CategoryCountOutputTypeCountProductsArgs
    promotions?: boolean | CategoryCountOutputTypeCountPromotionsArgs
    combos?: boolean | CategoryCountOutputTypeCountCombosArgs
  }

  // Custom InputTypes

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }


  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountPromotionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PromotionWhereInput
  }


  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountCombosArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ComboWhereInput
  }



  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    accompaniments: number
    additionals: number
    orders: number
    orderItems: number
    productTags: number
    combos: number
    ComboProducts: number
    Combo: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    accompaniments?: boolean | ProductCountOutputTypeCountAccompanimentsArgs
    additionals?: boolean | ProductCountOutputTypeCountAdditionalsArgs
    orders?: boolean | ProductCountOutputTypeCountOrdersArgs
    orderItems?: boolean | ProductCountOutputTypeCountOrderItemsArgs
    productTags?: boolean | ProductCountOutputTypeCountProductTagsArgs
    combos?: boolean | ProductCountOutputTypeCountCombosArgs
    ComboProducts?: boolean | ProductCountOutputTypeCountComboProductsArgs
    Combo?: boolean | ProductCountOutputTypeCountComboArgs
  }

  // Custom InputTypes

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountAccompanimentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: AccompanimentWhereInput
  }


  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountAdditionalsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: AdditionalWhereInput
  }


  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }


  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountOrderItemsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
  }


  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountProductTagsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ProductTagWhereInput
  }


  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountCombosArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ComboWhereInput
  }


  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountComboProductsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ComboProductsWhereInput
  }


  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountComboArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ComboWhereInput
  }



  /**
   * Count Type OrderCountOutputType
   */

  export type OrderCountOutputType = {
    products: number
    orderItems: number
    orderHistories: number
  }

  export type OrderCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    products?: boolean | OrderCountOutputTypeCountProductsArgs
    orderItems?: boolean | OrderCountOutputTypeCountOrderItemsArgs
    orderHistories?: boolean | OrderCountOutputTypeCountOrderHistoriesArgs
  }

  // Custom InputTypes

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderCountOutputType
     */
    select?: OrderCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }


  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountOrderItemsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
  }


  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountOrderHistoriesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: OrderHistoryWhereInput
  }



  /**
   * Count Type EnterpriseCountOutputType
   */

  export type EnterpriseCountOutputType = {
    users: number
    categories: number
    products: number
    configurations: number
    orders: number
    promotions: number
    combos: number
  }

  export type EnterpriseCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    users?: boolean | EnterpriseCountOutputTypeCountUsersArgs
    categories?: boolean | EnterpriseCountOutputTypeCountCategoriesArgs
    products?: boolean | EnterpriseCountOutputTypeCountProductsArgs
    configurations?: boolean | EnterpriseCountOutputTypeCountConfigurationsArgs
    orders?: boolean | EnterpriseCountOutputTypeCountOrdersArgs
    promotions?: boolean | EnterpriseCountOutputTypeCountPromotionsArgs
    combos?: boolean | EnterpriseCountOutputTypeCountCombosArgs
  }

  // Custom InputTypes

  /**
   * EnterpriseCountOutputType without action
   */
  export type EnterpriseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnterpriseCountOutputType
     */
    select?: EnterpriseCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * EnterpriseCountOutputType without action
   */
  export type EnterpriseCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * EnterpriseCountOutputType without action
   */
  export type EnterpriseCountOutputTypeCountCategoriesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
  }


  /**
   * EnterpriseCountOutputType without action
   */
  export type EnterpriseCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }


  /**
   * EnterpriseCountOutputType without action
   */
  export type EnterpriseCountOutputTypeCountConfigurationsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ConfigurationWhereInput
  }


  /**
   * EnterpriseCountOutputType without action
   */
  export type EnterpriseCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }


  /**
   * EnterpriseCountOutputType without action
   */
  export type EnterpriseCountOutputTypeCountPromotionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PromotionWhereInput
  }


  /**
   * EnterpriseCountOutputType without action
   */
  export type EnterpriseCountOutputTypeCountCombosArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ComboWhereInput
  }



  /**
   * Count Type TagCountOutputType
   */

  export type TagCountOutputType = {
    productTags: number
    promotionTags: number
  }

  export type TagCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    productTags?: boolean | TagCountOutputTypeCountProductTagsArgs
    promotionTags?: boolean | TagCountOutputTypeCountPromotionTagsArgs
  }

  // Custom InputTypes

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagCountOutputType
     */
    select?: TagCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountProductTagsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ProductTagWhereInput
  }


  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountPromotionTagsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PromotionTagWhereInput
  }



  /**
   * Count Type PromotionCountOutputType
   */

  export type PromotionCountOutputType = {
    promotionTags: number
  }

  export type PromotionCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    promotionTags?: boolean | PromotionCountOutputTypeCountPromotionTagsArgs
  }

  // Custom InputTypes

  /**
   * PromotionCountOutputType without action
   */
  export type PromotionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionCountOutputType
     */
    select?: PromotionCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * PromotionCountOutputType without action
   */
  export type PromotionCountOutputTypeCountPromotionTagsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PromotionTagWhereInput
  }



  /**
   * Count Type ComboCountOutputType
   */

  export type ComboCountOutputType = {
    products: number
    ComboProducts: number
  }

  export type ComboCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    products?: boolean | ComboCountOutputTypeCountProductsArgs
    ComboProducts?: boolean | ComboCountOutputTypeCountComboProductsArgs
  }

  // Custom InputTypes

  /**
   * ComboCountOutputType without action
   */
  export type ComboCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComboCountOutputType
     */
    select?: ComboCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ComboCountOutputType without action
   */
  export type ComboCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }


  /**
   * ComboCountOutputType without action
   */
  export type ComboCountOutputTypeCountComboProductsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ComboProductsWhereInput
  }



  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    enterpriseId: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    enterpriseId: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    uuid: string | null
    email: string | null
    nickname: string | null
    role: string | null
    firstName: string | null
    lastName: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    enterpriseId: number | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    uuid: string | null
    email: string | null
    nickname: string | null
    role: string | null
    firstName: string | null
    lastName: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    enterpriseId: number | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    uuid: number
    email: number
    nickname: number
    role: number
    firstName: number
    lastName: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    enterpriseId: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    enterpriseId?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    enterpriseId?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    uuid?: true
    email?: true
    nickname?: true
    role?: true
    firstName?: true
    lastName?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    enterpriseId?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    uuid?: true
    email?: true
    nickname?: true
    role?: true
    firstName?: true
    lastName?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    enterpriseId?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    uuid?: true
    email?: true
    nickname?: true
    role?: true
    firstName?: true
    lastName?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    enterpriseId?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    uuid: string
    email: string
    nickname: string
    role: string
    firstName: string | null
    lastName: string | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    enterpriseId: number
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    email?: boolean
    nickname?: boolean
    role?: boolean
    firstName?: boolean
    lastName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    enterpriseId?: boolean
    orders?: boolean | User$ordersArgs<ExtArgs>
    enterprise?: boolean | User$enterpriseArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    uuid?: boolean
    email?: boolean
    nickname?: boolean
    role?: boolean
    firstName?: boolean
    lastName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    enterpriseId?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    orders?: boolean | User$ordersArgs<ExtArgs>
    enterprise?: boolean | User$enterpriseArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $UserPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      orders: Prisma.$OrderPayload<ExtArgs>[]
      enterprise: Prisma.$EnterprisePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetResult<{
      id: number
      uuid: string
      email: string
      nickname: string
      role: string
      firstName: string | null
      lastName: string | null
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
      enterpriseId: number
    }, ExtArgs["result"]["user"]>
    composites: {}
  }


  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserCreateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserDeleteArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpsertArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    orders<T extends User$ordersArgs<ExtArgs> = {}>(args?: Subset<T, User$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'findMany'> | Null>;

    enterprise<T extends User$enterpriseArgs<ExtArgs> = {}>(args?: Subset<T, User$enterpriseArgs<ExtArgs>>): Prisma__EnterpriseClient<$Result.GetResult<Prisma.$EnterprisePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly uuid: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly nickname: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly deletedAt: FieldRef<"User", 'DateTime'>
    readonly enterpriseId: FieldRef<"User", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }


  /**
   * User.orders
   */
  export type User$ordersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }


  /**
   * User.enterprise
   */
  export type User$enterpriseArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enterprise
     */
    select?: EnterpriseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnterpriseInclude<ExtArgs> | null
    where?: EnterpriseWhereInput
  }


  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
  }



  /**
   * Model Category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryAvgAggregateOutputType = {
    id: number | null
    enterpriseId: number | null
  }

  export type CategorySumAggregateOutputType = {
    id: number | null
    enterpriseId: number | null
  }

  export type CategoryMinAggregateOutputType = {
    id: number | null
    uuid: string | null
    name: string | null
    description: string | null
    status: string | null
    enterpriseId: number | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: number | null
    uuid: string | null
    name: string | null
    description: string | null
    status: string | null
    enterpriseId: number | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    uuid: number
    name: number
    description: number
    status: number
    enterpriseId: number
    _all: number
  }


  export type CategoryAvgAggregateInputType = {
    id?: true
    enterpriseId?: true
  }

  export type CategorySumAggregateInputType = {
    id?: true
    enterpriseId?: true
  }

  export type CategoryMinAggregateInputType = {
    id?: true
    uuid?: true
    name?: true
    description?: true
    status?: true
    enterpriseId?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    uuid?: true
    name?: true
    description?: true
    status?: true
    enterpriseId?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    uuid?: true
    name?: true
    description?: true
    status?: true
    enterpriseId?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithAggregationInput | CategoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _avg?: CategoryAvgAggregateInputType
    _sum?: CategorySumAggregateInputType
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    id: number
    uuid: string
    name: string
    description: string | null
    status: string
    enterpriseId: number
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    enterpriseId?: boolean
    products?: boolean | Category$productsArgs<ExtArgs>
    enterprise?: boolean | EnterpriseDefaultArgs<ExtArgs>
    promotions?: boolean | Category$promotionsArgs<ExtArgs>
    combos?: boolean | Category$combosArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectScalar = {
    id?: boolean
    uuid?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    enterpriseId?: boolean
  }

  export type CategoryInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    products?: boolean | Category$productsArgs<ExtArgs>
    enterprise?: boolean | EnterpriseDefaultArgs<ExtArgs>
    promotions?: boolean | Category$promotionsArgs<ExtArgs>
    combos?: boolean | Category$combosArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $CategoryPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "Category"
    objects: {
      products: Prisma.$ProductPayload<ExtArgs>[]
      enterprise: Prisma.$EnterprisePayload<ExtArgs>
      promotions: Prisma.$PromotionPayload<ExtArgs>[]
      combos: Prisma.$ComboPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetResult<{
      id: number
      uuid: string
      name: string
      description: string | null
      status: string
      enterpriseId: number
    }, ExtArgs["result"]["category"]>
    composites: {}
  }


  type CategoryGetPayload<S extends boolean | null | undefined | CategoryDefaultArgs> = $Result.GetResult<Prisma.$CategoryPayload, S>

  type CategoryCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<CategoryFindManyArgs, 'select' | 'include'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface CategoryDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Category'], meta: { name: 'Category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CategoryFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CategoryFindUniqueArgs<ExtArgs>>
    ): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Category that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoryFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CategoryFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoryFindFirstArgs<ExtArgs>>
    ): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoryFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CategoryFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoryFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
    **/
    create<T extends CategoryCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CategoryCreateArgs<ExtArgs>>
    ): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Categories.
     *     @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     *     @example
     *     // Create many Categories
     *     const category = await prisma.category.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CategoryCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoryCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
    **/
    delete<T extends CategoryDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CategoryDeleteArgs<ExtArgs>>
    ): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CategoryUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CategoryUpdateArgs<ExtArgs>>
    ): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CategoryDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoryDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CategoryUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CategoryUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
    **/
    upsert<T extends CategoryUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CategoryUpsertArgs<ExtArgs>>
    ): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Category model
   */
  readonly fields: CategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    products<T extends Category$productsArgs<ExtArgs> = {}>(args?: Subset<T, Category$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findMany'> | Null>;

    enterprise<T extends EnterpriseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EnterpriseDefaultArgs<ExtArgs>>): Prisma__EnterpriseClient<$Result.GetResult<Prisma.$EnterprisePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    promotions<T extends Category$promotionsArgs<ExtArgs> = {}>(args?: Subset<T, Category$promotionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, 'findMany'> | Null>;

    combos<T extends Category$combosArgs<ExtArgs> = {}>(args?: Subset<T, Category$combosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComboPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Category model
   */ 
  interface CategoryFieldRefs {
    readonly id: FieldRef<"Category", 'Int'>
    readonly uuid: FieldRef<"Category", 'String'>
    readonly name: FieldRef<"Category", 'String'>
    readonly description: FieldRef<"Category", 'String'>
    readonly status: FieldRef<"Category", 'String'>
    readonly enterpriseId: FieldRef<"Category", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }


  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }


  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }


  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }


  /**
   * Category findMany
   */
  export type CategoryFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }


  /**
   * Category create
   */
  export type CategoryCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }


  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Category update
   */
  export type CategoryUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput
  }


  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
  }


  /**
   * Category upsert
   */
  export type CategoryUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }


  /**
   * Category delete
   */
  export type CategoryDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput
  }


  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput
  }


  /**
   * Category.products
   */
  export type Category$productsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }


  /**
   * Category.promotions
   */
  export type Category$promotionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PromotionInclude<ExtArgs> | null
    where?: PromotionWhereInput
    orderBy?: PromotionOrderByWithRelationInput | PromotionOrderByWithRelationInput[]
    cursor?: PromotionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PromotionScalarFieldEnum | PromotionScalarFieldEnum[]
  }


  /**
   * Category.combos
   */
  export type Category$combosArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Combo
     */
    select?: ComboSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ComboInclude<ExtArgs> | null
    where?: ComboWhereInput
    orderBy?: ComboOrderByWithRelationInput | ComboOrderByWithRelationInput[]
    cursor?: ComboWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComboScalarFieldEnum | ComboScalarFieldEnum[]
  }


  /**
   * Category without action
   */
  export type CategoryDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude<ExtArgs> | null
  }



  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    id: number | null
    price: number | null
    additionalsMax: number | null
    accompanimentsMax: number | null
    categoryId: number | null
    enterpriseId: number | null
  }

  export type ProductSumAggregateOutputType = {
    id: number | null
    price: number | null
    additionalsMax: number | null
    accompanimentsMax: number | null
    categoryId: number | null
    enterpriseId: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: number | null
    uuid: string | null
    name: string | null
    description: string | null
    type: string | null
    price: number | null
    free: boolean | null
    status: string | null
    additionalsMax: number | null
    accompanimentsMax: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    categoryId: number | null
    enterpriseId: number | null
  }

  export type ProductMaxAggregateOutputType = {
    id: number | null
    uuid: string | null
    name: string | null
    description: string | null
    type: string | null
    price: number | null
    free: boolean | null
    status: string | null
    additionalsMax: number | null
    accompanimentsMax: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    categoryId: number | null
    enterpriseId: number | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    uuid: number
    name: number
    description: number
    type: number
    price: number
    free: number
    status: number
    additionalsMax: number
    accompanimentsMax: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    categoryId: number
    enterpriseId: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    id?: true
    price?: true
    additionalsMax?: true
    accompanimentsMax?: true
    categoryId?: true
    enterpriseId?: true
  }

  export type ProductSumAggregateInputType = {
    id?: true
    price?: true
    additionalsMax?: true
    accompanimentsMax?: true
    categoryId?: true
    enterpriseId?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    uuid?: true
    name?: true
    description?: true
    type?: true
    price?: true
    free?: true
    status?: true
    additionalsMax?: true
    accompanimentsMax?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    categoryId?: true
    enterpriseId?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    uuid?: true
    name?: true
    description?: true
    type?: true
    price?: true
    free?: true
    status?: true
    additionalsMax?: true
    accompanimentsMax?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    categoryId?: true
    enterpriseId?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    uuid?: true
    name?: true
    description?: true
    type?: true
    price?: true
    free?: true
    status?: true
    additionalsMax?: true
    accompanimentsMax?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    categoryId?: true
    enterpriseId?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: number
    uuid: string
    name: string
    description: string | null
    type: string
    price: number
    free: boolean
    status: string
    additionalsMax: number
    accompanimentsMax: number
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    categoryId: number
    enterpriseId: number
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    price?: boolean
    free?: boolean
    status?: boolean
    additionalsMax?: boolean
    accompanimentsMax?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    categoryId?: boolean
    enterpriseId?: boolean
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    enterprise?: boolean | EnterpriseDefaultArgs<ExtArgs>
    accompaniments?: boolean | Product$accompanimentsArgs<ExtArgs>
    additionals?: boolean | Product$additionalsArgs<ExtArgs>
    orders?: boolean | Product$ordersArgs<ExtArgs>
    orderItems?: boolean | Product$orderItemsArgs<ExtArgs>
    productTags?: boolean | Product$productTagsArgs<ExtArgs>
    combos?: boolean | Product$combosArgs<ExtArgs>
    ComboProducts?: boolean | Product$ComboProductsArgs<ExtArgs>
    Combo?: boolean | Product$ComboArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectScalar = {
    id?: boolean
    uuid?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    price?: boolean
    free?: boolean
    status?: boolean
    additionalsMax?: boolean
    accompanimentsMax?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    categoryId?: boolean
    enterpriseId?: boolean
  }

  export type ProductInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    enterprise?: boolean | EnterpriseDefaultArgs<ExtArgs>
    accompaniments?: boolean | Product$accompanimentsArgs<ExtArgs>
    additionals?: boolean | Product$additionalsArgs<ExtArgs>
    orders?: boolean | Product$ordersArgs<ExtArgs>
    orderItems?: boolean | Product$orderItemsArgs<ExtArgs>
    productTags?: boolean | Product$productTagsArgs<ExtArgs>
    combos?: boolean | Product$combosArgs<ExtArgs>
    ComboProducts?: boolean | Product$ComboProductsArgs<ExtArgs>
    Combo?: boolean | Product$ComboArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ProductPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      category: Prisma.$CategoryPayload<ExtArgs>
      enterprise: Prisma.$EnterprisePayload<ExtArgs>
      accompaniments: Prisma.$AccompanimentPayload<ExtArgs>[]
      additionals: Prisma.$AdditionalPayload<ExtArgs>[]
      orders: Prisma.$OrderPayload<ExtArgs>[]
      orderItems: Prisma.$OrderItemPayload<ExtArgs>[]
      productTags: Prisma.$ProductTagPayload<ExtArgs>[]
      combos: Prisma.$ComboPayload<ExtArgs>[]
      ComboProducts: Prisma.$ComboProductsPayload<ExtArgs>[]
      Combo: Prisma.$ComboPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetResult<{
      id: number
      uuid: string
      name: string
      description: string | null
      type: string
      price: number
      free: boolean
      status: string
      additionalsMax: number
      accompanimentsMax: number
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
      categoryId: number
      enterpriseId: number
    }, ExtArgs["result"]["product"]>
    composites: {}
  }


  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ProductFindManyArgs, 'select' | 'include'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProductFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>
    ): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Product that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProductFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>
    ): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProductFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
    **/
    create<T extends ProductCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ProductCreateArgs<ExtArgs>>
    ): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Products.
     *     @param {ProductCreateManyArgs} args - Arguments to create many Products.
     *     @example
     *     // Create many Products
     *     const product = await prisma.product.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProductCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
    **/
    delete<T extends ProductDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>
    ): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProductUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>
    ): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProductDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProductUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
    **/
    upsert<T extends ProductUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>
    ): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    category<T extends CategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CategoryDefaultArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    enterprise<T extends EnterpriseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EnterpriseDefaultArgs<ExtArgs>>): Prisma__EnterpriseClient<$Result.GetResult<Prisma.$EnterprisePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    accompaniments<T extends Product$accompanimentsArgs<ExtArgs> = {}>(args?: Subset<T, Product$accompanimentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccompanimentPayload<ExtArgs>, T, 'findMany'> | Null>;

    additionals<T extends Product$additionalsArgs<ExtArgs> = {}>(args?: Subset<T, Product$additionalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdditionalPayload<ExtArgs>, T, 'findMany'> | Null>;

    orders<T extends Product$ordersArgs<ExtArgs> = {}>(args?: Subset<T, Product$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'findMany'> | Null>;

    orderItems<T extends Product$orderItemsArgs<ExtArgs> = {}>(args?: Subset<T, Product$orderItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, 'findMany'> | Null>;

    productTags<T extends Product$productTagsArgs<ExtArgs> = {}>(args?: Subset<T, Product$productTagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductTagPayload<ExtArgs>, T, 'findMany'> | Null>;

    combos<T extends Product$combosArgs<ExtArgs> = {}>(args?: Subset<T, Product$combosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComboPayload<ExtArgs>, T, 'findMany'> | Null>;

    ComboProducts<T extends Product$ComboProductsArgs<ExtArgs> = {}>(args?: Subset<T, Product$ComboProductsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComboProductsPayload<ExtArgs>, T, 'findMany'> | Null>;

    Combo<T extends Product$ComboArgs<ExtArgs> = {}>(args?: Subset<T, Product$ComboArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComboPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Product model
   */ 
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'Int'>
    readonly uuid: FieldRef<"Product", 'String'>
    readonly name: FieldRef<"Product", 'String'>
    readonly description: FieldRef<"Product", 'String'>
    readonly type: FieldRef<"Product", 'String'>
    readonly price: FieldRef<"Product", 'Float'>
    readonly free: FieldRef<"Product", 'Boolean'>
    readonly status: FieldRef<"Product", 'String'>
    readonly additionalsMax: FieldRef<"Product", 'Int'>
    readonly accompanimentsMax: FieldRef<"Product", 'Int'>
    readonly createdAt: FieldRef<"Product", 'DateTime'>
    readonly updatedAt: FieldRef<"Product", 'DateTime'>
    readonly deletedAt: FieldRef<"Product", 'DateTime'>
    readonly categoryId: FieldRef<"Product", 'Int'>
    readonly enterpriseId: FieldRef<"Product", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }


  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }


  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }


  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }


  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }


  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }


  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }


  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
  }


  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }


  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }


  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
  }


  /**
   * Product.accompaniments
   */
  export type Product$accompanimentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Accompaniment
     */
    select?: AccompanimentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccompanimentInclude<ExtArgs> | null
    where?: AccompanimentWhereInput
    orderBy?: AccompanimentOrderByWithRelationInput | AccompanimentOrderByWithRelationInput[]
    cursor?: AccompanimentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccompanimentScalarFieldEnum | AccompanimentScalarFieldEnum[]
  }


  /**
   * Product.additionals
   */
  export type Product$additionalsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Additional
     */
    select?: AdditionalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdditionalInclude<ExtArgs> | null
    where?: AdditionalWhereInput
    orderBy?: AdditionalOrderByWithRelationInput | AdditionalOrderByWithRelationInput[]
    cursor?: AdditionalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdditionalScalarFieldEnum | AdditionalScalarFieldEnum[]
  }


  /**
   * Product.orders
   */
  export type Product$ordersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }


  /**
   * Product.orderItems
   */
  export type Product$orderItemsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }


  /**
   * Product.productTags
   */
  export type Product$productTagsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTag
     */
    select?: ProductTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductTagInclude<ExtArgs> | null
    where?: ProductTagWhereInput
    orderBy?: ProductTagOrderByWithRelationInput | ProductTagOrderByWithRelationInput[]
    cursor?: ProductTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductTagScalarFieldEnum | ProductTagScalarFieldEnum[]
  }


  /**
   * Product.combos
   */
  export type Product$combosArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Combo
     */
    select?: ComboSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ComboInclude<ExtArgs> | null
    where?: ComboWhereInput
    orderBy?: ComboOrderByWithRelationInput | ComboOrderByWithRelationInput[]
    cursor?: ComboWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComboScalarFieldEnum | ComboScalarFieldEnum[]
  }


  /**
   * Product.ComboProducts
   */
  export type Product$ComboProductsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComboProducts
     */
    select?: ComboProductsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ComboProductsInclude<ExtArgs> | null
    where?: ComboProductsWhereInput
    orderBy?: ComboProductsOrderByWithRelationInput | ComboProductsOrderByWithRelationInput[]
    cursor?: ComboProductsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComboProductsScalarFieldEnum | ComboProductsScalarFieldEnum[]
  }


  /**
   * Product.Combo
   */
  export type Product$ComboArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Combo
     */
    select?: ComboSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ComboInclude<ExtArgs> | null
    where?: ComboWhereInput
    orderBy?: ComboOrderByWithRelationInput | ComboOrderByWithRelationInput[]
    cursor?: ComboWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComboScalarFieldEnum | ComboScalarFieldEnum[]
  }


  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
  }



  /**
   * Model Accompaniment
   */

  export type AggregateAccompaniment = {
    _count: AccompanimentCountAggregateOutputType | null
    _avg: AccompanimentAvgAggregateOutputType | null
    _sum: AccompanimentSumAggregateOutputType | null
    _min: AccompanimentMinAggregateOutputType | null
    _max: AccompanimentMaxAggregateOutputType | null
  }

  export type AccompanimentAvgAggregateOutputType = {
    id: number | null
    productId: number | null
  }

  export type AccompanimentSumAggregateOutputType = {
    id: number | null
    productId: number | null
  }

  export type AccompanimentMinAggregateOutputType = {
    id: number | null
    uuid: string | null
    productId: number | null
  }

  export type AccompanimentMaxAggregateOutputType = {
    id: number | null
    uuid: string | null
    productId: number | null
  }

  export type AccompanimentCountAggregateOutputType = {
    id: number
    uuid: number
    productId: number
    _all: number
  }


  export type AccompanimentAvgAggregateInputType = {
    id?: true
    productId?: true
  }

  export type AccompanimentSumAggregateInputType = {
    id?: true
    productId?: true
  }

  export type AccompanimentMinAggregateInputType = {
    id?: true
    uuid?: true
    productId?: true
  }

  export type AccompanimentMaxAggregateInputType = {
    id?: true
    uuid?: true
    productId?: true
  }

  export type AccompanimentCountAggregateInputType = {
    id?: true
    uuid?: true
    productId?: true
    _all?: true
  }

  export type AccompanimentAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accompaniment to aggregate.
     */
    where?: AccompanimentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accompaniments to fetch.
     */
    orderBy?: AccompanimentOrderByWithRelationInput | AccompanimentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccompanimentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accompaniments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accompaniments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accompaniments
    **/
    _count?: true | AccompanimentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccompanimentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccompanimentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccompanimentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccompanimentMaxAggregateInputType
  }

  export type GetAccompanimentAggregateType<T extends AccompanimentAggregateArgs> = {
        [P in keyof T & keyof AggregateAccompaniment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccompaniment[P]>
      : GetScalarType<T[P], AggregateAccompaniment[P]>
  }




  export type AccompanimentGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: AccompanimentWhereInput
    orderBy?: AccompanimentOrderByWithAggregationInput | AccompanimentOrderByWithAggregationInput[]
    by: AccompanimentScalarFieldEnum[] | AccompanimentScalarFieldEnum
    having?: AccompanimentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccompanimentCountAggregateInputType | true
    _avg?: AccompanimentAvgAggregateInputType
    _sum?: AccompanimentSumAggregateInputType
    _min?: AccompanimentMinAggregateInputType
    _max?: AccompanimentMaxAggregateInputType
  }

  export type AccompanimentGroupByOutputType = {
    id: number
    uuid: string
    productId: number
    _count: AccompanimentCountAggregateOutputType | null
    _avg: AccompanimentAvgAggregateOutputType | null
    _sum: AccompanimentSumAggregateOutputType | null
    _min: AccompanimentMinAggregateOutputType | null
    _max: AccompanimentMaxAggregateOutputType | null
  }

  type GetAccompanimentGroupByPayload<T extends AccompanimentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccompanimentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccompanimentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccompanimentGroupByOutputType[P]>
            : GetScalarType<T[P], AccompanimentGroupByOutputType[P]>
        }
      >
    >


  export type AccompanimentSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    productId?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["accompaniment"]>

  export type AccompanimentSelectScalar = {
    id?: boolean
    uuid?: boolean
    productId?: boolean
  }

  export type AccompanimentInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }


  export type $AccompanimentPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "Accompaniment"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetResult<{
      id: number
      uuid: string
      productId: number
    }, ExtArgs["result"]["accompaniment"]>
    composites: {}
  }


  type AccompanimentGetPayload<S extends boolean | null | undefined | AccompanimentDefaultArgs> = $Result.GetResult<Prisma.$AccompanimentPayload, S>

  type AccompanimentCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<AccompanimentFindManyArgs, 'select' | 'include'> & {
      select?: AccompanimentCountAggregateInputType | true
    }

  export interface AccompanimentDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Accompaniment'], meta: { name: 'Accompaniment' } }
    /**
     * Find zero or one Accompaniment that matches the filter.
     * @param {AccompanimentFindUniqueArgs} args - Arguments to find a Accompaniment
     * @example
     * // Get one Accompaniment
     * const accompaniment = await prisma.accompaniment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AccompanimentFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AccompanimentFindUniqueArgs<ExtArgs>>
    ): Prisma__AccompanimentClient<$Result.GetResult<Prisma.$AccompanimentPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Accompaniment that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AccompanimentFindUniqueOrThrowArgs} args - Arguments to find a Accompaniment
     * @example
     * // Get one Accompaniment
     * const accompaniment = await prisma.accompaniment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AccompanimentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AccompanimentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AccompanimentClient<$Result.GetResult<Prisma.$AccompanimentPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Accompaniment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccompanimentFindFirstArgs} args - Arguments to find a Accompaniment
     * @example
     * // Get one Accompaniment
     * const accompaniment = await prisma.accompaniment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AccompanimentFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AccompanimentFindFirstArgs<ExtArgs>>
    ): Prisma__AccompanimentClient<$Result.GetResult<Prisma.$AccompanimentPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Accompaniment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccompanimentFindFirstOrThrowArgs} args - Arguments to find a Accompaniment
     * @example
     * // Get one Accompaniment
     * const accompaniment = await prisma.accompaniment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AccompanimentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AccompanimentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AccompanimentClient<$Result.GetResult<Prisma.$AccompanimentPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Accompaniments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccompanimentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accompaniments
     * const accompaniments = await prisma.accompaniment.findMany()
     * 
     * // Get first 10 Accompaniments
     * const accompaniments = await prisma.accompaniment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accompanimentWithIdOnly = await prisma.accompaniment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AccompanimentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AccompanimentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccompanimentPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Accompaniment.
     * @param {AccompanimentCreateArgs} args - Arguments to create a Accompaniment.
     * @example
     * // Create one Accompaniment
     * const Accompaniment = await prisma.accompaniment.create({
     *   data: {
     *     // ... data to create a Accompaniment
     *   }
     * })
     * 
    **/
    create<T extends AccompanimentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AccompanimentCreateArgs<ExtArgs>>
    ): Prisma__AccompanimentClient<$Result.GetResult<Prisma.$AccompanimentPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Accompaniments.
     *     @param {AccompanimentCreateManyArgs} args - Arguments to create many Accompaniments.
     *     @example
     *     // Create many Accompaniments
     *     const accompaniment = await prisma.accompaniment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AccompanimentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AccompanimentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Accompaniment.
     * @param {AccompanimentDeleteArgs} args - Arguments to delete one Accompaniment.
     * @example
     * // Delete one Accompaniment
     * const Accompaniment = await prisma.accompaniment.delete({
     *   where: {
     *     // ... filter to delete one Accompaniment
     *   }
     * })
     * 
    **/
    delete<T extends AccompanimentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AccompanimentDeleteArgs<ExtArgs>>
    ): Prisma__AccompanimentClient<$Result.GetResult<Prisma.$AccompanimentPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Accompaniment.
     * @param {AccompanimentUpdateArgs} args - Arguments to update one Accompaniment.
     * @example
     * // Update one Accompaniment
     * const accompaniment = await prisma.accompaniment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AccompanimentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AccompanimentUpdateArgs<ExtArgs>>
    ): Prisma__AccompanimentClient<$Result.GetResult<Prisma.$AccompanimentPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Accompaniments.
     * @param {AccompanimentDeleteManyArgs} args - Arguments to filter Accompaniments to delete.
     * @example
     * // Delete a few Accompaniments
     * const { count } = await prisma.accompaniment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AccompanimentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AccompanimentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accompaniments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccompanimentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accompaniments
     * const accompaniment = await prisma.accompaniment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AccompanimentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AccompanimentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Accompaniment.
     * @param {AccompanimentUpsertArgs} args - Arguments to update or create a Accompaniment.
     * @example
     * // Update or create a Accompaniment
     * const accompaniment = await prisma.accompaniment.upsert({
     *   create: {
     *     // ... data to create a Accompaniment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Accompaniment we want to update
     *   }
     * })
    **/
    upsert<T extends AccompanimentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AccompanimentUpsertArgs<ExtArgs>>
    ): Prisma__AccompanimentClient<$Result.GetResult<Prisma.$AccompanimentPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Accompaniments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccompanimentCountArgs} args - Arguments to filter Accompaniments to count.
     * @example
     * // Count the number of Accompaniments
     * const count = await prisma.accompaniment.count({
     *   where: {
     *     // ... the filter for the Accompaniments we want to count
     *   }
     * })
    **/
    count<T extends AccompanimentCountArgs>(
      args?: Subset<T, AccompanimentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccompanimentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Accompaniment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccompanimentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccompanimentAggregateArgs>(args: Subset<T, AccompanimentAggregateArgs>): Prisma.PrismaPromise<GetAccompanimentAggregateType<T>>

    /**
     * Group by Accompaniment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccompanimentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccompanimentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccompanimentGroupByArgs['orderBy'] }
        : { orderBy?: AccompanimentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccompanimentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccompanimentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Accompaniment model
   */
  readonly fields: AccompanimentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Accompaniment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccompanimentClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Accompaniment model
   */ 
  interface AccompanimentFieldRefs {
    readonly id: FieldRef<"Accompaniment", 'Int'>
    readonly uuid: FieldRef<"Accompaniment", 'String'>
    readonly productId: FieldRef<"Accompaniment", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Accompaniment findUnique
   */
  export type AccompanimentFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Accompaniment
     */
    select?: AccompanimentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccompanimentInclude<ExtArgs> | null
    /**
     * Filter, which Accompaniment to fetch.
     */
    where: AccompanimentWhereUniqueInput
  }


  /**
   * Accompaniment findUniqueOrThrow
   */
  export type AccompanimentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Accompaniment
     */
    select?: AccompanimentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccompanimentInclude<ExtArgs> | null
    /**
     * Filter, which Accompaniment to fetch.
     */
    where: AccompanimentWhereUniqueInput
  }


  /**
   * Accompaniment findFirst
   */
  export type AccompanimentFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Accompaniment
     */
    select?: AccompanimentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccompanimentInclude<ExtArgs> | null
    /**
     * Filter, which Accompaniment to fetch.
     */
    where?: AccompanimentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accompaniments to fetch.
     */
    orderBy?: AccompanimentOrderByWithRelationInput | AccompanimentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accompaniments.
     */
    cursor?: AccompanimentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accompaniments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accompaniments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accompaniments.
     */
    distinct?: AccompanimentScalarFieldEnum | AccompanimentScalarFieldEnum[]
  }


  /**
   * Accompaniment findFirstOrThrow
   */
  export type AccompanimentFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Accompaniment
     */
    select?: AccompanimentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccompanimentInclude<ExtArgs> | null
    /**
     * Filter, which Accompaniment to fetch.
     */
    where?: AccompanimentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accompaniments to fetch.
     */
    orderBy?: AccompanimentOrderByWithRelationInput | AccompanimentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accompaniments.
     */
    cursor?: AccompanimentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accompaniments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accompaniments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accompaniments.
     */
    distinct?: AccompanimentScalarFieldEnum | AccompanimentScalarFieldEnum[]
  }


  /**
   * Accompaniment findMany
   */
  export type AccompanimentFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Accompaniment
     */
    select?: AccompanimentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccompanimentInclude<ExtArgs> | null
    /**
     * Filter, which Accompaniments to fetch.
     */
    where?: AccompanimentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accompaniments to fetch.
     */
    orderBy?: AccompanimentOrderByWithRelationInput | AccompanimentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accompaniments.
     */
    cursor?: AccompanimentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accompaniments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accompaniments.
     */
    skip?: number
    distinct?: AccompanimentScalarFieldEnum | AccompanimentScalarFieldEnum[]
  }


  /**
   * Accompaniment create
   */
  export type AccompanimentCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Accompaniment
     */
    select?: AccompanimentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccompanimentInclude<ExtArgs> | null
    /**
     * The data needed to create a Accompaniment.
     */
    data: XOR<AccompanimentCreateInput, AccompanimentUncheckedCreateInput>
  }


  /**
   * Accompaniment createMany
   */
  export type AccompanimentCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accompaniments.
     */
    data: AccompanimentCreateManyInput | AccompanimentCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Accompaniment update
   */
  export type AccompanimentUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Accompaniment
     */
    select?: AccompanimentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccompanimentInclude<ExtArgs> | null
    /**
     * The data needed to update a Accompaniment.
     */
    data: XOR<AccompanimentUpdateInput, AccompanimentUncheckedUpdateInput>
    /**
     * Choose, which Accompaniment to update.
     */
    where: AccompanimentWhereUniqueInput
  }


  /**
   * Accompaniment updateMany
   */
  export type AccompanimentUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accompaniments.
     */
    data: XOR<AccompanimentUpdateManyMutationInput, AccompanimentUncheckedUpdateManyInput>
    /**
     * Filter which Accompaniments to update
     */
    where?: AccompanimentWhereInput
  }


  /**
   * Accompaniment upsert
   */
  export type AccompanimentUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Accompaniment
     */
    select?: AccompanimentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccompanimentInclude<ExtArgs> | null
    /**
     * The filter to search for the Accompaniment to update in case it exists.
     */
    where: AccompanimentWhereUniqueInput
    /**
     * In case the Accompaniment found by the `where` argument doesn't exist, create a new Accompaniment with this data.
     */
    create: XOR<AccompanimentCreateInput, AccompanimentUncheckedCreateInput>
    /**
     * In case the Accompaniment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccompanimentUpdateInput, AccompanimentUncheckedUpdateInput>
  }


  /**
   * Accompaniment delete
   */
  export type AccompanimentDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Accompaniment
     */
    select?: AccompanimentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccompanimentInclude<ExtArgs> | null
    /**
     * Filter which Accompaniment to delete.
     */
    where: AccompanimentWhereUniqueInput
  }


  /**
   * Accompaniment deleteMany
   */
  export type AccompanimentDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accompaniments to delete
     */
    where?: AccompanimentWhereInput
  }


  /**
   * Accompaniment without action
   */
  export type AccompanimentDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Accompaniment
     */
    select?: AccompanimentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccompanimentInclude<ExtArgs> | null
  }



  /**
   * Model Additional
   */

  export type AggregateAdditional = {
    _count: AdditionalCountAggregateOutputType | null
    _avg: AdditionalAvgAggregateOutputType | null
    _sum: AdditionalSumAggregateOutputType | null
    _min: AdditionalMinAggregateOutputType | null
    _max: AdditionalMaxAggregateOutputType | null
  }

  export type AdditionalAvgAggregateOutputType = {
    id: number | null
    productId: number | null
  }

  export type AdditionalSumAggregateOutputType = {
    id: number | null
    productId: number | null
  }

  export type AdditionalMinAggregateOutputType = {
    id: number | null
    uuid: string | null
    productId: number | null
  }

  export type AdditionalMaxAggregateOutputType = {
    id: number | null
    uuid: string | null
    productId: number | null
  }

  export type AdditionalCountAggregateOutputType = {
    id: number
    uuid: number
    productId: number
    _all: number
  }


  export type AdditionalAvgAggregateInputType = {
    id?: true
    productId?: true
  }

  export type AdditionalSumAggregateInputType = {
    id?: true
    productId?: true
  }

  export type AdditionalMinAggregateInputType = {
    id?: true
    uuid?: true
    productId?: true
  }

  export type AdditionalMaxAggregateInputType = {
    id?: true
    uuid?: true
    productId?: true
  }

  export type AdditionalCountAggregateInputType = {
    id?: true
    uuid?: true
    productId?: true
    _all?: true
  }

  export type AdditionalAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Additional to aggregate.
     */
    where?: AdditionalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Additionals to fetch.
     */
    orderBy?: AdditionalOrderByWithRelationInput | AdditionalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdditionalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Additionals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Additionals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Additionals
    **/
    _count?: true | AdditionalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdditionalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdditionalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdditionalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdditionalMaxAggregateInputType
  }

  export type GetAdditionalAggregateType<T extends AdditionalAggregateArgs> = {
        [P in keyof T & keyof AggregateAdditional]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdditional[P]>
      : GetScalarType<T[P], AggregateAdditional[P]>
  }




  export type AdditionalGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: AdditionalWhereInput
    orderBy?: AdditionalOrderByWithAggregationInput | AdditionalOrderByWithAggregationInput[]
    by: AdditionalScalarFieldEnum[] | AdditionalScalarFieldEnum
    having?: AdditionalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdditionalCountAggregateInputType | true
    _avg?: AdditionalAvgAggregateInputType
    _sum?: AdditionalSumAggregateInputType
    _min?: AdditionalMinAggregateInputType
    _max?: AdditionalMaxAggregateInputType
  }

  export type AdditionalGroupByOutputType = {
    id: number
    uuid: string
    productId: number
    _count: AdditionalCountAggregateOutputType | null
    _avg: AdditionalAvgAggregateOutputType | null
    _sum: AdditionalSumAggregateOutputType | null
    _min: AdditionalMinAggregateOutputType | null
    _max: AdditionalMaxAggregateOutputType | null
  }

  type GetAdditionalGroupByPayload<T extends AdditionalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdditionalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdditionalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdditionalGroupByOutputType[P]>
            : GetScalarType<T[P], AdditionalGroupByOutputType[P]>
        }
      >
    >


  export type AdditionalSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    productId?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["additional"]>

  export type AdditionalSelectScalar = {
    id?: boolean
    uuid?: boolean
    productId?: boolean
  }

  export type AdditionalInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }


  export type $AdditionalPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "Additional"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetResult<{
      id: number
      uuid: string
      productId: number
    }, ExtArgs["result"]["additional"]>
    composites: {}
  }


  type AdditionalGetPayload<S extends boolean | null | undefined | AdditionalDefaultArgs> = $Result.GetResult<Prisma.$AdditionalPayload, S>

  type AdditionalCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<AdditionalFindManyArgs, 'select' | 'include'> & {
      select?: AdditionalCountAggregateInputType | true
    }

  export interface AdditionalDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Additional'], meta: { name: 'Additional' } }
    /**
     * Find zero or one Additional that matches the filter.
     * @param {AdditionalFindUniqueArgs} args - Arguments to find a Additional
     * @example
     * // Get one Additional
     * const additional = await prisma.additional.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AdditionalFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AdditionalFindUniqueArgs<ExtArgs>>
    ): Prisma__AdditionalClient<$Result.GetResult<Prisma.$AdditionalPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Additional that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AdditionalFindUniqueOrThrowArgs} args - Arguments to find a Additional
     * @example
     * // Get one Additional
     * const additional = await prisma.additional.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AdditionalFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AdditionalFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AdditionalClient<$Result.GetResult<Prisma.$AdditionalPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Additional that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdditionalFindFirstArgs} args - Arguments to find a Additional
     * @example
     * // Get one Additional
     * const additional = await prisma.additional.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AdditionalFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AdditionalFindFirstArgs<ExtArgs>>
    ): Prisma__AdditionalClient<$Result.GetResult<Prisma.$AdditionalPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Additional that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdditionalFindFirstOrThrowArgs} args - Arguments to find a Additional
     * @example
     * // Get one Additional
     * const additional = await prisma.additional.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AdditionalFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AdditionalFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AdditionalClient<$Result.GetResult<Prisma.$AdditionalPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Additionals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdditionalFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Additionals
     * const additionals = await prisma.additional.findMany()
     * 
     * // Get first 10 Additionals
     * const additionals = await prisma.additional.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const additionalWithIdOnly = await prisma.additional.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AdditionalFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AdditionalFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdditionalPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Additional.
     * @param {AdditionalCreateArgs} args - Arguments to create a Additional.
     * @example
     * // Create one Additional
     * const Additional = await prisma.additional.create({
     *   data: {
     *     // ... data to create a Additional
     *   }
     * })
     * 
    **/
    create<T extends AdditionalCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AdditionalCreateArgs<ExtArgs>>
    ): Prisma__AdditionalClient<$Result.GetResult<Prisma.$AdditionalPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Additionals.
     *     @param {AdditionalCreateManyArgs} args - Arguments to create many Additionals.
     *     @example
     *     // Create many Additionals
     *     const additional = await prisma.additional.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AdditionalCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AdditionalCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Additional.
     * @param {AdditionalDeleteArgs} args - Arguments to delete one Additional.
     * @example
     * // Delete one Additional
     * const Additional = await prisma.additional.delete({
     *   where: {
     *     // ... filter to delete one Additional
     *   }
     * })
     * 
    **/
    delete<T extends AdditionalDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AdditionalDeleteArgs<ExtArgs>>
    ): Prisma__AdditionalClient<$Result.GetResult<Prisma.$AdditionalPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Additional.
     * @param {AdditionalUpdateArgs} args - Arguments to update one Additional.
     * @example
     * // Update one Additional
     * const additional = await prisma.additional.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AdditionalUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AdditionalUpdateArgs<ExtArgs>>
    ): Prisma__AdditionalClient<$Result.GetResult<Prisma.$AdditionalPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Additionals.
     * @param {AdditionalDeleteManyArgs} args - Arguments to filter Additionals to delete.
     * @example
     * // Delete a few Additionals
     * const { count } = await prisma.additional.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AdditionalDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AdditionalDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Additionals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdditionalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Additionals
     * const additional = await prisma.additional.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AdditionalUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AdditionalUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Additional.
     * @param {AdditionalUpsertArgs} args - Arguments to update or create a Additional.
     * @example
     * // Update or create a Additional
     * const additional = await prisma.additional.upsert({
     *   create: {
     *     // ... data to create a Additional
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Additional we want to update
     *   }
     * })
    **/
    upsert<T extends AdditionalUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AdditionalUpsertArgs<ExtArgs>>
    ): Prisma__AdditionalClient<$Result.GetResult<Prisma.$AdditionalPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Additionals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdditionalCountArgs} args - Arguments to filter Additionals to count.
     * @example
     * // Count the number of Additionals
     * const count = await prisma.additional.count({
     *   where: {
     *     // ... the filter for the Additionals we want to count
     *   }
     * })
    **/
    count<T extends AdditionalCountArgs>(
      args?: Subset<T, AdditionalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdditionalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Additional.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdditionalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdditionalAggregateArgs>(args: Subset<T, AdditionalAggregateArgs>): Prisma.PrismaPromise<GetAdditionalAggregateType<T>>

    /**
     * Group by Additional.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdditionalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdditionalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdditionalGroupByArgs['orderBy'] }
        : { orderBy?: AdditionalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdditionalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdditionalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Additional model
   */
  readonly fields: AdditionalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Additional.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdditionalClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Additional model
   */ 
  interface AdditionalFieldRefs {
    readonly id: FieldRef<"Additional", 'Int'>
    readonly uuid: FieldRef<"Additional", 'String'>
    readonly productId: FieldRef<"Additional", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Additional findUnique
   */
  export type AdditionalFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Additional
     */
    select?: AdditionalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdditionalInclude<ExtArgs> | null
    /**
     * Filter, which Additional to fetch.
     */
    where: AdditionalWhereUniqueInput
  }


  /**
   * Additional findUniqueOrThrow
   */
  export type AdditionalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Additional
     */
    select?: AdditionalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdditionalInclude<ExtArgs> | null
    /**
     * Filter, which Additional to fetch.
     */
    where: AdditionalWhereUniqueInput
  }


  /**
   * Additional findFirst
   */
  export type AdditionalFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Additional
     */
    select?: AdditionalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdditionalInclude<ExtArgs> | null
    /**
     * Filter, which Additional to fetch.
     */
    where?: AdditionalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Additionals to fetch.
     */
    orderBy?: AdditionalOrderByWithRelationInput | AdditionalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Additionals.
     */
    cursor?: AdditionalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Additionals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Additionals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Additionals.
     */
    distinct?: AdditionalScalarFieldEnum | AdditionalScalarFieldEnum[]
  }


  /**
   * Additional findFirstOrThrow
   */
  export type AdditionalFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Additional
     */
    select?: AdditionalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdditionalInclude<ExtArgs> | null
    /**
     * Filter, which Additional to fetch.
     */
    where?: AdditionalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Additionals to fetch.
     */
    orderBy?: AdditionalOrderByWithRelationInput | AdditionalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Additionals.
     */
    cursor?: AdditionalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Additionals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Additionals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Additionals.
     */
    distinct?: AdditionalScalarFieldEnum | AdditionalScalarFieldEnum[]
  }


  /**
   * Additional findMany
   */
  export type AdditionalFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Additional
     */
    select?: AdditionalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdditionalInclude<ExtArgs> | null
    /**
     * Filter, which Additionals to fetch.
     */
    where?: AdditionalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Additionals to fetch.
     */
    orderBy?: AdditionalOrderByWithRelationInput | AdditionalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Additionals.
     */
    cursor?: AdditionalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Additionals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Additionals.
     */
    skip?: number
    distinct?: AdditionalScalarFieldEnum | AdditionalScalarFieldEnum[]
  }


  /**
   * Additional create
   */
  export type AdditionalCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Additional
     */
    select?: AdditionalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdditionalInclude<ExtArgs> | null
    /**
     * The data needed to create a Additional.
     */
    data: XOR<AdditionalCreateInput, AdditionalUncheckedCreateInput>
  }


  /**
   * Additional createMany
   */
  export type AdditionalCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Additionals.
     */
    data: AdditionalCreateManyInput | AdditionalCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Additional update
   */
  export type AdditionalUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Additional
     */
    select?: AdditionalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdditionalInclude<ExtArgs> | null
    /**
     * The data needed to update a Additional.
     */
    data: XOR<AdditionalUpdateInput, AdditionalUncheckedUpdateInput>
    /**
     * Choose, which Additional to update.
     */
    where: AdditionalWhereUniqueInput
  }


  /**
   * Additional updateMany
   */
  export type AdditionalUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Additionals.
     */
    data: XOR<AdditionalUpdateManyMutationInput, AdditionalUncheckedUpdateManyInput>
    /**
     * Filter which Additionals to update
     */
    where?: AdditionalWhereInput
  }


  /**
   * Additional upsert
   */
  export type AdditionalUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Additional
     */
    select?: AdditionalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdditionalInclude<ExtArgs> | null
    /**
     * The filter to search for the Additional to update in case it exists.
     */
    where: AdditionalWhereUniqueInput
    /**
     * In case the Additional found by the `where` argument doesn't exist, create a new Additional with this data.
     */
    create: XOR<AdditionalCreateInput, AdditionalUncheckedCreateInput>
    /**
     * In case the Additional was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdditionalUpdateInput, AdditionalUncheckedUpdateInput>
  }


  /**
   * Additional delete
   */
  export type AdditionalDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Additional
     */
    select?: AdditionalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdditionalInclude<ExtArgs> | null
    /**
     * Filter which Additional to delete.
     */
    where: AdditionalWhereUniqueInput
  }


  /**
   * Additional deleteMany
   */
  export type AdditionalDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Additionals to delete
     */
    where?: AdditionalWhereInput
  }


  /**
   * Additional without action
   */
  export type AdditionalDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Additional
     */
    select?: AdditionalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdditionalInclude<ExtArgs> | null
  }



  /**
   * Model Order
   */

  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  export type OrderAvgAggregateOutputType = {
    id: number | null
    totalPrice: number | null
    userId: number | null
    enterpriseId: number | null
  }

  export type OrderSumAggregateOutputType = {
    id: number | null
    totalPrice: number | null
    userId: number | null
    enterpriseId: number | null
  }

  export type OrderMinAggregateOutputType = {
    id: number | null
    uuid: string | null
    totalPrice: number | null
    status: string | null
    updatedAt: Date | null
    orderDate: Date | null
    userId: number | null
    enterpriseId: number | null
  }

  export type OrderMaxAggregateOutputType = {
    id: number | null
    uuid: string | null
    totalPrice: number | null
    status: string | null
    updatedAt: Date | null
    orderDate: Date | null
    userId: number | null
    enterpriseId: number | null
  }

  export type OrderCountAggregateOutputType = {
    id: number
    uuid: number
    totalPrice: number
    status: number
    updatedAt: number
    orderDate: number
    userId: number
    enterpriseId: number
    _all: number
  }


  export type OrderAvgAggregateInputType = {
    id?: true
    totalPrice?: true
    userId?: true
    enterpriseId?: true
  }

  export type OrderSumAggregateInputType = {
    id?: true
    totalPrice?: true
    userId?: true
    enterpriseId?: true
  }

  export type OrderMinAggregateInputType = {
    id?: true
    uuid?: true
    totalPrice?: true
    status?: true
    updatedAt?: true
    orderDate?: true
    userId?: true
    enterpriseId?: true
  }

  export type OrderMaxAggregateInputType = {
    id?: true
    uuid?: true
    totalPrice?: true
    status?: true
    updatedAt?: true
    orderDate?: true
    userId?: true
    enterpriseId?: true
  }

  export type OrderCountAggregateInputType = {
    id?: true
    uuid?: true
    totalPrice?: true
    status?: true
    updatedAt?: true
    orderDate?: true
    userId?: true
    enterpriseId?: true
    _all?: true
  }

  export type OrderAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Order to aggregate.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orders
    **/
    _count?: true | OrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderMaxAggregateInputType
  }

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>
  }




  export type OrderGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithAggregationInput | OrderOrderByWithAggregationInput[]
    by: OrderScalarFieldEnum[] | OrderScalarFieldEnum
    having?: OrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCountAggregateInputType | true
    _avg?: OrderAvgAggregateInputType
    _sum?: OrderSumAggregateInputType
    _min?: OrderMinAggregateInputType
    _max?: OrderMaxAggregateInputType
  }

  export type OrderGroupByOutputType = {
    id: number
    uuid: string
    totalPrice: number
    status: string
    updatedAt: Date
    orderDate: Date
    userId: number
    enterpriseId: number
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  type GetOrderGroupByPayload<T extends OrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
        }
      >
    >


  export type OrderSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    totalPrice?: boolean
    status?: boolean
    updatedAt?: boolean
    orderDate?: boolean
    userId?: boolean
    enterpriseId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    products?: boolean | Order$productsArgs<ExtArgs>
    enterprise?: boolean | EnterpriseDefaultArgs<ExtArgs>
    orderItems?: boolean | Order$orderItemsArgs<ExtArgs>
    orderHistories?: boolean | Order$orderHistoriesArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectScalar = {
    id?: boolean
    uuid?: boolean
    totalPrice?: boolean
    status?: boolean
    updatedAt?: boolean
    orderDate?: boolean
    userId?: boolean
    enterpriseId?: boolean
  }

  export type OrderInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    products?: boolean | Order$productsArgs<ExtArgs>
    enterprise?: boolean | EnterpriseDefaultArgs<ExtArgs>
    orderItems?: boolean | Order$orderItemsArgs<ExtArgs>
    orderHistories?: boolean | Order$orderHistoriesArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $OrderPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "Order"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      products: Prisma.$ProductPayload<ExtArgs>[]
      enterprise: Prisma.$EnterprisePayload<ExtArgs>
      orderItems: Prisma.$OrderItemPayload<ExtArgs>[]
      orderHistories: Prisma.$OrderHistoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetResult<{
      id: number
      uuid: string
      totalPrice: number
      status: string
      updatedAt: Date
      orderDate: Date
      userId: number
      enterpriseId: number
    }, ExtArgs["result"]["order"]>
    composites: {}
  }


  type OrderGetPayload<S extends boolean | null | undefined | OrderDefaultArgs> = $Result.GetResult<Prisma.$OrderPayload, S>

  type OrderCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<OrderFindManyArgs, 'select' | 'include'> & {
      select?: OrderCountAggregateInputType | true
    }

  export interface OrderDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Order'], meta: { name: 'Order' } }
    /**
     * Find zero or one Order that matches the filter.
     * @param {OrderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OrderFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, OrderFindUniqueArgs<ExtArgs>>
    ): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Order that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {OrderFindUniqueOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OrderFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OrderFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderFindFirstArgs<ExtArgs>>
    ): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Order that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OrderFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OrderFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Order.
     * @param {OrderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     * 
    **/
    create<T extends OrderCreateArgs<ExtArgs>>(
      args: SelectSubset<T, OrderCreateArgs<ExtArgs>>
    ): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Orders.
     *     @param {OrderCreateManyArgs} args - Arguments to create many Orders.
     *     @example
     *     // Create many Orders
     *     const order = await prisma.order.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OrderCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Order.
     * @param {OrderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     * 
    **/
    delete<T extends OrderDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, OrderDeleteArgs<ExtArgs>>
    ): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Order.
     * @param {OrderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OrderUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, OrderUpdateArgs<ExtArgs>>
    ): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Orders.
     * @param {OrderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OrderDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OrderUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, OrderUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Order.
     * @param {OrderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
    **/
    upsert<T extends OrderUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, OrderUpsertArgs<ExtArgs>>
    ): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends OrderCountArgs>(
      args?: Subset<T, OrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): Prisma.PrismaPromise<GetOrderAggregateType<T>>

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderGroupByArgs['orderBy'] }
        : { orderBy?: OrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Order model
   */
  readonly fields: OrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    products<T extends Order$productsArgs<ExtArgs> = {}>(args?: Subset<T, Order$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findMany'> | Null>;

    enterprise<T extends EnterpriseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EnterpriseDefaultArgs<ExtArgs>>): Prisma__EnterpriseClient<$Result.GetResult<Prisma.$EnterprisePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    orderItems<T extends Order$orderItemsArgs<ExtArgs> = {}>(args?: Subset<T, Order$orderItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, 'findMany'> | Null>;

    orderHistories<T extends Order$orderHistoriesArgs<ExtArgs> = {}>(args?: Subset<T, Order$orderHistoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderHistoryPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Order model
   */ 
  interface OrderFieldRefs {
    readonly id: FieldRef<"Order", 'Int'>
    readonly uuid: FieldRef<"Order", 'String'>
    readonly totalPrice: FieldRef<"Order", 'Float'>
    readonly status: FieldRef<"Order", 'String'>
    readonly updatedAt: FieldRef<"Order", 'DateTime'>
    readonly orderDate: FieldRef<"Order", 'DateTime'>
    readonly userId: FieldRef<"Order", 'Int'>
    readonly enterpriseId: FieldRef<"Order", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Order findUnique
   */
  export type OrderFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }


  /**
   * Order findUniqueOrThrow
   */
  export type OrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }


  /**
   * Order findFirst
   */
  export type OrderFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }


  /**
   * Order findFirstOrThrow
   */
  export type OrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }


  /**
   * Order findMany
   */
  export type OrderFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }


  /**
   * Order create
   */
  export type OrderCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to create a Order.
     */
    data: XOR<OrderCreateInput, OrderUncheckedCreateInput>
  }


  /**
   * Order createMany
   */
  export type OrderCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Order update
   */
  export type OrderUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to update a Order.
     */
    data: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
    /**
     * Choose, which Order to update.
     */
    where: OrderWhereUniqueInput
  }


  /**
   * Order updateMany
   */
  export type OrderUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
  }


  /**
   * Order upsert
   */
  export type OrderUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The filter to search for the Order to update in case it exists.
     */
    where: OrderWhereUniqueInput
    /**
     * In case the Order found by the `where` argument doesn't exist, create a new Order with this data.
     */
    create: XOR<OrderCreateInput, OrderUncheckedCreateInput>
    /**
     * In case the Order was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
  }


  /**
   * Order delete
   */
  export type OrderDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter which Order to delete.
     */
    where: OrderWhereUniqueInput
  }


  /**
   * Order deleteMany
   */
  export type OrderDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Orders to delete
     */
    where?: OrderWhereInput
  }


  /**
   * Order.products
   */
  export type Order$productsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }


  /**
   * Order.orderItems
   */
  export type Order$orderItemsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }


  /**
   * Order.orderHistories
   */
  export type Order$orderHistoriesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderHistory
     */
    select?: OrderHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderHistoryInclude<ExtArgs> | null
    where?: OrderHistoryWhereInput
    orderBy?: OrderHistoryOrderByWithRelationInput | OrderHistoryOrderByWithRelationInput[]
    cursor?: OrderHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderHistoryScalarFieldEnum | OrderHistoryScalarFieldEnum[]
  }


  /**
   * Order without action
   */
  export type OrderDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderInclude<ExtArgs> | null
  }



  /**
   * Model OrderItem
   */

  export type AggregateOrderItem = {
    _count: OrderItemCountAggregateOutputType | null
    _avg: OrderItemAvgAggregateOutputType | null
    _sum: OrderItemSumAggregateOutputType | null
    _min: OrderItemMinAggregateOutputType | null
    _max: OrderItemMaxAggregateOutputType | null
  }

  export type OrderItemAvgAggregateOutputType = {
    id: number | null
    quantity: number | null
    price: number | null
    productId: number | null
    orderId: number | null
  }

  export type OrderItemSumAggregateOutputType = {
    id: number | null
    quantity: number | null
    price: number | null
    productId: number | null
    orderId: number | null
  }

  export type OrderItemMinAggregateOutputType = {
    id: number | null
    uuid: string | null
    quantity: number | null
    price: number | null
    productId: number | null
    orderId: number | null
  }

  export type OrderItemMaxAggregateOutputType = {
    id: number | null
    uuid: string | null
    quantity: number | null
    price: number | null
    productId: number | null
    orderId: number | null
  }

  export type OrderItemCountAggregateOutputType = {
    id: number
    uuid: number
    quantity: number
    price: number
    productId: number
    orderId: number
    _all: number
  }


  export type OrderItemAvgAggregateInputType = {
    id?: true
    quantity?: true
    price?: true
    productId?: true
    orderId?: true
  }

  export type OrderItemSumAggregateInputType = {
    id?: true
    quantity?: true
    price?: true
    productId?: true
    orderId?: true
  }

  export type OrderItemMinAggregateInputType = {
    id?: true
    uuid?: true
    quantity?: true
    price?: true
    productId?: true
    orderId?: true
  }

  export type OrderItemMaxAggregateInputType = {
    id?: true
    uuid?: true
    quantity?: true
    price?: true
    productId?: true
    orderId?: true
  }

  export type OrderItemCountAggregateInputType = {
    id?: true
    uuid?: true
    quantity?: true
    price?: true
    productId?: true
    orderId?: true
    _all?: true
  }

  export type OrderItemAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItem to aggregate.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderItems
    **/
    _count?: true | OrderItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderItemMaxAggregateInputType
  }

  export type GetOrderItemAggregateType<T extends OrderItemAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderItem[P]>
      : GetScalarType<T[P], AggregateOrderItem[P]>
  }




  export type OrderItemGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithAggregationInput | OrderItemOrderByWithAggregationInput[]
    by: OrderItemScalarFieldEnum[] | OrderItemScalarFieldEnum
    having?: OrderItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderItemCountAggregateInputType | true
    _avg?: OrderItemAvgAggregateInputType
    _sum?: OrderItemSumAggregateInputType
    _min?: OrderItemMinAggregateInputType
    _max?: OrderItemMaxAggregateInputType
  }

  export type OrderItemGroupByOutputType = {
    id: number
    uuid: string
    quantity: number
    price: number
    productId: number
    orderId: number
    _count: OrderItemCountAggregateOutputType | null
    _avg: OrderItemAvgAggregateOutputType | null
    _sum: OrderItemSumAggregateOutputType | null
    _min: OrderItemMinAggregateOutputType | null
    _max: OrderItemMaxAggregateOutputType | null
  }

  type GetOrderItemGroupByPayload<T extends OrderItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
            : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
        }
      >
    >


  export type OrderItemSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    quantity?: boolean
    price?: boolean
    productId?: boolean
    orderId?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>

  export type OrderItemSelectScalar = {
    id?: boolean
    uuid?: boolean
    quantity?: boolean
    price?: boolean
    productId?: boolean
    orderId?: boolean
  }

  export type OrderItemInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }


  export type $OrderItemPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "OrderItem"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
      order: Prisma.$OrderPayload<ExtArgs>
    }
    scalars: $Extensions.GetResult<{
      id: number
      uuid: string
      quantity: number
      price: number
      productId: number
      orderId: number
    }, ExtArgs["result"]["orderItem"]>
    composites: {}
  }


  type OrderItemGetPayload<S extends boolean | null | undefined | OrderItemDefaultArgs> = $Result.GetResult<Prisma.$OrderItemPayload, S>

  type OrderItemCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<OrderItemFindManyArgs, 'select' | 'include'> & {
      select?: OrderItemCountAggregateInputType | true
    }

  export interface OrderItemDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderItem'], meta: { name: 'OrderItem' } }
    /**
     * Find zero or one OrderItem that matches the filter.
     * @param {OrderItemFindUniqueArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OrderItemFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, OrderItemFindUniqueArgs<ExtArgs>>
    ): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one OrderItem that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {OrderItemFindUniqueOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OrderItemFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderItemFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first OrderItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OrderItemFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderItemFindFirstArgs<ExtArgs>>
    ): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first OrderItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OrderItemFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderItemFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more OrderItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderItems
     * const orderItems = await prisma.orderItem.findMany()
     * 
     * // Get first 10 OrderItems
     * const orderItems = await prisma.orderItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OrderItemFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderItemFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a OrderItem.
     * @param {OrderItemCreateArgs} args - Arguments to create a OrderItem.
     * @example
     * // Create one OrderItem
     * const OrderItem = await prisma.orderItem.create({
     *   data: {
     *     // ... data to create a OrderItem
     *   }
     * })
     * 
    **/
    create<T extends OrderItemCreateArgs<ExtArgs>>(
      args: SelectSubset<T, OrderItemCreateArgs<ExtArgs>>
    ): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many OrderItems.
     *     @param {OrderItemCreateManyArgs} args - Arguments to create many OrderItems.
     *     @example
     *     // Create many OrderItems
     *     const orderItem = await prisma.orderItem.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OrderItemCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderItemCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OrderItem.
     * @param {OrderItemDeleteArgs} args - Arguments to delete one OrderItem.
     * @example
     * // Delete one OrderItem
     * const OrderItem = await prisma.orderItem.delete({
     *   where: {
     *     // ... filter to delete one OrderItem
     *   }
     * })
     * 
    **/
    delete<T extends OrderItemDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, OrderItemDeleteArgs<ExtArgs>>
    ): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one OrderItem.
     * @param {OrderItemUpdateArgs} args - Arguments to update one OrderItem.
     * @example
     * // Update one OrderItem
     * const orderItem = await prisma.orderItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OrderItemUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, OrderItemUpdateArgs<ExtArgs>>
    ): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more OrderItems.
     * @param {OrderItemDeleteManyArgs} args - Arguments to filter OrderItems to delete.
     * @example
     * // Delete a few OrderItems
     * const { count } = await prisma.orderItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OrderItemDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderItemDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderItems
     * const orderItem = await prisma.orderItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OrderItemUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, OrderItemUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OrderItem.
     * @param {OrderItemUpsertArgs} args - Arguments to update or create a OrderItem.
     * @example
     * // Update or create a OrderItem
     * const orderItem = await prisma.orderItem.upsert({
     *   create: {
     *     // ... data to create a OrderItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderItem we want to update
     *   }
     * })
    **/
    upsert<T extends OrderItemUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, OrderItemUpsertArgs<ExtArgs>>
    ): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemCountArgs} args - Arguments to filter OrderItems to count.
     * @example
     * // Count the number of OrderItems
     * const count = await prisma.orderItem.count({
     *   where: {
     *     // ... the filter for the OrderItems we want to count
     *   }
     * })
    **/
    count<T extends OrderItemCountArgs>(
      args?: Subset<T, OrderItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderItemAggregateArgs>(args: Subset<T, OrderItemAggregateArgs>): Prisma.PrismaPromise<GetOrderItemAggregateType<T>>

    /**
     * Group by OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderItemGroupByArgs['orderBy'] }
        : { orderBy?: OrderItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrderItem model
   */
  readonly fields: OrderItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderItemClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the OrderItem model
   */ 
  interface OrderItemFieldRefs {
    readonly id: FieldRef<"OrderItem", 'Int'>
    readonly uuid: FieldRef<"OrderItem", 'String'>
    readonly quantity: FieldRef<"OrderItem", 'Int'>
    readonly price: FieldRef<"OrderItem", 'Float'>
    readonly productId: FieldRef<"OrderItem", 'Int'>
    readonly orderId: FieldRef<"OrderItem", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * OrderItem findUnique
   */
  export type OrderItemFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput
  }


  /**
   * OrderItem findUniqueOrThrow
   */
  export type OrderItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput
  }


  /**
   * OrderItem findFirst
   */
  export type OrderItemFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }


  /**
   * OrderItem findFirstOrThrow
   */
  export type OrderItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }


  /**
   * OrderItem findMany
   */
  export type OrderItemFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItems to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }


  /**
   * OrderItem create
   */
  export type OrderItemCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The data needed to create a OrderItem.
     */
    data: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
  }


  /**
   * OrderItem createMany
   */
  export type OrderItemCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderItems.
     */
    data: OrderItemCreateManyInput | OrderItemCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * OrderItem update
   */
  export type OrderItemUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The data needed to update a OrderItem.
     */
    data: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
    /**
     * Choose, which OrderItem to update.
     */
    where: OrderItemWhereUniqueInput
  }


  /**
   * OrderItem updateMany
   */
  export type OrderItemUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderItems.
     */
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyInput>
    /**
     * Filter which OrderItems to update
     */
    where?: OrderItemWhereInput
  }


  /**
   * OrderItem upsert
   */
  export type OrderItemUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The filter to search for the OrderItem to update in case it exists.
     */
    where: OrderItemWhereUniqueInput
    /**
     * In case the OrderItem found by the `where` argument doesn't exist, create a new OrderItem with this data.
     */
    create: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
    /**
     * In case the OrderItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
  }


  /**
   * OrderItem delete
   */
  export type OrderItemDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter which OrderItem to delete.
     */
    where: OrderItemWhereUniqueInput
  }


  /**
   * OrderItem deleteMany
   */
  export type OrderItemDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItems to delete
     */
    where?: OrderItemWhereInput
  }


  /**
   * OrderItem without action
   */
  export type OrderItemDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderItemInclude<ExtArgs> | null
  }



  /**
   * Model OrderHistory
   */

  export type AggregateOrderHistory = {
    _count: OrderHistoryCountAggregateOutputType | null
    _avg: OrderHistoryAvgAggregateOutputType | null
    _sum: OrderHistorySumAggregateOutputType | null
    _min: OrderHistoryMinAggregateOutputType | null
    _max: OrderHistoryMaxAggregateOutputType | null
  }

  export type OrderHistoryAvgAggregateOutputType = {
    id: number | null
    orderId: number | null
  }

  export type OrderHistorySumAggregateOutputType = {
    id: number | null
    orderId: number | null
  }

  export type OrderHistoryMinAggregateOutputType = {
    id: number | null
    uuid: string | null
    status: string | null
    description: string | null
    orderId: number | null
    createdAt: Date | null
  }

  export type OrderHistoryMaxAggregateOutputType = {
    id: number | null
    uuid: string | null
    status: string | null
    description: string | null
    orderId: number | null
    createdAt: Date | null
  }

  export type OrderHistoryCountAggregateOutputType = {
    id: number
    uuid: number
    status: number
    description: number
    orderId: number
    createdAt: number
    _all: number
  }


  export type OrderHistoryAvgAggregateInputType = {
    id?: true
    orderId?: true
  }

  export type OrderHistorySumAggregateInputType = {
    id?: true
    orderId?: true
  }

  export type OrderHistoryMinAggregateInputType = {
    id?: true
    uuid?: true
    status?: true
    description?: true
    orderId?: true
    createdAt?: true
  }

  export type OrderHistoryMaxAggregateInputType = {
    id?: true
    uuid?: true
    status?: true
    description?: true
    orderId?: true
    createdAt?: true
  }

  export type OrderHistoryCountAggregateInputType = {
    id?: true
    uuid?: true
    status?: true
    description?: true
    orderId?: true
    createdAt?: true
    _all?: true
  }

  export type OrderHistoryAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderHistory to aggregate.
     */
    where?: OrderHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderHistories to fetch.
     */
    orderBy?: OrderHistoryOrderByWithRelationInput | OrderHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderHistories
    **/
    _count?: true | OrderHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderHistoryMaxAggregateInputType
  }

  export type GetOrderHistoryAggregateType<T extends OrderHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderHistory[P]>
      : GetScalarType<T[P], AggregateOrderHistory[P]>
  }




  export type OrderHistoryGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: OrderHistoryWhereInput
    orderBy?: OrderHistoryOrderByWithAggregationInput | OrderHistoryOrderByWithAggregationInput[]
    by: OrderHistoryScalarFieldEnum[] | OrderHistoryScalarFieldEnum
    having?: OrderHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderHistoryCountAggregateInputType | true
    _avg?: OrderHistoryAvgAggregateInputType
    _sum?: OrderHistorySumAggregateInputType
    _min?: OrderHistoryMinAggregateInputType
    _max?: OrderHistoryMaxAggregateInputType
  }

  export type OrderHistoryGroupByOutputType = {
    id: number
    uuid: string
    status: string
    description: string | null
    orderId: number
    createdAt: Date
    _count: OrderHistoryCountAggregateOutputType | null
    _avg: OrderHistoryAvgAggregateOutputType | null
    _sum: OrderHistorySumAggregateOutputType | null
    _min: OrderHistoryMinAggregateOutputType | null
    _max: OrderHistoryMaxAggregateOutputType | null
  }

  type GetOrderHistoryGroupByPayload<T extends OrderHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], OrderHistoryGroupByOutputType[P]>
        }
      >
    >


  export type OrderHistorySelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    status?: boolean
    description?: boolean
    orderId?: boolean
    createdAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderHistory"]>

  export type OrderHistorySelectScalar = {
    id?: boolean
    uuid?: boolean
    status?: boolean
    description?: boolean
    orderId?: boolean
    createdAt?: boolean
  }

  export type OrderHistoryInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }


  export type $OrderHistoryPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "OrderHistory"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>
    }
    scalars: $Extensions.GetResult<{
      id: number
      uuid: string
      status: string
      description: string | null
      orderId: number
      createdAt: Date
    }, ExtArgs["result"]["orderHistory"]>
    composites: {}
  }


  type OrderHistoryGetPayload<S extends boolean | null | undefined | OrderHistoryDefaultArgs> = $Result.GetResult<Prisma.$OrderHistoryPayload, S>

  type OrderHistoryCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<OrderHistoryFindManyArgs, 'select' | 'include'> & {
      select?: OrderHistoryCountAggregateInputType | true
    }

  export interface OrderHistoryDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderHistory'], meta: { name: 'OrderHistory' } }
    /**
     * Find zero or one OrderHistory that matches the filter.
     * @param {OrderHistoryFindUniqueArgs} args - Arguments to find a OrderHistory
     * @example
     * // Get one OrderHistory
     * const orderHistory = await prisma.orderHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OrderHistoryFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, OrderHistoryFindUniqueArgs<ExtArgs>>
    ): Prisma__OrderHistoryClient<$Result.GetResult<Prisma.$OrderHistoryPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one OrderHistory that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {OrderHistoryFindUniqueOrThrowArgs} args - Arguments to find a OrderHistory
     * @example
     * // Get one OrderHistory
     * const orderHistory = await prisma.orderHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OrderHistoryFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderHistoryFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__OrderHistoryClient<$Result.GetResult<Prisma.$OrderHistoryPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first OrderHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderHistoryFindFirstArgs} args - Arguments to find a OrderHistory
     * @example
     * // Get one OrderHistory
     * const orderHistory = await prisma.orderHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OrderHistoryFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderHistoryFindFirstArgs<ExtArgs>>
    ): Prisma__OrderHistoryClient<$Result.GetResult<Prisma.$OrderHistoryPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first OrderHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderHistoryFindFirstOrThrowArgs} args - Arguments to find a OrderHistory
     * @example
     * // Get one OrderHistory
     * const orderHistory = await prisma.orderHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OrderHistoryFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderHistoryFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__OrderHistoryClient<$Result.GetResult<Prisma.$OrderHistoryPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more OrderHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderHistoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderHistories
     * const orderHistories = await prisma.orderHistory.findMany()
     * 
     * // Get first 10 OrderHistories
     * const orderHistories = await prisma.orderHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderHistoryWithIdOnly = await prisma.orderHistory.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OrderHistoryFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderHistoryFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderHistoryPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a OrderHistory.
     * @param {OrderHistoryCreateArgs} args - Arguments to create a OrderHistory.
     * @example
     * // Create one OrderHistory
     * const OrderHistory = await prisma.orderHistory.create({
     *   data: {
     *     // ... data to create a OrderHistory
     *   }
     * })
     * 
    **/
    create<T extends OrderHistoryCreateArgs<ExtArgs>>(
      args: SelectSubset<T, OrderHistoryCreateArgs<ExtArgs>>
    ): Prisma__OrderHistoryClient<$Result.GetResult<Prisma.$OrderHistoryPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many OrderHistories.
     *     @param {OrderHistoryCreateManyArgs} args - Arguments to create many OrderHistories.
     *     @example
     *     // Create many OrderHistories
     *     const orderHistory = await prisma.orderHistory.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OrderHistoryCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderHistoryCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OrderHistory.
     * @param {OrderHistoryDeleteArgs} args - Arguments to delete one OrderHistory.
     * @example
     * // Delete one OrderHistory
     * const OrderHistory = await prisma.orderHistory.delete({
     *   where: {
     *     // ... filter to delete one OrderHistory
     *   }
     * })
     * 
    **/
    delete<T extends OrderHistoryDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, OrderHistoryDeleteArgs<ExtArgs>>
    ): Prisma__OrderHistoryClient<$Result.GetResult<Prisma.$OrderHistoryPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one OrderHistory.
     * @param {OrderHistoryUpdateArgs} args - Arguments to update one OrderHistory.
     * @example
     * // Update one OrderHistory
     * const orderHistory = await prisma.orderHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OrderHistoryUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, OrderHistoryUpdateArgs<ExtArgs>>
    ): Prisma__OrderHistoryClient<$Result.GetResult<Prisma.$OrderHistoryPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more OrderHistories.
     * @param {OrderHistoryDeleteManyArgs} args - Arguments to filter OrderHistories to delete.
     * @example
     * // Delete a few OrderHistories
     * const { count } = await prisma.orderHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OrderHistoryDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderHistoryDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderHistories
     * const orderHistory = await prisma.orderHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OrderHistoryUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, OrderHistoryUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OrderHistory.
     * @param {OrderHistoryUpsertArgs} args - Arguments to update or create a OrderHistory.
     * @example
     * // Update or create a OrderHistory
     * const orderHistory = await prisma.orderHistory.upsert({
     *   create: {
     *     // ... data to create a OrderHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderHistory we want to update
     *   }
     * })
    **/
    upsert<T extends OrderHistoryUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, OrderHistoryUpsertArgs<ExtArgs>>
    ): Prisma__OrderHistoryClient<$Result.GetResult<Prisma.$OrderHistoryPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of OrderHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderHistoryCountArgs} args - Arguments to filter OrderHistories to count.
     * @example
     * // Count the number of OrderHistories
     * const count = await prisma.orderHistory.count({
     *   where: {
     *     // ... the filter for the OrderHistories we want to count
     *   }
     * })
    **/
    count<T extends OrderHistoryCountArgs>(
      args?: Subset<T, OrderHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderHistoryAggregateArgs>(args: Subset<T, OrderHistoryAggregateArgs>): Prisma.PrismaPromise<GetOrderHistoryAggregateType<T>>

    /**
     * Group by OrderHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderHistoryGroupByArgs['orderBy'] }
        : { orderBy?: OrderHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrderHistory model
   */
  readonly fields: OrderHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderHistoryClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the OrderHistory model
   */ 
  interface OrderHistoryFieldRefs {
    readonly id: FieldRef<"OrderHistory", 'Int'>
    readonly uuid: FieldRef<"OrderHistory", 'String'>
    readonly status: FieldRef<"OrderHistory", 'String'>
    readonly description: FieldRef<"OrderHistory", 'String'>
    readonly orderId: FieldRef<"OrderHistory", 'Int'>
    readonly createdAt: FieldRef<"OrderHistory", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * OrderHistory findUnique
   */
  export type OrderHistoryFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderHistory
     */
    select?: OrderHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderHistoryInclude<ExtArgs> | null
    /**
     * Filter, which OrderHistory to fetch.
     */
    where: OrderHistoryWhereUniqueInput
  }


  /**
   * OrderHistory findUniqueOrThrow
   */
  export type OrderHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderHistory
     */
    select?: OrderHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderHistoryInclude<ExtArgs> | null
    /**
     * Filter, which OrderHistory to fetch.
     */
    where: OrderHistoryWhereUniqueInput
  }


  /**
   * OrderHistory findFirst
   */
  export type OrderHistoryFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderHistory
     */
    select?: OrderHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderHistoryInclude<ExtArgs> | null
    /**
     * Filter, which OrderHistory to fetch.
     */
    where?: OrderHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderHistories to fetch.
     */
    orderBy?: OrderHistoryOrderByWithRelationInput | OrderHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderHistories.
     */
    cursor?: OrderHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderHistories.
     */
    distinct?: OrderHistoryScalarFieldEnum | OrderHistoryScalarFieldEnum[]
  }


  /**
   * OrderHistory findFirstOrThrow
   */
  export type OrderHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderHistory
     */
    select?: OrderHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderHistoryInclude<ExtArgs> | null
    /**
     * Filter, which OrderHistory to fetch.
     */
    where?: OrderHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderHistories to fetch.
     */
    orderBy?: OrderHistoryOrderByWithRelationInput | OrderHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderHistories.
     */
    cursor?: OrderHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderHistories.
     */
    distinct?: OrderHistoryScalarFieldEnum | OrderHistoryScalarFieldEnum[]
  }


  /**
   * OrderHistory findMany
   */
  export type OrderHistoryFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderHistory
     */
    select?: OrderHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderHistoryInclude<ExtArgs> | null
    /**
     * Filter, which OrderHistories to fetch.
     */
    where?: OrderHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderHistories to fetch.
     */
    orderBy?: OrderHistoryOrderByWithRelationInput | OrderHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderHistories.
     */
    cursor?: OrderHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderHistories.
     */
    skip?: number
    distinct?: OrderHistoryScalarFieldEnum | OrderHistoryScalarFieldEnum[]
  }


  /**
   * OrderHistory create
   */
  export type OrderHistoryCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderHistory
     */
    select?: OrderHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a OrderHistory.
     */
    data: XOR<OrderHistoryCreateInput, OrderHistoryUncheckedCreateInput>
  }


  /**
   * OrderHistory createMany
   */
  export type OrderHistoryCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderHistories.
     */
    data: OrderHistoryCreateManyInput | OrderHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * OrderHistory update
   */
  export type OrderHistoryUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderHistory
     */
    select?: OrderHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a OrderHistory.
     */
    data: XOR<OrderHistoryUpdateInput, OrderHistoryUncheckedUpdateInput>
    /**
     * Choose, which OrderHistory to update.
     */
    where: OrderHistoryWhereUniqueInput
  }


  /**
   * OrderHistory updateMany
   */
  export type OrderHistoryUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderHistories.
     */
    data: XOR<OrderHistoryUpdateManyMutationInput, OrderHistoryUncheckedUpdateManyInput>
    /**
     * Filter which OrderHistories to update
     */
    where?: OrderHistoryWhereInput
  }


  /**
   * OrderHistory upsert
   */
  export type OrderHistoryUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderHistory
     */
    select?: OrderHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the OrderHistory to update in case it exists.
     */
    where: OrderHistoryWhereUniqueInput
    /**
     * In case the OrderHistory found by the `where` argument doesn't exist, create a new OrderHistory with this data.
     */
    create: XOR<OrderHistoryCreateInput, OrderHistoryUncheckedCreateInput>
    /**
     * In case the OrderHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderHistoryUpdateInput, OrderHistoryUncheckedUpdateInput>
  }


  /**
   * OrderHistory delete
   */
  export type OrderHistoryDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderHistory
     */
    select?: OrderHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderHistoryInclude<ExtArgs> | null
    /**
     * Filter which OrderHistory to delete.
     */
    where: OrderHistoryWhereUniqueInput
  }


  /**
   * OrderHistory deleteMany
   */
  export type OrderHistoryDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderHistories to delete
     */
    where?: OrderHistoryWhereInput
  }


  /**
   * OrderHistory without action
   */
  export type OrderHistoryDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderHistory
     */
    select?: OrderHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderHistoryInclude<ExtArgs> | null
  }



  /**
   * Model Enterprise
   */

  export type AggregateEnterprise = {
    _count: EnterpriseCountAggregateOutputType | null
    _avg: EnterpriseAvgAggregateOutputType | null
    _sum: EnterpriseSumAggregateOutputType | null
    _min: EnterpriseMinAggregateOutputType | null
    _max: EnterpriseMaxAggregateOutputType | null
  }

  export type EnterpriseAvgAggregateOutputType = {
    id: number | null
  }

  export type EnterpriseSumAggregateOutputType = {
    id: number | null
  }

  export type EnterpriseMinAggregateOutputType = {
    id: number | null
    uuid: string | null
    name: string | null
    responsiblePerson: string | null
    phoneNumber: string | null
    email: string | null
    description: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type EnterpriseMaxAggregateOutputType = {
    id: number | null
    uuid: string | null
    name: string | null
    responsiblePerson: string | null
    phoneNumber: string | null
    email: string | null
    description: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type EnterpriseCountAggregateOutputType = {
    id: number
    uuid: number
    name: number
    responsiblePerson: number
    phoneNumber: number
    email: number
    description: number
    status: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type EnterpriseAvgAggregateInputType = {
    id?: true
  }

  export type EnterpriseSumAggregateInputType = {
    id?: true
  }

  export type EnterpriseMinAggregateInputType = {
    id?: true
    uuid?: true
    name?: true
    responsiblePerson?: true
    phoneNumber?: true
    email?: true
    description?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type EnterpriseMaxAggregateInputType = {
    id?: true
    uuid?: true
    name?: true
    responsiblePerson?: true
    phoneNumber?: true
    email?: true
    description?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type EnterpriseCountAggregateInputType = {
    id?: true
    uuid?: true
    name?: true
    responsiblePerson?: true
    phoneNumber?: true
    email?: true
    description?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type EnterpriseAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Enterprise to aggregate.
     */
    where?: EnterpriseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enterprises to fetch.
     */
    orderBy?: EnterpriseOrderByWithRelationInput | EnterpriseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EnterpriseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enterprises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enterprises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Enterprises
    **/
    _count?: true | EnterpriseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EnterpriseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EnterpriseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EnterpriseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EnterpriseMaxAggregateInputType
  }

  export type GetEnterpriseAggregateType<T extends EnterpriseAggregateArgs> = {
        [P in keyof T & keyof AggregateEnterprise]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEnterprise[P]>
      : GetScalarType<T[P], AggregateEnterprise[P]>
  }




  export type EnterpriseGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: EnterpriseWhereInput
    orderBy?: EnterpriseOrderByWithAggregationInput | EnterpriseOrderByWithAggregationInput[]
    by: EnterpriseScalarFieldEnum[] | EnterpriseScalarFieldEnum
    having?: EnterpriseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EnterpriseCountAggregateInputType | true
    _avg?: EnterpriseAvgAggregateInputType
    _sum?: EnterpriseSumAggregateInputType
    _min?: EnterpriseMinAggregateInputType
    _max?: EnterpriseMaxAggregateInputType
  }

  export type EnterpriseGroupByOutputType = {
    id: number
    uuid: string
    name: string
    responsiblePerson: string | null
    phoneNumber: string | null
    email: string | null
    description: string | null
    status: string
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: EnterpriseCountAggregateOutputType | null
    _avg: EnterpriseAvgAggregateOutputType | null
    _sum: EnterpriseSumAggregateOutputType | null
    _min: EnterpriseMinAggregateOutputType | null
    _max: EnterpriseMaxAggregateOutputType | null
  }

  type GetEnterpriseGroupByPayload<T extends EnterpriseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EnterpriseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EnterpriseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EnterpriseGroupByOutputType[P]>
            : GetScalarType<T[P], EnterpriseGroupByOutputType[P]>
        }
      >
    >


  export type EnterpriseSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    name?: boolean
    responsiblePerson?: boolean
    phoneNumber?: boolean
    email?: boolean
    description?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    users?: boolean | Enterprise$usersArgs<ExtArgs>
    categories?: boolean | Enterprise$categoriesArgs<ExtArgs>
    products?: boolean | Enterprise$productsArgs<ExtArgs>
    configurations?: boolean | Enterprise$configurationsArgs<ExtArgs>
    orders?: boolean | Enterprise$ordersArgs<ExtArgs>
    promotions?: boolean | Enterprise$promotionsArgs<ExtArgs>
    combos?: boolean | Enterprise$combosArgs<ExtArgs>
    _count?: boolean | EnterpriseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["enterprise"]>

  export type EnterpriseSelectScalar = {
    id?: boolean
    uuid?: boolean
    name?: boolean
    responsiblePerson?: boolean
    phoneNumber?: boolean
    email?: boolean
    description?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type EnterpriseInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    users?: boolean | Enterprise$usersArgs<ExtArgs>
    categories?: boolean | Enterprise$categoriesArgs<ExtArgs>
    products?: boolean | Enterprise$productsArgs<ExtArgs>
    configurations?: boolean | Enterprise$configurationsArgs<ExtArgs>
    orders?: boolean | Enterprise$ordersArgs<ExtArgs>
    promotions?: boolean | Enterprise$promotionsArgs<ExtArgs>
    combos?: boolean | Enterprise$combosArgs<ExtArgs>
    _count?: boolean | EnterpriseCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $EnterprisePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "Enterprise"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
      categories: Prisma.$CategoryPayload<ExtArgs>[]
      products: Prisma.$ProductPayload<ExtArgs>[]
      configurations: Prisma.$ConfigurationPayload<ExtArgs>[]
      orders: Prisma.$OrderPayload<ExtArgs>[]
      promotions: Prisma.$PromotionPayload<ExtArgs>[]
      combos: Prisma.$ComboPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetResult<{
      id: number
      uuid: string
      name: string
      responsiblePerson: string | null
      phoneNumber: string | null
      email: string | null
      description: string | null
      status: string
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["enterprise"]>
    composites: {}
  }


  type EnterpriseGetPayload<S extends boolean | null | undefined | EnterpriseDefaultArgs> = $Result.GetResult<Prisma.$EnterprisePayload, S>

  type EnterpriseCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<EnterpriseFindManyArgs, 'select' | 'include'> & {
      select?: EnterpriseCountAggregateInputType | true
    }

  export interface EnterpriseDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Enterprise'], meta: { name: 'Enterprise' } }
    /**
     * Find zero or one Enterprise that matches the filter.
     * @param {EnterpriseFindUniqueArgs} args - Arguments to find a Enterprise
     * @example
     * // Get one Enterprise
     * const enterprise = await prisma.enterprise.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EnterpriseFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, EnterpriseFindUniqueArgs<ExtArgs>>
    ): Prisma__EnterpriseClient<$Result.GetResult<Prisma.$EnterprisePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Enterprise that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EnterpriseFindUniqueOrThrowArgs} args - Arguments to find a Enterprise
     * @example
     * // Get one Enterprise
     * const enterprise = await prisma.enterprise.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EnterpriseFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EnterpriseFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EnterpriseClient<$Result.GetResult<Prisma.$EnterprisePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Enterprise that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnterpriseFindFirstArgs} args - Arguments to find a Enterprise
     * @example
     * // Get one Enterprise
     * const enterprise = await prisma.enterprise.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EnterpriseFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, EnterpriseFindFirstArgs<ExtArgs>>
    ): Prisma__EnterpriseClient<$Result.GetResult<Prisma.$EnterprisePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Enterprise that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnterpriseFindFirstOrThrowArgs} args - Arguments to find a Enterprise
     * @example
     * // Get one Enterprise
     * const enterprise = await prisma.enterprise.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EnterpriseFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EnterpriseFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EnterpriseClient<$Result.GetResult<Prisma.$EnterprisePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Enterprises that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnterpriseFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Enterprises
     * const enterprises = await prisma.enterprise.findMany()
     * 
     * // Get first 10 Enterprises
     * const enterprises = await prisma.enterprise.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const enterpriseWithIdOnly = await prisma.enterprise.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EnterpriseFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EnterpriseFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnterprisePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Enterprise.
     * @param {EnterpriseCreateArgs} args - Arguments to create a Enterprise.
     * @example
     * // Create one Enterprise
     * const Enterprise = await prisma.enterprise.create({
     *   data: {
     *     // ... data to create a Enterprise
     *   }
     * })
     * 
    **/
    create<T extends EnterpriseCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EnterpriseCreateArgs<ExtArgs>>
    ): Prisma__EnterpriseClient<$Result.GetResult<Prisma.$EnterprisePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Enterprises.
     *     @param {EnterpriseCreateManyArgs} args - Arguments to create many Enterprises.
     *     @example
     *     // Create many Enterprises
     *     const enterprise = await prisma.enterprise.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EnterpriseCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EnterpriseCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Enterprise.
     * @param {EnterpriseDeleteArgs} args - Arguments to delete one Enterprise.
     * @example
     * // Delete one Enterprise
     * const Enterprise = await prisma.enterprise.delete({
     *   where: {
     *     // ... filter to delete one Enterprise
     *   }
     * })
     * 
    **/
    delete<T extends EnterpriseDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EnterpriseDeleteArgs<ExtArgs>>
    ): Prisma__EnterpriseClient<$Result.GetResult<Prisma.$EnterprisePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Enterprise.
     * @param {EnterpriseUpdateArgs} args - Arguments to update one Enterprise.
     * @example
     * // Update one Enterprise
     * const enterprise = await prisma.enterprise.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EnterpriseUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EnterpriseUpdateArgs<ExtArgs>>
    ): Prisma__EnterpriseClient<$Result.GetResult<Prisma.$EnterprisePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Enterprises.
     * @param {EnterpriseDeleteManyArgs} args - Arguments to filter Enterprises to delete.
     * @example
     * // Delete a few Enterprises
     * const { count } = await prisma.enterprise.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EnterpriseDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EnterpriseDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Enterprises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnterpriseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Enterprises
     * const enterprise = await prisma.enterprise.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EnterpriseUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EnterpriseUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Enterprise.
     * @param {EnterpriseUpsertArgs} args - Arguments to update or create a Enterprise.
     * @example
     * // Update or create a Enterprise
     * const enterprise = await prisma.enterprise.upsert({
     *   create: {
     *     // ... data to create a Enterprise
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Enterprise we want to update
     *   }
     * })
    **/
    upsert<T extends EnterpriseUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EnterpriseUpsertArgs<ExtArgs>>
    ): Prisma__EnterpriseClient<$Result.GetResult<Prisma.$EnterprisePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Enterprises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnterpriseCountArgs} args - Arguments to filter Enterprises to count.
     * @example
     * // Count the number of Enterprises
     * const count = await prisma.enterprise.count({
     *   where: {
     *     // ... the filter for the Enterprises we want to count
     *   }
     * })
    **/
    count<T extends EnterpriseCountArgs>(
      args?: Subset<T, EnterpriseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EnterpriseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Enterprise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnterpriseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EnterpriseAggregateArgs>(args: Subset<T, EnterpriseAggregateArgs>): Prisma.PrismaPromise<GetEnterpriseAggregateType<T>>

    /**
     * Group by Enterprise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnterpriseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EnterpriseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EnterpriseGroupByArgs['orderBy'] }
        : { orderBy?: EnterpriseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EnterpriseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEnterpriseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Enterprise model
   */
  readonly fields: EnterpriseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Enterprise.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EnterpriseClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    users<T extends Enterprise$usersArgs<ExtArgs> = {}>(args?: Subset<T, Enterprise$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findMany'> | Null>;

    categories<T extends Enterprise$categoriesArgs<ExtArgs> = {}>(args?: Subset<T, Enterprise$categoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, 'findMany'> | Null>;

    products<T extends Enterprise$productsArgs<ExtArgs> = {}>(args?: Subset<T, Enterprise$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findMany'> | Null>;

    configurations<T extends Enterprise$configurationsArgs<ExtArgs> = {}>(args?: Subset<T, Enterprise$configurationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConfigurationPayload<ExtArgs>, T, 'findMany'> | Null>;

    orders<T extends Enterprise$ordersArgs<ExtArgs> = {}>(args?: Subset<T, Enterprise$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'findMany'> | Null>;

    promotions<T extends Enterprise$promotionsArgs<ExtArgs> = {}>(args?: Subset<T, Enterprise$promotionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, 'findMany'> | Null>;

    combos<T extends Enterprise$combosArgs<ExtArgs> = {}>(args?: Subset<T, Enterprise$combosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComboPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Enterprise model
   */ 
  interface EnterpriseFieldRefs {
    readonly id: FieldRef<"Enterprise", 'Int'>
    readonly uuid: FieldRef<"Enterprise", 'String'>
    readonly name: FieldRef<"Enterprise", 'String'>
    readonly responsiblePerson: FieldRef<"Enterprise", 'String'>
    readonly phoneNumber: FieldRef<"Enterprise", 'String'>
    readonly email: FieldRef<"Enterprise", 'String'>
    readonly description: FieldRef<"Enterprise", 'String'>
    readonly status: FieldRef<"Enterprise", 'String'>
    readonly createdAt: FieldRef<"Enterprise", 'DateTime'>
    readonly updatedAt: FieldRef<"Enterprise", 'DateTime'>
    readonly deletedAt: FieldRef<"Enterprise", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Enterprise findUnique
   */
  export type EnterpriseFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enterprise
     */
    select?: EnterpriseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnterpriseInclude<ExtArgs> | null
    /**
     * Filter, which Enterprise to fetch.
     */
    where: EnterpriseWhereUniqueInput
  }


  /**
   * Enterprise findUniqueOrThrow
   */
  export type EnterpriseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enterprise
     */
    select?: EnterpriseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnterpriseInclude<ExtArgs> | null
    /**
     * Filter, which Enterprise to fetch.
     */
    where: EnterpriseWhereUniqueInput
  }


  /**
   * Enterprise findFirst
   */
  export type EnterpriseFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enterprise
     */
    select?: EnterpriseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnterpriseInclude<ExtArgs> | null
    /**
     * Filter, which Enterprise to fetch.
     */
    where?: EnterpriseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enterprises to fetch.
     */
    orderBy?: EnterpriseOrderByWithRelationInput | EnterpriseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Enterprises.
     */
    cursor?: EnterpriseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enterprises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enterprises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Enterprises.
     */
    distinct?: EnterpriseScalarFieldEnum | EnterpriseScalarFieldEnum[]
  }


  /**
   * Enterprise findFirstOrThrow
   */
  export type EnterpriseFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enterprise
     */
    select?: EnterpriseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnterpriseInclude<ExtArgs> | null
    /**
     * Filter, which Enterprise to fetch.
     */
    where?: EnterpriseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enterprises to fetch.
     */
    orderBy?: EnterpriseOrderByWithRelationInput | EnterpriseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Enterprises.
     */
    cursor?: EnterpriseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enterprises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enterprises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Enterprises.
     */
    distinct?: EnterpriseScalarFieldEnum | EnterpriseScalarFieldEnum[]
  }


  /**
   * Enterprise findMany
   */
  export type EnterpriseFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enterprise
     */
    select?: EnterpriseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnterpriseInclude<ExtArgs> | null
    /**
     * Filter, which Enterprises to fetch.
     */
    where?: EnterpriseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enterprises to fetch.
     */
    orderBy?: EnterpriseOrderByWithRelationInput | EnterpriseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Enterprises.
     */
    cursor?: EnterpriseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enterprises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enterprises.
     */
    skip?: number
    distinct?: EnterpriseScalarFieldEnum | EnterpriseScalarFieldEnum[]
  }


  /**
   * Enterprise create
   */
  export type EnterpriseCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enterprise
     */
    select?: EnterpriseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnterpriseInclude<ExtArgs> | null
    /**
     * The data needed to create a Enterprise.
     */
    data: XOR<EnterpriseCreateInput, EnterpriseUncheckedCreateInput>
  }


  /**
   * Enterprise createMany
   */
  export type EnterpriseCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Enterprises.
     */
    data: EnterpriseCreateManyInput | EnterpriseCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Enterprise update
   */
  export type EnterpriseUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enterprise
     */
    select?: EnterpriseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnterpriseInclude<ExtArgs> | null
    /**
     * The data needed to update a Enterprise.
     */
    data: XOR<EnterpriseUpdateInput, EnterpriseUncheckedUpdateInput>
    /**
     * Choose, which Enterprise to update.
     */
    where: EnterpriseWhereUniqueInput
  }


  /**
   * Enterprise updateMany
   */
  export type EnterpriseUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Enterprises.
     */
    data: XOR<EnterpriseUpdateManyMutationInput, EnterpriseUncheckedUpdateManyInput>
    /**
     * Filter which Enterprises to update
     */
    where?: EnterpriseWhereInput
  }


  /**
   * Enterprise upsert
   */
  export type EnterpriseUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enterprise
     */
    select?: EnterpriseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnterpriseInclude<ExtArgs> | null
    /**
     * The filter to search for the Enterprise to update in case it exists.
     */
    where: EnterpriseWhereUniqueInput
    /**
     * In case the Enterprise found by the `where` argument doesn't exist, create a new Enterprise with this data.
     */
    create: XOR<EnterpriseCreateInput, EnterpriseUncheckedCreateInput>
    /**
     * In case the Enterprise was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EnterpriseUpdateInput, EnterpriseUncheckedUpdateInput>
  }


  /**
   * Enterprise delete
   */
  export type EnterpriseDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enterprise
     */
    select?: EnterpriseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnterpriseInclude<ExtArgs> | null
    /**
     * Filter which Enterprise to delete.
     */
    where: EnterpriseWhereUniqueInput
  }


  /**
   * Enterprise deleteMany
   */
  export type EnterpriseDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Enterprises to delete
     */
    where?: EnterpriseWhereInput
  }


  /**
   * Enterprise.users
   */
  export type Enterprise$usersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * Enterprise.categories
   */
  export type Enterprise$categoriesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    cursor?: CategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }


  /**
   * Enterprise.products
   */
  export type Enterprise$productsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }


  /**
   * Enterprise.configurations
   */
  export type Enterprise$configurationsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Configuration
     */
    select?: ConfigurationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConfigurationInclude<ExtArgs> | null
    where?: ConfigurationWhereInput
    orderBy?: ConfigurationOrderByWithRelationInput | ConfigurationOrderByWithRelationInput[]
    cursor?: ConfigurationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConfigurationScalarFieldEnum | ConfigurationScalarFieldEnum[]
  }


  /**
   * Enterprise.orders
   */
  export type Enterprise$ordersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }


  /**
   * Enterprise.promotions
   */
  export type Enterprise$promotionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PromotionInclude<ExtArgs> | null
    where?: PromotionWhereInput
    orderBy?: PromotionOrderByWithRelationInput | PromotionOrderByWithRelationInput[]
    cursor?: PromotionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PromotionScalarFieldEnum | PromotionScalarFieldEnum[]
  }


  /**
   * Enterprise.combos
   */
  export type Enterprise$combosArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Combo
     */
    select?: ComboSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ComboInclude<ExtArgs> | null
    where?: ComboWhereInput
    orderBy?: ComboOrderByWithRelationInput | ComboOrderByWithRelationInput[]
    cursor?: ComboWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComboScalarFieldEnum | ComboScalarFieldEnum[]
  }


  /**
   * Enterprise without action
   */
  export type EnterpriseDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enterprise
     */
    select?: EnterpriseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnterpriseInclude<ExtArgs> | null
  }



  /**
   * Model Configuration
   */

  export type AggregateConfiguration = {
    _count: ConfigurationCountAggregateOutputType | null
    _avg: ConfigurationAvgAggregateOutputType | null
    _sum: ConfigurationSumAggregateOutputType | null
    _min: ConfigurationMinAggregateOutputType | null
    _max: ConfigurationMaxAggregateOutputType | null
  }

  export type ConfigurationAvgAggregateOutputType = {
    id: number | null
    enterpriseId: number | null
  }

  export type ConfigurationSumAggregateOutputType = {
    id: number | null
    enterpriseId: number | null
  }

  export type ConfigurationMinAggregateOutputType = {
    id: number | null
    uuid: string | null
    configKey: string | null
    configValue: string | null
    configText: string | null
    createdAt: Date | null
    updatedAt: Date | null
    enterpriseId: number | null
  }

  export type ConfigurationMaxAggregateOutputType = {
    id: number | null
    uuid: string | null
    configKey: string | null
    configValue: string | null
    configText: string | null
    createdAt: Date | null
    updatedAt: Date | null
    enterpriseId: number | null
  }

  export type ConfigurationCountAggregateOutputType = {
    id: number
    uuid: number
    configKey: number
    configValue: number
    configText: number
    createdAt: number
    updatedAt: number
    enterpriseId: number
    _all: number
  }


  export type ConfigurationAvgAggregateInputType = {
    id?: true
    enterpriseId?: true
  }

  export type ConfigurationSumAggregateInputType = {
    id?: true
    enterpriseId?: true
  }

  export type ConfigurationMinAggregateInputType = {
    id?: true
    uuid?: true
    configKey?: true
    configValue?: true
    configText?: true
    createdAt?: true
    updatedAt?: true
    enterpriseId?: true
  }

  export type ConfigurationMaxAggregateInputType = {
    id?: true
    uuid?: true
    configKey?: true
    configValue?: true
    configText?: true
    createdAt?: true
    updatedAt?: true
    enterpriseId?: true
  }

  export type ConfigurationCountAggregateInputType = {
    id?: true
    uuid?: true
    configKey?: true
    configValue?: true
    configText?: true
    createdAt?: true
    updatedAt?: true
    enterpriseId?: true
    _all?: true
  }

  export type ConfigurationAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Configuration to aggregate.
     */
    where?: ConfigurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Configurations to fetch.
     */
    orderBy?: ConfigurationOrderByWithRelationInput | ConfigurationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConfigurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Configurations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Configurations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Configurations
    **/
    _count?: true | ConfigurationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConfigurationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConfigurationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConfigurationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConfigurationMaxAggregateInputType
  }

  export type GetConfigurationAggregateType<T extends ConfigurationAggregateArgs> = {
        [P in keyof T & keyof AggregateConfiguration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConfiguration[P]>
      : GetScalarType<T[P], AggregateConfiguration[P]>
  }




  export type ConfigurationGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ConfigurationWhereInput
    orderBy?: ConfigurationOrderByWithAggregationInput | ConfigurationOrderByWithAggregationInput[]
    by: ConfigurationScalarFieldEnum[] | ConfigurationScalarFieldEnum
    having?: ConfigurationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConfigurationCountAggregateInputType | true
    _avg?: ConfigurationAvgAggregateInputType
    _sum?: ConfigurationSumAggregateInputType
    _min?: ConfigurationMinAggregateInputType
    _max?: ConfigurationMaxAggregateInputType
  }

  export type ConfigurationGroupByOutputType = {
    id: number
    uuid: string
    configKey: string
    configValue: string
    configText: string | null
    createdAt: Date
    updatedAt: Date
    enterpriseId: number
    _count: ConfigurationCountAggregateOutputType | null
    _avg: ConfigurationAvgAggregateOutputType | null
    _sum: ConfigurationSumAggregateOutputType | null
    _min: ConfigurationMinAggregateOutputType | null
    _max: ConfigurationMaxAggregateOutputType | null
  }

  type GetConfigurationGroupByPayload<T extends ConfigurationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConfigurationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConfigurationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConfigurationGroupByOutputType[P]>
            : GetScalarType<T[P], ConfigurationGroupByOutputType[P]>
        }
      >
    >


  export type ConfigurationSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    configKey?: boolean
    configValue?: boolean
    configText?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    enterpriseId?: boolean
    enterprise?: boolean | EnterpriseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["configuration"]>

  export type ConfigurationSelectScalar = {
    id?: boolean
    uuid?: boolean
    configKey?: boolean
    configValue?: boolean
    configText?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    enterpriseId?: boolean
  }

  export type ConfigurationInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    enterprise?: boolean | EnterpriseDefaultArgs<ExtArgs>
  }


  export type $ConfigurationPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "Configuration"
    objects: {
      enterprise: Prisma.$EnterprisePayload<ExtArgs>
    }
    scalars: $Extensions.GetResult<{
      id: number
      uuid: string
      configKey: string
      configValue: string
      configText: string | null
      createdAt: Date
      updatedAt: Date
      enterpriseId: number
    }, ExtArgs["result"]["configuration"]>
    composites: {}
  }


  type ConfigurationGetPayload<S extends boolean | null | undefined | ConfigurationDefaultArgs> = $Result.GetResult<Prisma.$ConfigurationPayload, S>

  type ConfigurationCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ConfigurationFindManyArgs, 'select' | 'include'> & {
      select?: ConfigurationCountAggregateInputType | true
    }

  export interface ConfigurationDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Configuration'], meta: { name: 'Configuration' } }
    /**
     * Find zero or one Configuration that matches the filter.
     * @param {ConfigurationFindUniqueArgs} args - Arguments to find a Configuration
     * @example
     * // Get one Configuration
     * const configuration = await prisma.configuration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ConfigurationFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ConfigurationFindUniqueArgs<ExtArgs>>
    ): Prisma__ConfigurationClient<$Result.GetResult<Prisma.$ConfigurationPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Configuration that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ConfigurationFindUniqueOrThrowArgs} args - Arguments to find a Configuration
     * @example
     * // Get one Configuration
     * const configuration = await prisma.configuration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ConfigurationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ConfigurationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ConfigurationClient<$Result.GetResult<Prisma.$ConfigurationPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Configuration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigurationFindFirstArgs} args - Arguments to find a Configuration
     * @example
     * // Get one Configuration
     * const configuration = await prisma.configuration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ConfigurationFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ConfigurationFindFirstArgs<ExtArgs>>
    ): Prisma__ConfigurationClient<$Result.GetResult<Prisma.$ConfigurationPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Configuration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigurationFindFirstOrThrowArgs} args - Arguments to find a Configuration
     * @example
     * // Get one Configuration
     * const configuration = await prisma.configuration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ConfigurationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ConfigurationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ConfigurationClient<$Result.GetResult<Prisma.$ConfigurationPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Configurations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigurationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Configurations
     * const configurations = await prisma.configuration.findMany()
     * 
     * // Get first 10 Configurations
     * const configurations = await prisma.configuration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const configurationWithIdOnly = await prisma.configuration.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ConfigurationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ConfigurationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConfigurationPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Configuration.
     * @param {ConfigurationCreateArgs} args - Arguments to create a Configuration.
     * @example
     * // Create one Configuration
     * const Configuration = await prisma.configuration.create({
     *   data: {
     *     // ... data to create a Configuration
     *   }
     * })
     * 
    **/
    create<T extends ConfigurationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ConfigurationCreateArgs<ExtArgs>>
    ): Prisma__ConfigurationClient<$Result.GetResult<Prisma.$ConfigurationPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Configurations.
     *     @param {ConfigurationCreateManyArgs} args - Arguments to create many Configurations.
     *     @example
     *     // Create many Configurations
     *     const configuration = await prisma.configuration.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ConfigurationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ConfigurationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Configuration.
     * @param {ConfigurationDeleteArgs} args - Arguments to delete one Configuration.
     * @example
     * // Delete one Configuration
     * const Configuration = await prisma.configuration.delete({
     *   where: {
     *     // ... filter to delete one Configuration
     *   }
     * })
     * 
    **/
    delete<T extends ConfigurationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ConfigurationDeleteArgs<ExtArgs>>
    ): Prisma__ConfigurationClient<$Result.GetResult<Prisma.$ConfigurationPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Configuration.
     * @param {ConfigurationUpdateArgs} args - Arguments to update one Configuration.
     * @example
     * // Update one Configuration
     * const configuration = await prisma.configuration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ConfigurationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ConfigurationUpdateArgs<ExtArgs>>
    ): Prisma__ConfigurationClient<$Result.GetResult<Prisma.$ConfigurationPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Configurations.
     * @param {ConfigurationDeleteManyArgs} args - Arguments to filter Configurations to delete.
     * @example
     * // Delete a few Configurations
     * const { count } = await prisma.configuration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ConfigurationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ConfigurationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Configurations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigurationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Configurations
     * const configuration = await prisma.configuration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ConfigurationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ConfigurationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Configuration.
     * @param {ConfigurationUpsertArgs} args - Arguments to update or create a Configuration.
     * @example
     * // Update or create a Configuration
     * const configuration = await prisma.configuration.upsert({
     *   create: {
     *     // ... data to create a Configuration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Configuration we want to update
     *   }
     * })
    **/
    upsert<T extends ConfigurationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ConfigurationUpsertArgs<ExtArgs>>
    ): Prisma__ConfigurationClient<$Result.GetResult<Prisma.$ConfigurationPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Configurations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigurationCountArgs} args - Arguments to filter Configurations to count.
     * @example
     * // Count the number of Configurations
     * const count = await prisma.configuration.count({
     *   where: {
     *     // ... the filter for the Configurations we want to count
     *   }
     * })
    **/
    count<T extends ConfigurationCountArgs>(
      args?: Subset<T, ConfigurationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConfigurationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Configuration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigurationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConfigurationAggregateArgs>(args: Subset<T, ConfigurationAggregateArgs>): Prisma.PrismaPromise<GetConfigurationAggregateType<T>>

    /**
     * Group by Configuration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigurationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConfigurationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConfigurationGroupByArgs['orderBy'] }
        : { orderBy?: ConfigurationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConfigurationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConfigurationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Configuration model
   */
  readonly fields: ConfigurationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Configuration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConfigurationClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    enterprise<T extends EnterpriseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EnterpriseDefaultArgs<ExtArgs>>): Prisma__EnterpriseClient<$Result.GetResult<Prisma.$EnterprisePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Configuration model
   */ 
  interface ConfigurationFieldRefs {
    readonly id: FieldRef<"Configuration", 'Int'>
    readonly uuid: FieldRef<"Configuration", 'String'>
    readonly configKey: FieldRef<"Configuration", 'String'>
    readonly configValue: FieldRef<"Configuration", 'String'>
    readonly configText: FieldRef<"Configuration", 'String'>
    readonly createdAt: FieldRef<"Configuration", 'DateTime'>
    readonly updatedAt: FieldRef<"Configuration", 'DateTime'>
    readonly enterpriseId: FieldRef<"Configuration", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Configuration findUnique
   */
  export type ConfigurationFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Configuration
     */
    select?: ConfigurationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConfigurationInclude<ExtArgs> | null
    /**
     * Filter, which Configuration to fetch.
     */
    where: ConfigurationWhereUniqueInput
  }


  /**
   * Configuration findUniqueOrThrow
   */
  export type ConfigurationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Configuration
     */
    select?: ConfigurationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConfigurationInclude<ExtArgs> | null
    /**
     * Filter, which Configuration to fetch.
     */
    where: ConfigurationWhereUniqueInput
  }


  /**
   * Configuration findFirst
   */
  export type ConfigurationFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Configuration
     */
    select?: ConfigurationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConfigurationInclude<ExtArgs> | null
    /**
     * Filter, which Configuration to fetch.
     */
    where?: ConfigurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Configurations to fetch.
     */
    orderBy?: ConfigurationOrderByWithRelationInput | ConfigurationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Configurations.
     */
    cursor?: ConfigurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Configurations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Configurations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Configurations.
     */
    distinct?: ConfigurationScalarFieldEnum | ConfigurationScalarFieldEnum[]
  }


  /**
   * Configuration findFirstOrThrow
   */
  export type ConfigurationFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Configuration
     */
    select?: ConfigurationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConfigurationInclude<ExtArgs> | null
    /**
     * Filter, which Configuration to fetch.
     */
    where?: ConfigurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Configurations to fetch.
     */
    orderBy?: ConfigurationOrderByWithRelationInput | ConfigurationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Configurations.
     */
    cursor?: ConfigurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Configurations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Configurations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Configurations.
     */
    distinct?: ConfigurationScalarFieldEnum | ConfigurationScalarFieldEnum[]
  }


  /**
   * Configuration findMany
   */
  export type ConfigurationFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Configuration
     */
    select?: ConfigurationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConfigurationInclude<ExtArgs> | null
    /**
     * Filter, which Configurations to fetch.
     */
    where?: ConfigurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Configurations to fetch.
     */
    orderBy?: ConfigurationOrderByWithRelationInput | ConfigurationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Configurations.
     */
    cursor?: ConfigurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Configurations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Configurations.
     */
    skip?: number
    distinct?: ConfigurationScalarFieldEnum | ConfigurationScalarFieldEnum[]
  }


  /**
   * Configuration create
   */
  export type ConfigurationCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Configuration
     */
    select?: ConfigurationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConfigurationInclude<ExtArgs> | null
    /**
     * The data needed to create a Configuration.
     */
    data: XOR<ConfigurationCreateInput, ConfigurationUncheckedCreateInput>
  }


  /**
   * Configuration createMany
   */
  export type ConfigurationCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Configurations.
     */
    data: ConfigurationCreateManyInput | ConfigurationCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Configuration update
   */
  export type ConfigurationUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Configuration
     */
    select?: ConfigurationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConfigurationInclude<ExtArgs> | null
    /**
     * The data needed to update a Configuration.
     */
    data: XOR<ConfigurationUpdateInput, ConfigurationUncheckedUpdateInput>
    /**
     * Choose, which Configuration to update.
     */
    where: ConfigurationWhereUniqueInput
  }


  /**
   * Configuration updateMany
   */
  export type ConfigurationUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Configurations.
     */
    data: XOR<ConfigurationUpdateManyMutationInput, ConfigurationUncheckedUpdateManyInput>
    /**
     * Filter which Configurations to update
     */
    where?: ConfigurationWhereInput
  }


  /**
   * Configuration upsert
   */
  export type ConfigurationUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Configuration
     */
    select?: ConfigurationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConfigurationInclude<ExtArgs> | null
    /**
     * The filter to search for the Configuration to update in case it exists.
     */
    where: ConfigurationWhereUniqueInput
    /**
     * In case the Configuration found by the `where` argument doesn't exist, create a new Configuration with this data.
     */
    create: XOR<ConfigurationCreateInput, ConfigurationUncheckedCreateInput>
    /**
     * In case the Configuration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConfigurationUpdateInput, ConfigurationUncheckedUpdateInput>
  }


  /**
   * Configuration delete
   */
  export type ConfigurationDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Configuration
     */
    select?: ConfigurationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConfigurationInclude<ExtArgs> | null
    /**
     * Filter which Configuration to delete.
     */
    where: ConfigurationWhereUniqueInput
  }


  /**
   * Configuration deleteMany
   */
  export type ConfigurationDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Configurations to delete
     */
    where?: ConfigurationWhereInput
  }


  /**
   * Configuration without action
   */
  export type ConfigurationDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Configuration
     */
    select?: ConfigurationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConfigurationInclude<ExtArgs> | null
  }



  /**
   * Model Tag
   */

  export type AggregateTag = {
    _count: TagCountAggregateOutputType | null
    _avg: TagAvgAggregateOutputType | null
    _sum: TagSumAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  export type TagAvgAggregateOutputType = {
    id: number | null
  }

  export type TagSumAggregateOutputType = {
    id: number | null
  }

  export type TagMinAggregateOutputType = {
    id: number | null
    uuid: string | null
    name: string | null
    textColor: string | null
    backgroundColor: string | null
    status: string | null
    updatedAt: Date | null
    deletedAt: Date | null
    description: string | null
  }

  export type TagMaxAggregateOutputType = {
    id: number | null
    uuid: string | null
    name: string | null
    textColor: string | null
    backgroundColor: string | null
    status: string | null
    updatedAt: Date | null
    deletedAt: Date | null
    description: string | null
  }

  export type TagCountAggregateOutputType = {
    id: number
    uuid: number
    name: number
    textColor: number
    backgroundColor: number
    status: number
    updatedAt: number
    deletedAt: number
    description: number
    _all: number
  }


  export type TagAvgAggregateInputType = {
    id?: true
  }

  export type TagSumAggregateInputType = {
    id?: true
  }

  export type TagMinAggregateInputType = {
    id?: true
    uuid?: true
    name?: true
    textColor?: true
    backgroundColor?: true
    status?: true
    updatedAt?: true
    deletedAt?: true
    description?: true
  }

  export type TagMaxAggregateInputType = {
    id?: true
    uuid?: true
    name?: true
    textColor?: true
    backgroundColor?: true
    status?: true
    updatedAt?: true
    deletedAt?: true
    description?: true
  }

  export type TagCountAggregateInputType = {
    id?: true
    uuid?: true
    name?: true
    textColor?: true
    backgroundColor?: true
    status?: true
    updatedAt?: true
    deletedAt?: true
    description?: true
    _all?: true
  }

  export type TagAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tag to aggregate.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tags
    **/
    _count?: true | TagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TagAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TagSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagMaxAggregateInputType
  }

  export type GetTagAggregateType<T extends TagAggregateArgs> = {
        [P in keyof T & keyof AggregateTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTag[P]>
      : GetScalarType<T[P], AggregateTag[P]>
  }




  export type TagGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
    orderBy?: TagOrderByWithAggregationInput | TagOrderByWithAggregationInput[]
    by: TagScalarFieldEnum[] | TagScalarFieldEnum
    having?: TagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagCountAggregateInputType | true
    _avg?: TagAvgAggregateInputType
    _sum?: TagSumAggregateInputType
    _min?: TagMinAggregateInputType
    _max?: TagMaxAggregateInputType
  }

  export type TagGroupByOutputType = {
    id: number
    uuid: string
    name: string
    textColor: string
    backgroundColor: string
    status: string
    updatedAt: Date
    deletedAt: Date | null
    description: string | null
    _count: TagCountAggregateOutputType | null
    _avg: TagAvgAggregateOutputType | null
    _sum: TagSumAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  type GetTagGroupByPayload<T extends TagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagGroupByOutputType[P]>
            : GetScalarType<T[P], TagGroupByOutputType[P]>
        }
      >
    >


  export type TagSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    name?: boolean
    textColor?: boolean
    backgroundColor?: boolean
    status?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    description?: boolean
    productTags?: boolean | Tag$productTagsArgs<ExtArgs>
    promotionTags?: boolean | Tag$promotionTagsArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tag"]>

  export type TagSelectScalar = {
    id?: boolean
    uuid?: boolean
    name?: boolean
    textColor?: boolean
    backgroundColor?: boolean
    status?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    description?: boolean
  }

  export type TagInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    productTags?: boolean | Tag$productTagsArgs<ExtArgs>
    promotionTags?: boolean | Tag$promotionTagsArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $TagPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "Tag"
    objects: {
      productTags: Prisma.$ProductTagPayload<ExtArgs>[]
      promotionTags: Prisma.$PromotionTagPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetResult<{
      id: number
      uuid: string
      name: string
      textColor: string
      backgroundColor: string
      status: string
      updatedAt: Date
      deletedAt: Date | null
      description: string | null
    }, ExtArgs["result"]["tag"]>
    composites: {}
  }


  type TagGetPayload<S extends boolean | null | undefined | TagDefaultArgs> = $Result.GetResult<Prisma.$TagPayload, S>

  type TagCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<TagFindManyArgs, 'select' | 'include'> & {
      select?: TagCountAggregateInputType | true
    }

  export interface TagDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tag'], meta: { name: 'Tag' } }
    /**
     * Find zero or one Tag that matches the filter.
     * @param {TagFindUniqueArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TagFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, TagFindUniqueArgs<ExtArgs>>
    ): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Tag that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TagFindUniqueOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TagFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TagFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Tag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TagFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, TagFindFirstArgs<ExtArgs>>
    ): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Tag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TagFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TagFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tags
     * const tags = await prisma.tag.findMany()
     * 
     * // Get first 10 Tags
     * const tags = await prisma.tag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tagWithIdOnly = await prisma.tag.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TagFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TagFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Tag.
     * @param {TagCreateArgs} args - Arguments to create a Tag.
     * @example
     * // Create one Tag
     * const Tag = await prisma.tag.create({
     *   data: {
     *     // ... data to create a Tag
     *   }
     * })
     * 
    **/
    create<T extends TagCreateArgs<ExtArgs>>(
      args: SelectSubset<T, TagCreateArgs<ExtArgs>>
    ): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Tags.
     *     @param {TagCreateManyArgs} args - Arguments to create many Tags.
     *     @example
     *     // Create many Tags
     *     const tag = await prisma.tag.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TagCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TagCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tag.
     * @param {TagDeleteArgs} args - Arguments to delete one Tag.
     * @example
     * // Delete one Tag
     * const Tag = await prisma.tag.delete({
     *   where: {
     *     // ... filter to delete one Tag
     *   }
     * })
     * 
    **/
    delete<T extends TagDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, TagDeleteArgs<ExtArgs>>
    ): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Tag.
     * @param {TagUpdateArgs} args - Arguments to update one Tag.
     * @example
     * // Update one Tag
     * const tag = await prisma.tag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TagUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, TagUpdateArgs<ExtArgs>>
    ): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Tags.
     * @param {TagDeleteManyArgs} args - Arguments to filter Tags to delete.
     * @example
     * // Delete a few Tags
     * const { count } = await prisma.tag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TagDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TagDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TagUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, TagUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tag.
     * @param {TagUpsertArgs} args - Arguments to update or create a Tag.
     * @example
     * // Update or create a Tag
     * const tag = await prisma.tag.upsert({
     *   create: {
     *     // ... data to create a Tag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tag we want to update
     *   }
     * })
    **/
    upsert<T extends TagUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, TagUpsertArgs<ExtArgs>>
    ): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagCountArgs} args - Arguments to filter Tags to count.
     * @example
     * // Count the number of Tags
     * const count = await prisma.tag.count({
     *   where: {
     *     // ... the filter for the Tags we want to count
     *   }
     * })
    **/
    count<T extends TagCountArgs>(
      args?: Subset<T, TagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagAggregateArgs>(args: Subset<T, TagAggregateArgs>): Prisma.PrismaPromise<GetTagAggregateType<T>>

    /**
     * Group by Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TagGroupByArgs['orderBy'] }
        : { orderBy?: TagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tag model
   */
  readonly fields: TagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TagClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    productTags<T extends Tag$productTagsArgs<ExtArgs> = {}>(args?: Subset<T, Tag$productTagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductTagPayload<ExtArgs>, T, 'findMany'> | Null>;

    promotionTags<T extends Tag$promotionTagsArgs<ExtArgs> = {}>(args?: Subset<T, Tag$promotionTagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromotionTagPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Tag model
   */ 
  interface TagFieldRefs {
    readonly id: FieldRef<"Tag", 'Int'>
    readonly uuid: FieldRef<"Tag", 'String'>
    readonly name: FieldRef<"Tag", 'String'>
    readonly textColor: FieldRef<"Tag", 'String'>
    readonly backgroundColor: FieldRef<"Tag", 'String'>
    readonly status: FieldRef<"Tag", 'String'>
    readonly updatedAt: FieldRef<"Tag", 'DateTime'>
    readonly deletedAt: FieldRef<"Tag", 'DateTime'>
    readonly description: FieldRef<"Tag", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Tag findUnique
   */
  export type TagFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }


  /**
   * Tag findUniqueOrThrow
   */
  export type TagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }


  /**
   * Tag findFirst
   */
  export type TagFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }


  /**
   * Tag findFirstOrThrow
   */
  export type TagFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }


  /**
   * Tag findMany
   */
  export type TagFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }


  /**
   * Tag create
   */
  export type TagCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to create a Tag.
     */
    data: XOR<TagCreateInput, TagUncheckedCreateInput>
  }


  /**
   * Tag createMany
   */
  export type TagCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Tag update
   */
  export type TagUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to update a Tag.
     */
    data: XOR<TagUpdateInput, TagUncheckedUpdateInput>
    /**
     * Choose, which Tag to update.
     */
    where: TagWhereUniqueInput
  }


  /**
   * Tag updateMany
   */
  export type TagUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
  }


  /**
   * Tag upsert
   */
  export type TagUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The filter to search for the Tag to update in case it exists.
     */
    where: TagWhereUniqueInput
    /**
     * In case the Tag found by the `where` argument doesn't exist, create a new Tag with this data.
     */
    create: XOR<TagCreateInput, TagUncheckedCreateInput>
    /**
     * In case the Tag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TagUpdateInput, TagUncheckedUpdateInput>
  }


  /**
   * Tag delete
   */
  export type TagDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter which Tag to delete.
     */
    where: TagWhereUniqueInput
  }


  /**
   * Tag deleteMany
   */
  export type TagDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tags to delete
     */
    where?: TagWhereInput
  }


  /**
   * Tag.productTags
   */
  export type Tag$productTagsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTag
     */
    select?: ProductTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductTagInclude<ExtArgs> | null
    where?: ProductTagWhereInput
    orderBy?: ProductTagOrderByWithRelationInput | ProductTagOrderByWithRelationInput[]
    cursor?: ProductTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductTagScalarFieldEnum | ProductTagScalarFieldEnum[]
  }


  /**
   * Tag.promotionTags
   */
  export type Tag$promotionTagsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionTag
     */
    select?: PromotionTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PromotionTagInclude<ExtArgs> | null
    where?: PromotionTagWhereInput
    orderBy?: PromotionTagOrderByWithRelationInput | PromotionTagOrderByWithRelationInput[]
    cursor?: PromotionTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PromotionTagScalarFieldEnum | PromotionTagScalarFieldEnum[]
  }


  /**
   * Tag without action
   */
  export type TagDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagInclude<ExtArgs> | null
  }



  /**
   * Model ProductTag
   */

  export type AggregateProductTag = {
    _count: ProductTagCountAggregateOutputType | null
    _avg: ProductTagAvgAggregateOutputType | null
    _sum: ProductTagSumAggregateOutputType | null
    _min: ProductTagMinAggregateOutputType | null
    _max: ProductTagMaxAggregateOutputType | null
  }

  export type ProductTagAvgAggregateOutputType = {
    id: number | null
    productId: number | null
    tagId: number | null
  }

  export type ProductTagSumAggregateOutputType = {
    id: number | null
    productId: number | null
    tagId: number | null
  }

  export type ProductTagMinAggregateOutputType = {
    id: number | null
    uuid: string | null
    productId: number | null
    tagId: number | null
  }

  export type ProductTagMaxAggregateOutputType = {
    id: number | null
    uuid: string | null
    productId: number | null
    tagId: number | null
  }

  export type ProductTagCountAggregateOutputType = {
    id: number
    uuid: number
    productId: number
    tagId: number
    _all: number
  }


  export type ProductTagAvgAggregateInputType = {
    id?: true
    productId?: true
    tagId?: true
  }

  export type ProductTagSumAggregateInputType = {
    id?: true
    productId?: true
    tagId?: true
  }

  export type ProductTagMinAggregateInputType = {
    id?: true
    uuid?: true
    productId?: true
    tagId?: true
  }

  export type ProductTagMaxAggregateInputType = {
    id?: true
    uuid?: true
    productId?: true
    tagId?: true
  }

  export type ProductTagCountAggregateInputType = {
    id?: true
    uuid?: true
    productId?: true
    tagId?: true
    _all?: true
  }

  export type ProductTagAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductTag to aggregate.
     */
    where?: ProductTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductTags to fetch.
     */
    orderBy?: ProductTagOrderByWithRelationInput | ProductTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductTags
    **/
    _count?: true | ProductTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductTagAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductTagSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductTagMaxAggregateInputType
  }

  export type GetProductTagAggregateType<T extends ProductTagAggregateArgs> = {
        [P in keyof T & keyof AggregateProductTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductTag[P]>
      : GetScalarType<T[P], AggregateProductTag[P]>
  }




  export type ProductTagGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ProductTagWhereInput
    orderBy?: ProductTagOrderByWithAggregationInput | ProductTagOrderByWithAggregationInput[]
    by: ProductTagScalarFieldEnum[] | ProductTagScalarFieldEnum
    having?: ProductTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductTagCountAggregateInputType | true
    _avg?: ProductTagAvgAggregateInputType
    _sum?: ProductTagSumAggregateInputType
    _min?: ProductTagMinAggregateInputType
    _max?: ProductTagMaxAggregateInputType
  }

  export type ProductTagGroupByOutputType = {
    id: number
    uuid: string
    productId: number
    tagId: number
    _count: ProductTagCountAggregateOutputType | null
    _avg: ProductTagAvgAggregateOutputType | null
    _sum: ProductTagSumAggregateOutputType | null
    _min: ProductTagMinAggregateOutputType | null
    _max: ProductTagMaxAggregateOutputType | null
  }

  type GetProductTagGroupByPayload<T extends ProductTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductTagGroupByOutputType[P]>
            : GetScalarType<T[P], ProductTagGroupByOutputType[P]>
        }
      >
    >


  export type ProductTagSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    productId?: boolean
    tagId?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productTag"]>

  export type ProductTagSelectScalar = {
    id?: boolean
    uuid?: boolean
    productId?: boolean
    tagId?: boolean
  }

  export type ProductTagInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }


  export type $ProductTagPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "ProductTag"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
      tag: Prisma.$TagPayload<ExtArgs>
    }
    scalars: $Extensions.GetResult<{
      id: number
      uuid: string
      productId: number
      tagId: number
    }, ExtArgs["result"]["productTag"]>
    composites: {}
  }


  type ProductTagGetPayload<S extends boolean | null | undefined | ProductTagDefaultArgs> = $Result.GetResult<Prisma.$ProductTagPayload, S>

  type ProductTagCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ProductTagFindManyArgs, 'select' | 'include'> & {
      select?: ProductTagCountAggregateInputType | true
    }

  export interface ProductTagDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductTag'], meta: { name: 'ProductTag' } }
    /**
     * Find zero or one ProductTag that matches the filter.
     * @param {ProductTagFindUniqueArgs} args - Arguments to find a ProductTag
     * @example
     * // Get one ProductTag
     * const productTag = await prisma.productTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProductTagFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ProductTagFindUniqueArgs<ExtArgs>>
    ): Prisma__ProductTagClient<$Result.GetResult<Prisma.$ProductTagPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ProductTag that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProductTagFindUniqueOrThrowArgs} args - Arguments to find a ProductTag
     * @example
     * // Get one ProductTag
     * const productTag = await prisma.productTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProductTagFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductTagFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ProductTagClient<$Result.GetResult<Prisma.$ProductTagPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ProductTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductTagFindFirstArgs} args - Arguments to find a ProductTag
     * @example
     * // Get one ProductTag
     * const productTag = await prisma.productTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProductTagFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductTagFindFirstArgs<ExtArgs>>
    ): Prisma__ProductTagClient<$Result.GetResult<Prisma.$ProductTagPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ProductTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductTagFindFirstOrThrowArgs} args - Arguments to find a ProductTag
     * @example
     * // Get one ProductTag
     * const productTag = await prisma.productTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProductTagFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductTagFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ProductTagClient<$Result.GetResult<Prisma.$ProductTagPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ProductTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductTagFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductTags
     * const productTags = await prisma.productTag.findMany()
     * 
     * // Get first 10 ProductTags
     * const productTags = await prisma.productTag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productTagWithIdOnly = await prisma.productTag.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProductTagFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductTagFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductTagPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ProductTag.
     * @param {ProductTagCreateArgs} args - Arguments to create a ProductTag.
     * @example
     * // Create one ProductTag
     * const ProductTag = await prisma.productTag.create({
     *   data: {
     *     // ... data to create a ProductTag
     *   }
     * })
     * 
    **/
    create<T extends ProductTagCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ProductTagCreateArgs<ExtArgs>>
    ): Prisma__ProductTagClient<$Result.GetResult<Prisma.$ProductTagPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ProductTags.
     *     @param {ProductTagCreateManyArgs} args - Arguments to create many ProductTags.
     *     @example
     *     // Create many ProductTags
     *     const productTag = await prisma.productTag.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProductTagCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductTagCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProductTag.
     * @param {ProductTagDeleteArgs} args - Arguments to delete one ProductTag.
     * @example
     * // Delete one ProductTag
     * const ProductTag = await prisma.productTag.delete({
     *   where: {
     *     // ... filter to delete one ProductTag
     *   }
     * })
     * 
    **/
    delete<T extends ProductTagDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ProductTagDeleteArgs<ExtArgs>>
    ): Prisma__ProductTagClient<$Result.GetResult<Prisma.$ProductTagPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ProductTag.
     * @param {ProductTagUpdateArgs} args - Arguments to update one ProductTag.
     * @example
     * // Update one ProductTag
     * const productTag = await prisma.productTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProductTagUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ProductTagUpdateArgs<ExtArgs>>
    ): Prisma__ProductTagClient<$Result.GetResult<Prisma.$ProductTagPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ProductTags.
     * @param {ProductTagDeleteManyArgs} args - Arguments to filter ProductTags to delete.
     * @example
     * // Delete a few ProductTags
     * const { count } = await prisma.productTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProductTagDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductTagDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductTags
     * const productTag = await prisma.productTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProductTagUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ProductTagUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductTag.
     * @param {ProductTagUpsertArgs} args - Arguments to update or create a ProductTag.
     * @example
     * // Update or create a ProductTag
     * const productTag = await prisma.productTag.upsert({
     *   create: {
     *     // ... data to create a ProductTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductTag we want to update
     *   }
     * })
    **/
    upsert<T extends ProductTagUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ProductTagUpsertArgs<ExtArgs>>
    ): Prisma__ProductTagClient<$Result.GetResult<Prisma.$ProductTagPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ProductTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductTagCountArgs} args - Arguments to filter ProductTags to count.
     * @example
     * // Count the number of ProductTags
     * const count = await prisma.productTag.count({
     *   where: {
     *     // ... the filter for the ProductTags we want to count
     *   }
     * })
    **/
    count<T extends ProductTagCountArgs>(
      args?: Subset<T, ProductTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductTagAggregateArgs>(args: Subset<T, ProductTagAggregateArgs>): Prisma.PrismaPromise<GetProductTagAggregateType<T>>

    /**
     * Group by ProductTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductTagGroupByArgs['orderBy'] }
        : { orderBy?: ProductTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductTag model
   */
  readonly fields: ProductTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductTagClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    tag<T extends TagDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TagDefaultArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ProductTag model
   */ 
  interface ProductTagFieldRefs {
    readonly id: FieldRef<"ProductTag", 'Int'>
    readonly uuid: FieldRef<"ProductTag", 'String'>
    readonly productId: FieldRef<"ProductTag", 'Int'>
    readonly tagId: FieldRef<"ProductTag", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * ProductTag findUnique
   */
  export type ProductTagFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTag
     */
    select?: ProductTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductTagInclude<ExtArgs> | null
    /**
     * Filter, which ProductTag to fetch.
     */
    where: ProductTagWhereUniqueInput
  }


  /**
   * ProductTag findUniqueOrThrow
   */
  export type ProductTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTag
     */
    select?: ProductTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductTagInclude<ExtArgs> | null
    /**
     * Filter, which ProductTag to fetch.
     */
    where: ProductTagWhereUniqueInput
  }


  /**
   * ProductTag findFirst
   */
  export type ProductTagFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTag
     */
    select?: ProductTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductTagInclude<ExtArgs> | null
    /**
     * Filter, which ProductTag to fetch.
     */
    where?: ProductTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductTags to fetch.
     */
    orderBy?: ProductTagOrderByWithRelationInput | ProductTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductTags.
     */
    cursor?: ProductTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductTags.
     */
    distinct?: ProductTagScalarFieldEnum | ProductTagScalarFieldEnum[]
  }


  /**
   * ProductTag findFirstOrThrow
   */
  export type ProductTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTag
     */
    select?: ProductTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductTagInclude<ExtArgs> | null
    /**
     * Filter, which ProductTag to fetch.
     */
    where?: ProductTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductTags to fetch.
     */
    orderBy?: ProductTagOrderByWithRelationInput | ProductTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductTags.
     */
    cursor?: ProductTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductTags.
     */
    distinct?: ProductTagScalarFieldEnum | ProductTagScalarFieldEnum[]
  }


  /**
   * ProductTag findMany
   */
  export type ProductTagFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTag
     */
    select?: ProductTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductTagInclude<ExtArgs> | null
    /**
     * Filter, which ProductTags to fetch.
     */
    where?: ProductTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductTags to fetch.
     */
    orderBy?: ProductTagOrderByWithRelationInput | ProductTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductTags.
     */
    cursor?: ProductTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductTags.
     */
    skip?: number
    distinct?: ProductTagScalarFieldEnum | ProductTagScalarFieldEnum[]
  }


  /**
   * ProductTag create
   */
  export type ProductTagCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTag
     */
    select?: ProductTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductTagInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductTag.
     */
    data: XOR<ProductTagCreateInput, ProductTagUncheckedCreateInput>
  }


  /**
   * ProductTag createMany
   */
  export type ProductTagCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductTags.
     */
    data: ProductTagCreateManyInput | ProductTagCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ProductTag update
   */
  export type ProductTagUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTag
     */
    select?: ProductTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductTagInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductTag.
     */
    data: XOR<ProductTagUpdateInput, ProductTagUncheckedUpdateInput>
    /**
     * Choose, which ProductTag to update.
     */
    where: ProductTagWhereUniqueInput
  }


  /**
   * ProductTag updateMany
   */
  export type ProductTagUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductTags.
     */
    data: XOR<ProductTagUpdateManyMutationInput, ProductTagUncheckedUpdateManyInput>
    /**
     * Filter which ProductTags to update
     */
    where?: ProductTagWhereInput
  }


  /**
   * ProductTag upsert
   */
  export type ProductTagUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTag
     */
    select?: ProductTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductTagInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductTag to update in case it exists.
     */
    where: ProductTagWhereUniqueInput
    /**
     * In case the ProductTag found by the `where` argument doesn't exist, create a new ProductTag with this data.
     */
    create: XOR<ProductTagCreateInput, ProductTagUncheckedCreateInput>
    /**
     * In case the ProductTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductTagUpdateInput, ProductTagUncheckedUpdateInput>
  }


  /**
   * ProductTag delete
   */
  export type ProductTagDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTag
     */
    select?: ProductTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductTagInclude<ExtArgs> | null
    /**
     * Filter which ProductTag to delete.
     */
    where: ProductTagWhereUniqueInput
  }


  /**
   * ProductTag deleteMany
   */
  export type ProductTagDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductTags to delete
     */
    where?: ProductTagWhereInput
  }


  /**
   * ProductTag without action
   */
  export type ProductTagDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTag
     */
    select?: ProductTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductTagInclude<ExtArgs> | null
  }



  /**
   * Model PromotionTag
   */

  export type AggregatePromotionTag = {
    _count: PromotionTagCountAggregateOutputType | null
    _avg: PromotionTagAvgAggregateOutputType | null
    _sum: PromotionTagSumAggregateOutputType | null
    _min: PromotionTagMinAggregateOutputType | null
    _max: PromotionTagMaxAggregateOutputType | null
  }

  export type PromotionTagAvgAggregateOutputType = {
    id: number | null
    promotionId: number | null
    tagId: number | null
  }

  export type PromotionTagSumAggregateOutputType = {
    id: number | null
    promotionId: number | null
    tagId: number | null
  }

  export type PromotionTagMinAggregateOutputType = {
    id: number | null
    uuid: string | null
    promotionId: number | null
    tagId: number | null
  }

  export type PromotionTagMaxAggregateOutputType = {
    id: number | null
    uuid: string | null
    promotionId: number | null
    tagId: number | null
  }

  export type PromotionTagCountAggregateOutputType = {
    id: number
    uuid: number
    promotionId: number
    tagId: number
    _all: number
  }


  export type PromotionTagAvgAggregateInputType = {
    id?: true
    promotionId?: true
    tagId?: true
  }

  export type PromotionTagSumAggregateInputType = {
    id?: true
    promotionId?: true
    tagId?: true
  }

  export type PromotionTagMinAggregateInputType = {
    id?: true
    uuid?: true
    promotionId?: true
    tagId?: true
  }

  export type PromotionTagMaxAggregateInputType = {
    id?: true
    uuid?: true
    promotionId?: true
    tagId?: true
  }

  export type PromotionTagCountAggregateInputType = {
    id?: true
    uuid?: true
    promotionId?: true
    tagId?: true
    _all?: true
  }

  export type PromotionTagAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which PromotionTag to aggregate.
     */
    where?: PromotionTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromotionTags to fetch.
     */
    orderBy?: PromotionTagOrderByWithRelationInput | PromotionTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PromotionTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromotionTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromotionTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PromotionTags
    **/
    _count?: true | PromotionTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PromotionTagAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PromotionTagSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PromotionTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PromotionTagMaxAggregateInputType
  }

  export type GetPromotionTagAggregateType<T extends PromotionTagAggregateArgs> = {
        [P in keyof T & keyof AggregatePromotionTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePromotionTag[P]>
      : GetScalarType<T[P], AggregatePromotionTag[P]>
  }




  export type PromotionTagGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PromotionTagWhereInput
    orderBy?: PromotionTagOrderByWithAggregationInput | PromotionTagOrderByWithAggregationInput[]
    by: PromotionTagScalarFieldEnum[] | PromotionTagScalarFieldEnum
    having?: PromotionTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PromotionTagCountAggregateInputType | true
    _avg?: PromotionTagAvgAggregateInputType
    _sum?: PromotionTagSumAggregateInputType
    _min?: PromotionTagMinAggregateInputType
    _max?: PromotionTagMaxAggregateInputType
  }

  export type PromotionTagGroupByOutputType = {
    id: number
    uuid: string
    promotionId: number
    tagId: number
    _count: PromotionTagCountAggregateOutputType | null
    _avg: PromotionTagAvgAggregateOutputType | null
    _sum: PromotionTagSumAggregateOutputType | null
    _min: PromotionTagMinAggregateOutputType | null
    _max: PromotionTagMaxAggregateOutputType | null
  }

  type GetPromotionTagGroupByPayload<T extends PromotionTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PromotionTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PromotionTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PromotionTagGroupByOutputType[P]>
            : GetScalarType<T[P], PromotionTagGroupByOutputType[P]>
        }
      >
    >


  export type PromotionTagSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    promotionId?: boolean
    tagId?: boolean
    promotion?: boolean | PromotionDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["promotionTag"]>

  export type PromotionTagSelectScalar = {
    id?: boolean
    uuid?: boolean
    promotionId?: boolean
    tagId?: boolean
  }

  export type PromotionTagInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    promotion?: boolean | PromotionDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }


  export type $PromotionTagPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "PromotionTag"
    objects: {
      promotion: Prisma.$PromotionPayload<ExtArgs>
      tag: Prisma.$TagPayload<ExtArgs>
    }
    scalars: $Extensions.GetResult<{
      id: number
      uuid: string
      promotionId: number
      tagId: number
    }, ExtArgs["result"]["promotionTag"]>
    composites: {}
  }


  type PromotionTagGetPayload<S extends boolean | null | undefined | PromotionTagDefaultArgs> = $Result.GetResult<Prisma.$PromotionTagPayload, S>

  type PromotionTagCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<PromotionTagFindManyArgs, 'select' | 'include'> & {
      select?: PromotionTagCountAggregateInputType | true
    }

  export interface PromotionTagDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PromotionTag'], meta: { name: 'PromotionTag' } }
    /**
     * Find zero or one PromotionTag that matches the filter.
     * @param {PromotionTagFindUniqueArgs} args - Arguments to find a PromotionTag
     * @example
     * // Get one PromotionTag
     * const promotionTag = await prisma.promotionTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PromotionTagFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PromotionTagFindUniqueArgs<ExtArgs>>
    ): Prisma__PromotionTagClient<$Result.GetResult<Prisma.$PromotionTagPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one PromotionTag that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PromotionTagFindUniqueOrThrowArgs} args - Arguments to find a PromotionTag
     * @example
     * // Get one PromotionTag
     * const promotionTag = await prisma.promotionTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PromotionTagFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PromotionTagFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PromotionTagClient<$Result.GetResult<Prisma.$PromotionTagPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first PromotionTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionTagFindFirstArgs} args - Arguments to find a PromotionTag
     * @example
     * // Get one PromotionTag
     * const promotionTag = await prisma.promotionTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PromotionTagFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PromotionTagFindFirstArgs<ExtArgs>>
    ): Prisma__PromotionTagClient<$Result.GetResult<Prisma.$PromotionTagPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first PromotionTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionTagFindFirstOrThrowArgs} args - Arguments to find a PromotionTag
     * @example
     * // Get one PromotionTag
     * const promotionTag = await prisma.promotionTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PromotionTagFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PromotionTagFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PromotionTagClient<$Result.GetResult<Prisma.$PromotionTagPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more PromotionTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionTagFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PromotionTags
     * const promotionTags = await prisma.promotionTag.findMany()
     * 
     * // Get first 10 PromotionTags
     * const promotionTags = await prisma.promotionTag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const promotionTagWithIdOnly = await prisma.promotionTag.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PromotionTagFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PromotionTagFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromotionTagPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a PromotionTag.
     * @param {PromotionTagCreateArgs} args - Arguments to create a PromotionTag.
     * @example
     * // Create one PromotionTag
     * const PromotionTag = await prisma.promotionTag.create({
     *   data: {
     *     // ... data to create a PromotionTag
     *   }
     * })
     * 
    **/
    create<T extends PromotionTagCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PromotionTagCreateArgs<ExtArgs>>
    ): Prisma__PromotionTagClient<$Result.GetResult<Prisma.$PromotionTagPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many PromotionTags.
     *     @param {PromotionTagCreateManyArgs} args - Arguments to create many PromotionTags.
     *     @example
     *     // Create many PromotionTags
     *     const promotionTag = await prisma.promotionTag.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PromotionTagCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PromotionTagCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PromotionTag.
     * @param {PromotionTagDeleteArgs} args - Arguments to delete one PromotionTag.
     * @example
     * // Delete one PromotionTag
     * const PromotionTag = await prisma.promotionTag.delete({
     *   where: {
     *     // ... filter to delete one PromotionTag
     *   }
     * })
     * 
    **/
    delete<T extends PromotionTagDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PromotionTagDeleteArgs<ExtArgs>>
    ): Prisma__PromotionTagClient<$Result.GetResult<Prisma.$PromotionTagPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one PromotionTag.
     * @param {PromotionTagUpdateArgs} args - Arguments to update one PromotionTag.
     * @example
     * // Update one PromotionTag
     * const promotionTag = await prisma.promotionTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PromotionTagUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PromotionTagUpdateArgs<ExtArgs>>
    ): Prisma__PromotionTagClient<$Result.GetResult<Prisma.$PromotionTagPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more PromotionTags.
     * @param {PromotionTagDeleteManyArgs} args - Arguments to filter PromotionTags to delete.
     * @example
     * // Delete a few PromotionTags
     * const { count } = await prisma.promotionTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PromotionTagDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PromotionTagDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PromotionTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PromotionTags
     * const promotionTag = await prisma.promotionTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PromotionTagUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PromotionTagUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PromotionTag.
     * @param {PromotionTagUpsertArgs} args - Arguments to update or create a PromotionTag.
     * @example
     * // Update or create a PromotionTag
     * const promotionTag = await prisma.promotionTag.upsert({
     *   create: {
     *     // ... data to create a PromotionTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PromotionTag we want to update
     *   }
     * })
    **/
    upsert<T extends PromotionTagUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PromotionTagUpsertArgs<ExtArgs>>
    ): Prisma__PromotionTagClient<$Result.GetResult<Prisma.$PromotionTagPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of PromotionTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionTagCountArgs} args - Arguments to filter PromotionTags to count.
     * @example
     * // Count the number of PromotionTags
     * const count = await prisma.promotionTag.count({
     *   where: {
     *     // ... the filter for the PromotionTags we want to count
     *   }
     * })
    **/
    count<T extends PromotionTagCountArgs>(
      args?: Subset<T, PromotionTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PromotionTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PromotionTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PromotionTagAggregateArgs>(args: Subset<T, PromotionTagAggregateArgs>): Prisma.PrismaPromise<GetPromotionTagAggregateType<T>>

    /**
     * Group by PromotionTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PromotionTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PromotionTagGroupByArgs['orderBy'] }
        : { orderBy?: PromotionTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PromotionTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPromotionTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PromotionTag model
   */
  readonly fields: PromotionTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PromotionTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PromotionTagClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    promotion<T extends PromotionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PromotionDefaultArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    tag<T extends TagDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TagDefaultArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the PromotionTag model
   */ 
  interface PromotionTagFieldRefs {
    readonly id: FieldRef<"PromotionTag", 'Int'>
    readonly uuid: FieldRef<"PromotionTag", 'String'>
    readonly promotionId: FieldRef<"PromotionTag", 'Int'>
    readonly tagId: FieldRef<"PromotionTag", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * PromotionTag findUnique
   */
  export type PromotionTagFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionTag
     */
    select?: PromotionTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PromotionTagInclude<ExtArgs> | null
    /**
     * Filter, which PromotionTag to fetch.
     */
    where: PromotionTagWhereUniqueInput
  }


  /**
   * PromotionTag findUniqueOrThrow
   */
  export type PromotionTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionTag
     */
    select?: PromotionTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PromotionTagInclude<ExtArgs> | null
    /**
     * Filter, which PromotionTag to fetch.
     */
    where: PromotionTagWhereUniqueInput
  }


  /**
   * PromotionTag findFirst
   */
  export type PromotionTagFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionTag
     */
    select?: PromotionTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PromotionTagInclude<ExtArgs> | null
    /**
     * Filter, which PromotionTag to fetch.
     */
    where?: PromotionTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromotionTags to fetch.
     */
    orderBy?: PromotionTagOrderByWithRelationInput | PromotionTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PromotionTags.
     */
    cursor?: PromotionTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromotionTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromotionTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PromotionTags.
     */
    distinct?: PromotionTagScalarFieldEnum | PromotionTagScalarFieldEnum[]
  }


  /**
   * PromotionTag findFirstOrThrow
   */
  export type PromotionTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionTag
     */
    select?: PromotionTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PromotionTagInclude<ExtArgs> | null
    /**
     * Filter, which PromotionTag to fetch.
     */
    where?: PromotionTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromotionTags to fetch.
     */
    orderBy?: PromotionTagOrderByWithRelationInput | PromotionTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PromotionTags.
     */
    cursor?: PromotionTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromotionTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromotionTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PromotionTags.
     */
    distinct?: PromotionTagScalarFieldEnum | PromotionTagScalarFieldEnum[]
  }


  /**
   * PromotionTag findMany
   */
  export type PromotionTagFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionTag
     */
    select?: PromotionTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PromotionTagInclude<ExtArgs> | null
    /**
     * Filter, which PromotionTags to fetch.
     */
    where?: PromotionTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromotionTags to fetch.
     */
    orderBy?: PromotionTagOrderByWithRelationInput | PromotionTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PromotionTags.
     */
    cursor?: PromotionTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromotionTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromotionTags.
     */
    skip?: number
    distinct?: PromotionTagScalarFieldEnum | PromotionTagScalarFieldEnum[]
  }


  /**
   * PromotionTag create
   */
  export type PromotionTagCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionTag
     */
    select?: PromotionTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PromotionTagInclude<ExtArgs> | null
    /**
     * The data needed to create a PromotionTag.
     */
    data: XOR<PromotionTagCreateInput, PromotionTagUncheckedCreateInput>
  }


  /**
   * PromotionTag createMany
   */
  export type PromotionTagCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PromotionTags.
     */
    data: PromotionTagCreateManyInput | PromotionTagCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * PromotionTag update
   */
  export type PromotionTagUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionTag
     */
    select?: PromotionTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PromotionTagInclude<ExtArgs> | null
    /**
     * The data needed to update a PromotionTag.
     */
    data: XOR<PromotionTagUpdateInput, PromotionTagUncheckedUpdateInput>
    /**
     * Choose, which PromotionTag to update.
     */
    where: PromotionTagWhereUniqueInput
  }


  /**
   * PromotionTag updateMany
   */
  export type PromotionTagUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PromotionTags.
     */
    data: XOR<PromotionTagUpdateManyMutationInput, PromotionTagUncheckedUpdateManyInput>
    /**
     * Filter which PromotionTags to update
     */
    where?: PromotionTagWhereInput
  }


  /**
   * PromotionTag upsert
   */
  export type PromotionTagUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionTag
     */
    select?: PromotionTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PromotionTagInclude<ExtArgs> | null
    /**
     * The filter to search for the PromotionTag to update in case it exists.
     */
    where: PromotionTagWhereUniqueInput
    /**
     * In case the PromotionTag found by the `where` argument doesn't exist, create a new PromotionTag with this data.
     */
    create: XOR<PromotionTagCreateInput, PromotionTagUncheckedCreateInput>
    /**
     * In case the PromotionTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PromotionTagUpdateInput, PromotionTagUncheckedUpdateInput>
  }


  /**
   * PromotionTag delete
   */
  export type PromotionTagDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionTag
     */
    select?: PromotionTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PromotionTagInclude<ExtArgs> | null
    /**
     * Filter which PromotionTag to delete.
     */
    where: PromotionTagWhereUniqueInput
  }


  /**
   * PromotionTag deleteMany
   */
  export type PromotionTagDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which PromotionTags to delete
     */
    where?: PromotionTagWhereInput
  }


  /**
   * PromotionTag without action
   */
  export type PromotionTagDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionTag
     */
    select?: PromotionTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PromotionTagInclude<ExtArgs> | null
  }



  /**
   * Model Promotion
   */

  export type AggregatePromotion = {
    _count: PromotionCountAggregateOutputType | null
    _avg: PromotionAvgAggregateOutputType | null
    _sum: PromotionSumAggregateOutputType | null
    _min: PromotionMinAggregateOutputType | null
    _max: PromotionMaxAggregateOutputType | null
  }

  export type PromotionAvgAggregateOutputType = {
    id: number | null
    discountRate: number | null
    categoryId: number | null
    enterpriseId: number | null
  }

  export type PromotionSumAggregateOutputType = {
    id: number | null
    discountRate: number | null
    categoryId: number | null
    enterpriseId: number | null
  }

  export type PromotionMinAggregateOutputType = {
    id: number | null
    uuid: string | null
    name: string | null
    description: string | null
    status: string | null
    discountRate: number | null
    startDate: Date | null
    endDate: Date | null
    categoryId: number | null
    enterpriseId: number | null
    deletedAt: Date | null
  }

  export type PromotionMaxAggregateOutputType = {
    id: number | null
    uuid: string | null
    name: string | null
    description: string | null
    status: string | null
    discountRate: number | null
    startDate: Date | null
    endDate: Date | null
    categoryId: number | null
    enterpriseId: number | null
    deletedAt: Date | null
  }

  export type PromotionCountAggregateOutputType = {
    id: number
    uuid: number
    name: number
    description: number
    status: number
    discountRate: number
    startDate: number
    endDate: number
    categoryId: number
    enterpriseId: number
    deletedAt: number
    _all: number
  }


  export type PromotionAvgAggregateInputType = {
    id?: true
    discountRate?: true
    categoryId?: true
    enterpriseId?: true
  }

  export type PromotionSumAggregateInputType = {
    id?: true
    discountRate?: true
    categoryId?: true
    enterpriseId?: true
  }

  export type PromotionMinAggregateInputType = {
    id?: true
    uuid?: true
    name?: true
    description?: true
    status?: true
    discountRate?: true
    startDate?: true
    endDate?: true
    categoryId?: true
    enterpriseId?: true
    deletedAt?: true
  }

  export type PromotionMaxAggregateInputType = {
    id?: true
    uuid?: true
    name?: true
    description?: true
    status?: true
    discountRate?: true
    startDate?: true
    endDate?: true
    categoryId?: true
    enterpriseId?: true
    deletedAt?: true
  }

  export type PromotionCountAggregateInputType = {
    id?: true
    uuid?: true
    name?: true
    description?: true
    status?: true
    discountRate?: true
    startDate?: true
    endDate?: true
    categoryId?: true
    enterpriseId?: true
    deletedAt?: true
    _all?: true
  }

  export type PromotionAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Promotion to aggregate.
     */
    where?: PromotionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Promotions to fetch.
     */
    orderBy?: PromotionOrderByWithRelationInput | PromotionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PromotionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Promotions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Promotions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Promotions
    **/
    _count?: true | PromotionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PromotionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PromotionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PromotionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PromotionMaxAggregateInputType
  }

  export type GetPromotionAggregateType<T extends PromotionAggregateArgs> = {
        [P in keyof T & keyof AggregatePromotion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePromotion[P]>
      : GetScalarType<T[P], AggregatePromotion[P]>
  }




  export type PromotionGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PromotionWhereInput
    orderBy?: PromotionOrderByWithAggregationInput | PromotionOrderByWithAggregationInput[]
    by: PromotionScalarFieldEnum[] | PromotionScalarFieldEnum
    having?: PromotionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PromotionCountAggregateInputType | true
    _avg?: PromotionAvgAggregateInputType
    _sum?: PromotionSumAggregateInputType
    _min?: PromotionMinAggregateInputType
    _max?: PromotionMaxAggregateInputType
  }

  export type PromotionGroupByOutputType = {
    id: number
    uuid: string
    name: string
    description: string | null
    status: string
    discountRate: number
    startDate: Date
    endDate: Date
    categoryId: number
    enterpriseId: number
    deletedAt: Date | null
    _count: PromotionCountAggregateOutputType | null
    _avg: PromotionAvgAggregateOutputType | null
    _sum: PromotionSumAggregateOutputType | null
    _min: PromotionMinAggregateOutputType | null
    _max: PromotionMaxAggregateOutputType | null
  }

  type GetPromotionGroupByPayload<T extends PromotionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PromotionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PromotionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PromotionGroupByOutputType[P]>
            : GetScalarType<T[P], PromotionGroupByOutputType[P]>
        }
      >
    >


  export type PromotionSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    discountRate?: boolean
    startDate?: boolean
    endDate?: boolean
    categoryId?: boolean
    enterpriseId?: boolean
    deletedAt?: boolean
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    enterprise?: boolean | EnterpriseDefaultArgs<ExtArgs>
    promotionTags?: boolean | Promotion$promotionTagsArgs<ExtArgs>
    _count?: boolean | PromotionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["promotion"]>

  export type PromotionSelectScalar = {
    id?: boolean
    uuid?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    discountRate?: boolean
    startDate?: boolean
    endDate?: boolean
    categoryId?: boolean
    enterpriseId?: boolean
    deletedAt?: boolean
  }

  export type PromotionInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    enterprise?: boolean | EnterpriseDefaultArgs<ExtArgs>
    promotionTags?: boolean | Promotion$promotionTagsArgs<ExtArgs>
    _count?: boolean | PromotionCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $PromotionPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "Promotion"
    objects: {
      category: Prisma.$CategoryPayload<ExtArgs>
      enterprise: Prisma.$EnterprisePayload<ExtArgs>
      promotionTags: Prisma.$PromotionTagPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetResult<{
      id: number
      uuid: string
      name: string
      description: string | null
      status: string
      discountRate: number
      startDate: Date
      endDate: Date
      categoryId: number
      enterpriseId: number
      deletedAt: Date | null
    }, ExtArgs["result"]["promotion"]>
    composites: {}
  }


  type PromotionGetPayload<S extends boolean | null | undefined | PromotionDefaultArgs> = $Result.GetResult<Prisma.$PromotionPayload, S>

  type PromotionCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<PromotionFindManyArgs, 'select' | 'include'> & {
      select?: PromotionCountAggregateInputType | true
    }

  export interface PromotionDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Promotion'], meta: { name: 'Promotion' } }
    /**
     * Find zero or one Promotion that matches the filter.
     * @param {PromotionFindUniqueArgs} args - Arguments to find a Promotion
     * @example
     * // Get one Promotion
     * const promotion = await prisma.promotion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PromotionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PromotionFindUniqueArgs<ExtArgs>>
    ): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Promotion that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PromotionFindUniqueOrThrowArgs} args - Arguments to find a Promotion
     * @example
     * // Get one Promotion
     * const promotion = await prisma.promotion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PromotionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PromotionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Promotion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionFindFirstArgs} args - Arguments to find a Promotion
     * @example
     * // Get one Promotion
     * const promotion = await prisma.promotion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PromotionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PromotionFindFirstArgs<ExtArgs>>
    ): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Promotion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionFindFirstOrThrowArgs} args - Arguments to find a Promotion
     * @example
     * // Get one Promotion
     * const promotion = await prisma.promotion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PromotionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PromotionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Promotions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Promotions
     * const promotions = await prisma.promotion.findMany()
     * 
     * // Get first 10 Promotions
     * const promotions = await prisma.promotion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const promotionWithIdOnly = await prisma.promotion.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PromotionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PromotionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Promotion.
     * @param {PromotionCreateArgs} args - Arguments to create a Promotion.
     * @example
     * // Create one Promotion
     * const Promotion = await prisma.promotion.create({
     *   data: {
     *     // ... data to create a Promotion
     *   }
     * })
     * 
    **/
    create<T extends PromotionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PromotionCreateArgs<ExtArgs>>
    ): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Promotions.
     *     @param {PromotionCreateManyArgs} args - Arguments to create many Promotions.
     *     @example
     *     // Create many Promotions
     *     const promotion = await prisma.promotion.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PromotionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PromotionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Promotion.
     * @param {PromotionDeleteArgs} args - Arguments to delete one Promotion.
     * @example
     * // Delete one Promotion
     * const Promotion = await prisma.promotion.delete({
     *   where: {
     *     // ... filter to delete one Promotion
     *   }
     * })
     * 
    **/
    delete<T extends PromotionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PromotionDeleteArgs<ExtArgs>>
    ): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Promotion.
     * @param {PromotionUpdateArgs} args - Arguments to update one Promotion.
     * @example
     * // Update one Promotion
     * const promotion = await prisma.promotion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PromotionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PromotionUpdateArgs<ExtArgs>>
    ): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Promotions.
     * @param {PromotionDeleteManyArgs} args - Arguments to filter Promotions to delete.
     * @example
     * // Delete a few Promotions
     * const { count } = await prisma.promotion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PromotionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PromotionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Promotions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Promotions
     * const promotion = await prisma.promotion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PromotionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PromotionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Promotion.
     * @param {PromotionUpsertArgs} args - Arguments to update or create a Promotion.
     * @example
     * // Update or create a Promotion
     * const promotion = await prisma.promotion.upsert({
     *   create: {
     *     // ... data to create a Promotion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Promotion we want to update
     *   }
     * })
    **/
    upsert<T extends PromotionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PromotionUpsertArgs<ExtArgs>>
    ): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Promotions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionCountArgs} args - Arguments to filter Promotions to count.
     * @example
     * // Count the number of Promotions
     * const count = await prisma.promotion.count({
     *   where: {
     *     // ... the filter for the Promotions we want to count
     *   }
     * })
    **/
    count<T extends PromotionCountArgs>(
      args?: Subset<T, PromotionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PromotionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Promotion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PromotionAggregateArgs>(args: Subset<T, PromotionAggregateArgs>): Prisma.PrismaPromise<GetPromotionAggregateType<T>>

    /**
     * Group by Promotion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PromotionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PromotionGroupByArgs['orderBy'] }
        : { orderBy?: PromotionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PromotionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPromotionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Promotion model
   */
  readonly fields: PromotionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Promotion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PromotionClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    category<T extends CategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CategoryDefaultArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    enterprise<T extends EnterpriseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EnterpriseDefaultArgs<ExtArgs>>): Prisma__EnterpriseClient<$Result.GetResult<Prisma.$EnterprisePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    promotionTags<T extends Promotion$promotionTagsArgs<ExtArgs> = {}>(args?: Subset<T, Promotion$promotionTagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromotionTagPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Promotion model
   */ 
  interface PromotionFieldRefs {
    readonly id: FieldRef<"Promotion", 'Int'>
    readonly uuid: FieldRef<"Promotion", 'String'>
    readonly name: FieldRef<"Promotion", 'String'>
    readonly description: FieldRef<"Promotion", 'String'>
    readonly status: FieldRef<"Promotion", 'String'>
    readonly discountRate: FieldRef<"Promotion", 'Float'>
    readonly startDate: FieldRef<"Promotion", 'DateTime'>
    readonly endDate: FieldRef<"Promotion", 'DateTime'>
    readonly categoryId: FieldRef<"Promotion", 'Int'>
    readonly enterpriseId: FieldRef<"Promotion", 'Int'>
    readonly deletedAt: FieldRef<"Promotion", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Promotion findUnique
   */
  export type PromotionFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * Filter, which Promotion to fetch.
     */
    where: PromotionWhereUniqueInput
  }


  /**
   * Promotion findUniqueOrThrow
   */
  export type PromotionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * Filter, which Promotion to fetch.
     */
    where: PromotionWhereUniqueInput
  }


  /**
   * Promotion findFirst
   */
  export type PromotionFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * Filter, which Promotion to fetch.
     */
    where?: PromotionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Promotions to fetch.
     */
    orderBy?: PromotionOrderByWithRelationInput | PromotionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Promotions.
     */
    cursor?: PromotionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Promotions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Promotions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Promotions.
     */
    distinct?: PromotionScalarFieldEnum | PromotionScalarFieldEnum[]
  }


  /**
   * Promotion findFirstOrThrow
   */
  export type PromotionFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * Filter, which Promotion to fetch.
     */
    where?: PromotionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Promotions to fetch.
     */
    orderBy?: PromotionOrderByWithRelationInput | PromotionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Promotions.
     */
    cursor?: PromotionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Promotions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Promotions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Promotions.
     */
    distinct?: PromotionScalarFieldEnum | PromotionScalarFieldEnum[]
  }


  /**
   * Promotion findMany
   */
  export type PromotionFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * Filter, which Promotions to fetch.
     */
    where?: PromotionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Promotions to fetch.
     */
    orderBy?: PromotionOrderByWithRelationInput | PromotionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Promotions.
     */
    cursor?: PromotionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Promotions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Promotions.
     */
    skip?: number
    distinct?: PromotionScalarFieldEnum | PromotionScalarFieldEnum[]
  }


  /**
   * Promotion create
   */
  export type PromotionCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * The data needed to create a Promotion.
     */
    data: XOR<PromotionCreateInput, PromotionUncheckedCreateInput>
  }


  /**
   * Promotion createMany
   */
  export type PromotionCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Promotions.
     */
    data: PromotionCreateManyInput | PromotionCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Promotion update
   */
  export type PromotionUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * The data needed to update a Promotion.
     */
    data: XOR<PromotionUpdateInput, PromotionUncheckedUpdateInput>
    /**
     * Choose, which Promotion to update.
     */
    where: PromotionWhereUniqueInput
  }


  /**
   * Promotion updateMany
   */
  export type PromotionUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Promotions.
     */
    data: XOR<PromotionUpdateManyMutationInput, PromotionUncheckedUpdateManyInput>
    /**
     * Filter which Promotions to update
     */
    where?: PromotionWhereInput
  }


  /**
   * Promotion upsert
   */
  export type PromotionUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * The filter to search for the Promotion to update in case it exists.
     */
    where: PromotionWhereUniqueInput
    /**
     * In case the Promotion found by the `where` argument doesn't exist, create a new Promotion with this data.
     */
    create: XOR<PromotionCreateInput, PromotionUncheckedCreateInput>
    /**
     * In case the Promotion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PromotionUpdateInput, PromotionUncheckedUpdateInput>
  }


  /**
   * Promotion delete
   */
  export type PromotionDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * Filter which Promotion to delete.
     */
    where: PromotionWhereUniqueInput
  }


  /**
   * Promotion deleteMany
   */
  export type PromotionDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Promotions to delete
     */
    where?: PromotionWhereInput
  }


  /**
   * Promotion.promotionTags
   */
  export type Promotion$promotionTagsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionTag
     */
    select?: PromotionTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PromotionTagInclude<ExtArgs> | null
    where?: PromotionTagWhereInput
    orderBy?: PromotionTagOrderByWithRelationInput | PromotionTagOrderByWithRelationInput[]
    cursor?: PromotionTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PromotionTagScalarFieldEnum | PromotionTagScalarFieldEnum[]
  }


  /**
   * Promotion without action
   */
  export type PromotionDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PromotionInclude<ExtArgs> | null
  }



  /**
   * Model Combo
   */

  export type AggregateCombo = {
    _count: ComboCountAggregateOutputType | null
    _avg: ComboAvgAggregateOutputType | null
    _sum: ComboSumAggregateOutputType | null
    _min: ComboMinAggregateOutputType | null
    _max: ComboMaxAggregateOutputType | null
  }

  export type ComboAvgAggregateOutputType = {
    id: number | null
    price: number | null
    categoryId: number | null
    enterpriseId: number | null
    productId: number | null
  }

  export type ComboSumAggregateOutputType = {
    id: number | null
    price: number | null
    categoryId: number | null
    enterpriseId: number | null
    productId: number | null
  }

  export type ComboMinAggregateOutputType = {
    id: number | null
    uuid: string | null
    name: string | null
    description: string | null
    price: number | null
    status: string | null
    categoryId: number | null
    enterpriseId: number | null
    productId: number | null
  }

  export type ComboMaxAggregateOutputType = {
    id: number | null
    uuid: string | null
    name: string | null
    description: string | null
    price: number | null
    status: string | null
    categoryId: number | null
    enterpriseId: number | null
    productId: number | null
  }

  export type ComboCountAggregateOutputType = {
    id: number
    uuid: number
    name: number
    description: number
    price: number
    status: number
    categoryId: number
    enterpriseId: number
    productId: number
    _all: number
  }


  export type ComboAvgAggregateInputType = {
    id?: true
    price?: true
    categoryId?: true
    enterpriseId?: true
    productId?: true
  }

  export type ComboSumAggregateInputType = {
    id?: true
    price?: true
    categoryId?: true
    enterpriseId?: true
    productId?: true
  }

  export type ComboMinAggregateInputType = {
    id?: true
    uuid?: true
    name?: true
    description?: true
    price?: true
    status?: true
    categoryId?: true
    enterpriseId?: true
    productId?: true
  }

  export type ComboMaxAggregateInputType = {
    id?: true
    uuid?: true
    name?: true
    description?: true
    price?: true
    status?: true
    categoryId?: true
    enterpriseId?: true
    productId?: true
  }

  export type ComboCountAggregateInputType = {
    id?: true
    uuid?: true
    name?: true
    description?: true
    price?: true
    status?: true
    categoryId?: true
    enterpriseId?: true
    productId?: true
    _all?: true
  }

  export type ComboAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Combo to aggregate.
     */
    where?: ComboWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Combos to fetch.
     */
    orderBy?: ComboOrderByWithRelationInput | ComboOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ComboWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Combos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Combos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Combos
    **/
    _count?: true | ComboCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ComboAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ComboSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ComboMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ComboMaxAggregateInputType
  }

  export type GetComboAggregateType<T extends ComboAggregateArgs> = {
        [P in keyof T & keyof AggregateCombo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCombo[P]>
      : GetScalarType<T[P], AggregateCombo[P]>
  }




  export type ComboGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ComboWhereInput
    orderBy?: ComboOrderByWithAggregationInput | ComboOrderByWithAggregationInput[]
    by: ComboScalarFieldEnum[] | ComboScalarFieldEnum
    having?: ComboScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ComboCountAggregateInputType | true
    _avg?: ComboAvgAggregateInputType
    _sum?: ComboSumAggregateInputType
    _min?: ComboMinAggregateInputType
    _max?: ComboMaxAggregateInputType
  }

  export type ComboGroupByOutputType = {
    id: number
    uuid: string
    name: string
    description: string | null
    price: number
    status: string
    categoryId: number
    enterpriseId: number
    productId: number | null
    _count: ComboCountAggregateOutputType | null
    _avg: ComboAvgAggregateOutputType | null
    _sum: ComboSumAggregateOutputType | null
    _min: ComboMinAggregateOutputType | null
    _max: ComboMaxAggregateOutputType | null
  }

  type GetComboGroupByPayload<T extends ComboGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ComboGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ComboGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComboGroupByOutputType[P]>
            : GetScalarType<T[P], ComboGroupByOutputType[P]>
        }
      >
    >


  export type ComboSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    status?: boolean
    categoryId?: boolean
    enterpriseId?: boolean
    productId?: boolean
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    enterprise?: boolean | EnterpriseDefaultArgs<ExtArgs>
    products?: boolean | Combo$productsArgs<ExtArgs>
    ComboProducts?: boolean | Combo$ComboProductsArgs<ExtArgs>
    Product?: boolean | Combo$ProductArgs<ExtArgs>
    _count?: boolean | ComboCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["combo"]>

  export type ComboSelectScalar = {
    id?: boolean
    uuid?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    status?: boolean
    categoryId?: boolean
    enterpriseId?: boolean
    productId?: boolean
  }

  export type ComboInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    enterprise?: boolean | EnterpriseDefaultArgs<ExtArgs>
    products?: boolean | Combo$productsArgs<ExtArgs>
    ComboProducts?: boolean | Combo$ComboProductsArgs<ExtArgs>
    Product?: boolean | Combo$ProductArgs<ExtArgs>
    _count?: boolean | ComboCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ComboPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "Combo"
    objects: {
      category: Prisma.$CategoryPayload<ExtArgs>
      enterprise: Prisma.$EnterprisePayload<ExtArgs>
      products: Prisma.$ProductPayload<ExtArgs>[]
      ComboProducts: Prisma.$ComboProductsPayload<ExtArgs>[]
      Product: Prisma.$ProductPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetResult<{
      id: number
      uuid: string
      name: string
      description: string | null
      price: number
      status: string
      categoryId: number
      enterpriseId: number
      productId: number | null
    }, ExtArgs["result"]["combo"]>
    composites: {}
  }


  type ComboGetPayload<S extends boolean | null | undefined | ComboDefaultArgs> = $Result.GetResult<Prisma.$ComboPayload, S>

  type ComboCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ComboFindManyArgs, 'select' | 'include'> & {
      select?: ComboCountAggregateInputType | true
    }

  export interface ComboDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Combo'], meta: { name: 'Combo' } }
    /**
     * Find zero or one Combo that matches the filter.
     * @param {ComboFindUniqueArgs} args - Arguments to find a Combo
     * @example
     * // Get one Combo
     * const combo = await prisma.combo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ComboFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ComboFindUniqueArgs<ExtArgs>>
    ): Prisma__ComboClient<$Result.GetResult<Prisma.$ComboPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Combo that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ComboFindUniqueOrThrowArgs} args - Arguments to find a Combo
     * @example
     * // Get one Combo
     * const combo = await prisma.combo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ComboFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ComboFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ComboClient<$Result.GetResult<Prisma.$ComboPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Combo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComboFindFirstArgs} args - Arguments to find a Combo
     * @example
     * // Get one Combo
     * const combo = await prisma.combo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ComboFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ComboFindFirstArgs<ExtArgs>>
    ): Prisma__ComboClient<$Result.GetResult<Prisma.$ComboPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Combo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComboFindFirstOrThrowArgs} args - Arguments to find a Combo
     * @example
     * // Get one Combo
     * const combo = await prisma.combo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ComboFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ComboFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ComboClient<$Result.GetResult<Prisma.$ComboPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Combos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComboFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Combos
     * const combos = await prisma.combo.findMany()
     * 
     * // Get first 10 Combos
     * const combos = await prisma.combo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const comboWithIdOnly = await prisma.combo.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ComboFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ComboFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComboPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Combo.
     * @param {ComboCreateArgs} args - Arguments to create a Combo.
     * @example
     * // Create one Combo
     * const Combo = await prisma.combo.create({
     *   data: {
     *     // ... data to create a Combo
     *   }
     * })
     * 
    **/
    create<T extends ComboCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ComboCreateArgs<ExtArgs>>
    ): Prisma__ComboClient<$Result.GetResult<Prisma.$ComboPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Combos.
     *     @param {ComboCreateManyArgs} args - Arguments to create many Combos.
     *     @example
     *     // Create many Combos
     *     const combo = await prisma.combo.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ComboCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ComboCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Combo.
     * @param {ComboDeleteArgs} args - Arguments to delete one Combo.
     * @example
     * // Delete one Combo
     * const Combo = await prisma.combo.delete({
     *   where: {
     *     // ... filter to delete one Combo
     *   }
     * })
     * 
    **/
    delete<T extends ComboDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ComboDeleteArgs<ExtArgs>>
    ): Prisma__ComboClient<$Result.GetResult<Prisma.$ComboPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Combo.
     * @param {ComboUpdateArgs} args - Arguments to update one Combo.
     * @example
     * // Update one Combo
     * const combo = await prisma.combo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ComboUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ComboUpdateArgs<ExtArgs>>
    ): Prisma__ComboClient<$Result.GetResult<Prisma.$ComboPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Combos.
     * @param {ComboDeleteManyArgs} args - Arguments to filter Combos to delete.
     * @example
     * // Delete a few Combos
     * const { count } = await prisma.combo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ComboDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ComboDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Combos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComboUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Combos
     * const combo = await prisma.combo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ComboUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ComboUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Combo.
     * @param {ComboUpsertArgs} args - Arguments to update or create a Combo.
     * @example
     * // Update or create a Combo
     * const combo = await prisma.combo.upsert({
     *   create: {
     *     // ... data to create a Combo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Combo we want to update
     *   }
     * })
    **/
    upsert<T extends ComboUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ComboUpsertArgs<ExtArgs>>
    ): Prisma__ComboClient<$Result.GetResult<Prisma.$ComboPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Combos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComboCountArgs} args - Arguments to filter Combos to count.
     * @example
     * // Count the number of Combos
     * const count = await prisma.combo.count({
     *   where: {
     *     // ... the filter for the Combos we want to count
     *   }
     * })
    **/
    count<T extends ComboCountArgs>(
      args?: Subset<T, ComboCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComboCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Combo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComboAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ComboAggregateArgs>(args: Subset<T, ComboAggregateArgs>): Prisma.PrismaPromise<GetComboAggregateType<T>>

    /**
     * Group by Combo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComboGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ComboGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ComboGroupByArgs['orderBy'] }
        : { orderBy?: ComboGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ComboGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComboGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Combo model
   */
  readonly fields: ComboFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Combo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ComboClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    category<T extends CategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CategoryDefaultArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    enterprise<T extends EnterpriseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EnterpriseDefaultArgs<ExtArgs>>): Prisma__EnterpriseClient<$Result.GetResult<Prisma.$EnterprisePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    products<T extends Combo$productsArgs<ExtArgs> = {}>(args?: Subset<T, Combo$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findMany'> | Null>;

    ComboProducts<T extends Combo$ComboProductsArgs<ExtArgs> = {}>(args?: Subset<T, Combo$ComboProductsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComboProductsPayload<ExtArgs>, T, 'findMany'> | Null>;

    Product<T extends Combo$ProductArgs<ExtArgs> = {}>(args?: Subset<T, Combo$ProductArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Combo model
   */ 
  interface ComboFieldRefs {
    readonly id: FieldRef<"Combo", 'Int'>
    readonly uuid: FieldRef<"Combo", 'String'>
    readonly name: FieldRef<"Combo", 'String'>
    readonly description: FieldRef<"Combo", 'String'>
    readonly price: FieldRef<"Combo", 'Float'>
    readonly status: FieldRef<"Combo", 'String'>
    readonly categoryId: FieldRef<"Combo", 'Int'>
    readonly enterpriseId: FieldRef<"Combo", 'Int'>
    readonly productId: FieldRef<"Combo", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Combo findUnique
   */
  export type ComboFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Combo
     */
    select?: ComboSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ComboInclude<ExtArgs> | null
    /**
     * Filter, which Combo to fetch.
     */
    where: ComboWhereUniqueInput
  }


  /**
   * Combo findUniqueOrThrow
   */
  export type ComboFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Combo
     */
    select?: ComboSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ComboInclude<ExtArgs> | null
    /**
     * Filter, which Combo to fetch.
     */
    where: ComboWhereUniqueInput
  }


  /**
   * Combo findFirst
   */
  export type ComboFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Combo
     */
    select?: ComboSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ComboInclude<ExtArgs> | null
    /**
     * Filter, which Combo to fetch.
     */
    where?: ComboWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Combos to fetch.
     */
    orderBy?: ComboOrderByWithRelationInput | ComboOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Combos.
     */
    cursor?: ComboWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Combos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Combos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Combos.
     */
    distinct?: ComboScalarFieldEnum | ComboScalarFieldEnum[]
  }


  /**
   * Combo findFirstOrThrow
   */
  export type ComboFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Combo
     */
    select?: ComboSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ComboInclude<ExtArgs> | null
    /**
     * Filter, which Combo to fetch.
     */
    where?: ComboWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Combos to fetch.
     */
    orderBy?: ComboOrderByWithRelationInput | ComboOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Combos.
     */
    cursor?: ComboWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Combos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Combos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Combos.
     */
    distinct?: ComboScalarFieldEnum | ComboScalarFieldEnum[]
  }


  /**
   * Combo findMany
   */
  export type ComboFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Combo
     */
    select?: ComboSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ComboInclude<ExtArgs> | null
    /**
     * Filter, which Combos to fetch.
     */
    where?: ComboWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Combos to fetch.
     */
    orderBy?: ComboOrderByWithRelationInput | ComboOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Combos.
     */
    cursor?: ComboWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Combos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Combos.
     */
    skip?: number
    distinct?: ComboScalarFieldEnum | ComboScalarFieldEnum[]
  }


  /**
   * Combo create
   */
  export type ComboCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Combo
     */
    select?: ComboSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ComboInclude<ExtArgs> | null
    /**
     * The data needed to create a Combo.
     */
    data: XOR<ComboCreateInput, ComboUncheckedCreateInput>
  }


  /**
   * Combo createMany
   */
  export type ComboCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Combos.
     */
    data: ComboCreateManyInput | ComboCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Combo update
   */
  export type ComboUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Combo
     */
    select?: ComboSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ComboInclude<ExtArgs> | null
    /**
     * The data needed to update a Combo.
     */
    data: XOR<ComboUpdateInput, ComboUncheckedUpdateInput>
    /**
     * Choose, which Combo to update.
     */
    where: ComboWhereUniqueInput
  }


  /**
   * Combo updateMany
   */
  export type ComboUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Combos.
     */
    data: XOR<ComboUpdateManyMutationInput, ComboUncheckedUpdateManyInput>
    /**
     * Filter which Combos to update
     */
    where?: ComboWhereInput
  }


  /**
   * Combo upsert
   */
  export type ComboUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Combo
     */
    select?: ComboSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ComboInclude<ExtArgs> | null
    /**
     * The filter to search for the Combo to update in case it exists.
     */
    where: ComboWhereUniqueInput
    /**
     * In case the Combo found by the `where` argument doesn't exist, create a new Combo with this data.
     */
    create: XOR<ComboCreateInput, ComboUncheckedCreateInput>
    /**
     * In case the Combo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ComboUpdateInput, ComboUncheckedUpdateInput>
  }


  /**
   * Combo delete
   */
  export type ComboDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Combo
     */
    select?: ComboSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ComboInclude<ExtArgs> | null
    /**
     * Filter which Combo to delete.
     */
    where: ComboWhereUniqueInput
  }


  /**
   * Combo deleteMany
   */
  export type ComboDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Combos to delete
     */
    where?: ComboWhereInput
  }


  /**
   * Combo.products
   */
  export type Combo$productsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }


  /**
   * Combo.ComboProducts
   */
  export type Combo$ComboProductsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComboProducts
     */
    select?: ComboProductsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ComboProductsInclude<ExtArgs> | null
    where?: ComboProductsWhereInput
    orderBy?: ComboProductsOrderByWithRelationInput | ComboProductsOrderByWithRelationInput[]
    cursor?: ComboProductsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComboProductsScalarFieldEnum | ComboProductsScalarFieldEnum[]
  }


  /**
   * Combo.Product
   */
  export type Combo$ProductArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
  }


  /**
   * Combo without action
   */
  export type ComboDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Combo
     */
    select?: ComboSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ComboInclude<ExtArgs> | null
  }



  /**
   * Model ComboProducts
   */

  export type AggregateComboProducts = {
    _count: ComboProductsCountAggregateOutputType | null
    _avg: ComboProductsAvgAggregateOutputType | null
    _sum: ComboProductsSumAggregateOutputType | null
    _min: ComboProductsMinAggregateOutputType | null
    _max: ComboProductsMaxAggregateOutputType | null
  }

  export type ComboProductsAvgAggregateOutputType = {
    id: number | null
    comboId: number | null
    productId: number | null
  }

  export type ComboProductsSumAggregateOutputType = {
    id: number | null
    comboId: number | null
    productId: number | null
  }

  export type ComboProductsMinAggregateOutputType = {
    id: number | null
    uuid: string | null
    comboId: number | null
    productId: number | null
  }

  export type ComboProductsMaxAggregateOutputType = {
    id: number | null
    uuid: string | null
    comboId: number | null
    productId: number | null
  }

  export type ComboProductsCountAggregateOutputType = {
    id: number
    uuid: number
    comboId: number
    productId: number
    _all: number
  }


  export type ComboProductsAvgAggregateInputType = {
    id?: true
    comboId?: true
    productId?: true
  }

  export type ComboProductsSumAggregateInputType = {
    id?: true
    comboId?: true
    productId?: true
  }

  export type ComboProductsMinAggregateInputType = {
    id?: true
    uuid?: true
    comboId?: true
    productId?: true
  }

  export type ComboProductsMaxAggregateInputType = {
    id?: true
    uuid?: true
    comboId?: true
    productId?: true
  }

  export type ComboProductsCountAggregateInputType = {
    id?: true
    uuid?: true
    comboId?: true
    productId?: true
    _all?: true
  }

  export type ComboProductsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ComboProducts to aggregate.
     */
    where?: ComboProductsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComboProducts to fetch.
     */
    orderBy?: ComboProductsOrderByWithRelationInput | ComboProductsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ComboProductsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComboProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComboProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ComboProducts
    **/
    _count?: true | ComboProductsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ComboProductsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ComboProductsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ComboProductsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ComboProductsMaxAggregateInputType
  }

  export type GetComboProductsAggregateType<T extends ComboProductsAggregateArgs> = {
        [P in keyof T & keyof AggregateComboProducts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComboProducts[P]>
      : GetScalarType<T[P], AggregateComboProducts[P]>
  }




  export type ComboProductsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ComboProductsWhereInput
    orderBy?: ComboProductsOrderByWithAggregationInput | ComboProductsOrderByWithAggregationInput[]
    by: ComboProductsScalarFieldEnum[] | ComboProductsScalarFieldEnum
    having?: ComboProductsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ComboProductsCountAggregateInputType | true
    _avg?: ComboProductsAvgAggregateInputType
    _sum?: ComboProductsSumAggregateInputType
    _min?: ComboProductsMinAggregateInputType
    _max?: ComboProductsMaxAggregateInputType
  }

  export type ComboProductsGroupByOutputType = {
    id: number
    uuid: string
    comboId: number
    productId: number
    _count: ComboProductsCountAggregateOutputType | null
    _avg: ComboProductsAvgAggregateOutputType | null
    _sum: ComboProductsSumAggregateOutputType | null
    _min: ComboProductsMinAggregateOutputType | null
    _max: ComboProductsMaxAggregateOutputType | null
  }

  type GetComboProductsGroupByPayload<T extends ComboProductsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ComboProductsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ComboProductsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComboProductsGroupByOutputType[P]>
            : GetScalarType<T[P], ComboProductsGroupByOutputType[P]>
        }
      >
    >


  export type ComboProductsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    comboId?: boolean
    productId?: boolean
    combo?: boolean | ComboDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comboProducts"]>

  export type ComboProductsSelectScalar = {
    id?: boolean
    uuid?: boolean
    comboId?: boolean
    productId?: boolean
  }

  export type ComboProductsInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    combo?: boolean | ComboDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }


  export type $ComboProductsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "ComboProducts"
    objects: {
      combo: Prisma.$ComboPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetResult<{
      id: number
      uuid: string
      comboId: number
      productId: number
    }, ExtArgs["result"]["comboProducts"]>
    composites: {}
  }


  type ComboProductsGetPayload<S extends boolean | null | undefined | ComboProductsDefaultArgs> = $Result.GetResult<Prisma.$ComboProductsPayload, S>

  type ComboProductsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ComboProductsFindManyArgs, 'select' | 'include'> & {
      select?: ComboProductsCountAggregateInputType | true
    }

  export interface ComboProductsDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ComboProducts'], meta: { name: 'ComboProducts' } }
    /**
     * Find zero or one ComboProducts that matches the filter.
     * @param {ComboProductsFindUniqueArgs} args - Arguments to find a ComboProducts
     * @example
     * // Get one ComboProducts
     * const comboProducts = await prisma.comboProducts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ComboProductsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ComboProductsFindUniqueArgs<ExtArgs>>
    ): Prisma__ComboProductsClient<$Result.GetResult<Prisma.$ComboProductsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ComboProducts that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ComboProductsFindUniqueOrThrowArgs} args - Arguments to find a ComboProducts
     * @example
     * // Get one ComboProducts
     * const comboProducts = await prisma.comboProducts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ComboProductsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ComboProductsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ComboProductsClient<$Result.GetResult<Prisma.$ComboProductsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ComboProducts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComboProductsFindFirstArgs} args - Arguments to find a ComboProducts
     * @example
     * // Get one ComboProducts
     * const comboProducts = await prisma.comboProducts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ComboProductsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ComboProductsFindFirstArgs<ExtArgs>>
    ): Prisma__ComboProductsClient<$Result.GetResult<Prisma.$ComboProductsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ComboProducts that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComboProductsFindFirstOrThrowArgs} args - Arguments to find a ComboProducts
     * @example
     * // Get one ComboProducts
     * const comboProducts = await prisma.comboProducts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ComboProductsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ComboProductsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ComboProductsClient<$Result.GetResult<Prisma.$ComboProductsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ComboProducts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComboProductsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ComboProducts
     * const comboProducts = await prisma.comboProducts.findMany()
     * 
     * // Get first 10 ComboProducts
     * const comboProducts = await prisma.comboProducts.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const comboProductsWithIdOnly = await prisma.comboProducts.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ComboProductsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ComboProductsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComboProductsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ComboProducts.
     * @param {ComboProductsCreateArgs} args - Arguments to create a ComboProducts.
     * @example
     * // Create one ComboProducts
     * const ComboProducts = await prisma.comboProducts.create({
     *   data: {
     *     // ... data to create a ComboProducts
     *   }
     * })
     * 
    **/
    create<T extends ComboProductsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ComboProductsCreateArgs<ExtArgs>>
    ): Prisma__ComboProductsClient<$Result.GetResult<Prisma.$ComboProductsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ComboProducts.
     *     @param {ComboProductsCreateManyArgs} args - Arguments to create many ComboProducts.
     *     @example
     *     // Create many ComboProducts
     *     const comboProducts = await prisma.comboProducts.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ComboProductsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ComboProductsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ComboProducts.
     * @param {ComboProductsDeleteArgs} args - Arguments to delete one ComboProducts.
     * @example
     * // Delete one ComboProducts
     * const ComboProducts = await prisma.comboProducts.delete({
     *   where: {
     *     // ... filter to delete one ComboProducts
     *   }
     * })
     * 
    **/
    delete<T extends ComboProductsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ComboProductsDeleteArgs<ExtArgs>>
    ): Prisma__ComboProductsClient<$Result.GetResult<Prisma.$ComboProductsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ComboProducts.
     * @param {ComboProductsUpdateArgs} args - Arguments to update one ComboProducts.
     * @example
     * // Update one ComboProducts
     * const comboProducts = await prisma.comboProducts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ComboProductsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ComboProductsUpdateArgs<ExtArgs>>
    ): Prisma__ComboProductsClient<$Result.GetResult<Prisma.$ComboProductsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ComboProducts.
     * @param {ComboProductsDeleteManyArgs} args - Arguments to filter ComboProducts to delete.
     * @example
     * // Delete a few ComboProducts
     * const { count } = await prisma.comboProducts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ComboProductsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ComboProductsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ComboProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComboProductsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ComboProducts
     * const comboProducts = await prisma.comboProducts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ComboProductsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ComboProductsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ComboProducts.
     * @param {ComboProductsUpsertArgs} args - Arguments to update or create a ComboProducts.
     * @example
     * // Update or create a ComboProducts
     * const comboProducts = await prisma.comboProducts.upsert({
     *   create: {
     *     // ... data to create a ComboProducts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ComboProducts we want to update
     *   }
     * })
    **/
    upsert<T extends ComboProductsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ComboProductsUpsertArgs<ExtArgs>>
    ): Prisma__ComboProductsClient<$Result.GetResult<Prisma.$ComboProductsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ComboProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComboProductsCountArgs} args - Arguments to filter ComboProducts to count.
     * @example
     * // Count the number of ComboProducts
     * const count = await prisma.comboProducts.count({
     *   where: {
     *     // ... the filter for the ComboProducts we want to count
     *   }
     * })
    **/
    count<T extends ComboProductsCountArgs>(
      args?: Subset<T, ComboProductsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComboProductsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ComboProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComboProductsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ComboProductsAggregateArgs>(args: Subset<T, ComboProductsAggregateArgs>): Prisma.PrismaPromise<GetComboProductsAggregateType<T>>

    /**
     * Group by ComboProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComboProductsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ComboProductsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ComboProductsGroupByArgs['orderBy'] }
        : { orderBy?: ComboProductsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ComboProductsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComboProductsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ComboProducts model
   */
  readonly fields: ComboProductsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ComboProducts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ComboProductsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    combo<T extends ComboDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ComboDefaultArgs<ExtArgs>>): Prisma__ComboClient<$Result.GetResult<Prisma.$ComboPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ComboProducts model
   */ 
  interface ComboProductsFieldRefs {
    readonly id: FieldRef<"ComboProducts", 'Int'>
    readonly uuid: FieldRef<"ComboProducts", 'String'>
    readonly comboId: FieldRef<"ComboProducts", 'Int'>
    readonly productId: FieldRef<"ComboProducts", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * ComboProducts findUnique
   */
  export type ComboProductsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComboProducts
     */
    select?: ComboProductsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ComboProductsInclude<ExtArgs> | null
    /**
     * Filter, which ComboProducts to fetch.
     */
    where: ComboProductsWhereUniqueInput
  }


  /**
   * ComboProducts findUniqueOrThrow
   */
  export type ComboProductsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComboProducts
     */
    select?: ComboProductsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ComboProductsInclude<ExtArgs> | null
    /**
     * Filter, which ComboProducts to fetch.
     */
    where: ComboProductsWhereUniqueInput
  }


  /**
   * ComboProducts findFirst
   */
  export type ComboProductsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComboProducts
     */
    select?: ComboProductsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ComboProductsInclude<ExtArgs> | null
    /**
     * Filter, which ComboProducts to fetch.
     */
    where?: ComboProductsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComboProducts to fetch.
     */
    orderBy?: ComboProductsOrderByWithRelationInput | ComboProductsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ComboProducts.
     */
    cursor?: ComboProductsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComboProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComboProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ComboProducts.
     */
    distinct?: ComboProductsScalarFieldEnum | ComboProductsScalarFieldEnum[]
  }


  /**
   * ComboProducts findFirstOrThrow
   */
  export type ComboProductsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComboProducts
     */
    select?: ComboProductsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ComboProductsInclude<ExtArgs> | null
    /**
     * Filter, which ComboProducts to fetch.
     */
    where?: ComboProductsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComboProducts to fetch.
     */
    orderBy?: ComboProductsOrderByWithRelationInput | ComboProductsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ComboProducts.
     */
    cursor?: ComboProductsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComboProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComboProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ComboProducts.
     */
    distinct?: ComboProductsScalarFieldEnum | ComboProductsScalarFieldEnum[]
  }


  /**
   * ComboProducts findMany
   */
  export type ComboProductsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComboProducts
     */
    select?: ComboProductsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ComboProductsInclude<ExtArgs> | null
    /**
     * Filter, which ComboProducts to fetch.
     */
    where?: ComboProductsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComboProducts to fetch.
     */
    orderBy?: ComboProductsOrderByWithRelationInput | ComboProductsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ComboProducts.
     */
    cursor?: ComboProductsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComboProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComboProducts.
     */
    skip?: number
    distinct?: ComboProductsScalarFieldEnum | ComboProductsScalarFieldEnum[]
  }


  /**
   * ComboProducts create
   */
  export type ComboProductsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComboProducts
     */
    select?: ComboProductsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ComboProductsInclude<ExtArgs> | null
    /**
     * The data needed to create a ComboProducts.
     */
    data: XOR<ComboProductsCreateInput, ComboProductsUncheckedCreateInput>
  }


  /**
   * ComboProducts createMany
   */
  export type ComboProductsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ComboProducts.
     */
    data: ComboProductsCreateManyInput | ComboProductsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ComboProducts update
   */
  export type ComboProductsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComboProducts
     */
    select?: ComboProductsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ComboProductsInclude<ExtArgs> | null
    /**
     * The data needed to update a ComboProducts.
     */
    data: XOR<ComboProductsUpdateInput, ComboProductsUncheckedUpdateInput>
    /**
     * Choose, which ComboProducts to update.
     */
    where: ComboProductsWhereUniqueInput
  }


  /**
   * ComboProducts updateMany
   */
  export type ComboProductsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ComboProducts.
     */
    data: XOR<ComboProductsUpdateManyMutationInput, ComboProductsUncheckedUpdateManyInput>
    /**
     * Filter which ComboProducts to update
     */
    where?: ComboProductsWhereInput
  }


  /**
   * ComboProducts upsert
   */
  export type ComboProductsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComboProducts
     */
    select?: ComboProductsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ComboProductsInclude<ExtArgs> | null
    /**
     * The filter to search for the ComboProducts to update in case it exists.
     */
    where: ComboProductsWhereUniqueInput
    /**
     * In case the ComboProducts found by the `where` argument doesn't exist, create a new ComboProducts with this data.
     */
    create: XOR<ComboProductsCreateInput, ComboProductsUncheckedCreateInput>
    /**
     * In case the ComboProducts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ComboProductsUpdateInput, ComboProductsUncheckedUpdateInput>
  }


  /**
   * ComboProducts delete
   */
  export type ComboProductsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComboProducts
     */
    select?: ComboProductsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ComboProductsInclude<ExtArgs> | null
    /**
     * Filter which ComboProducts to delete.
     */
    where: ComboProductsWhereUniqueInput
  }


  /**
   * ComboProducts deleteMany
   */
  export type ComboProductsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ComboProducts to delete
     */
    where?: ComboProductsWhereInput
  }


  /**
   * ComboProducts without action
   */
  export type ComboProductsDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComboProducts
     */
    select?: ComboProductsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ComboProductsInclude<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    email: 'email',
    nickname: 'nickname',
    role: 'role',
    firstName: 'firstName',
    lastName: 'lastName',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt',
    enterpriseId: 'enterpriseId'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    name: 'name',
    description: 'description',
    status: 'status',
    enterpriseId: 'enterpriseId'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    name: 'name',
    description: 'description',
    type: 'type',
    price: 'price',
    free: 'free',
    status: 'status',
    additionalsMax: 'additionalsMax',
    accompanimentsMax: 'accompanimentsMax',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt',
    categoryId: 'categoryId',
    enterpriseId: 'enterpriseId'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const AccompanimentScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    productId: 'productId'
  };

  export type AccompanimentScalarFieldEnum = (typeof AccompanimentScalarFieldEnum)[keyof typeof AccompanimentScalarFieldEnum]


  export const AdditionalScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    productId: 'productId'
  };

  export type AdditionalScalarFieldEnum = (typeof AdditionalScalarFieldEnum)[keyof typeof AdditionalScalarFieldEnum]


  export const OrderScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    totalPrice: 'totalPrice',
    status: 'status',
    updatedAt: 'updatedAt',
    orderDate: 'orderDate',
    userId: 'userId',
    enterpriseId: 'enterpriseId'
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


  export const OrderItemScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    quantity: 'quantity',
    price: 'price',
    productId: 'productId',
    orderId: 'orderId'
  };

  export type OrderItemScalarFieldEnum = (typeof OrderItemScalarFieldEnum)[keyof typeof OrderItemScalarFieldEnum]


  export const OrderHistoryScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    status: 'status',
    description: 'description',
    orderId: 'orderId',
    createdAt: 'createdAt'
  };

  export type OrderHistoryScalarFieldEnum = (typeof OrderHistoryScalarFieldEnum)[keyof typeof OrderHistoryScalarFieldEnum]


  export const EnterpriseScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    name: 'name',
    responsiblePerson: 'responsiblePerson',
    phoneNumber: 'phoneNumber',
    email: 'email',
    description: 'description',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type EnterpriseScalarFieldEnum = (typeof EnterpriseScalarFieldEnum)[keyof typeof EnterpriseScalarFieldEnum]


  export const ConfigurationScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    configKey: 'configKey',
    configValue: 'configValue',
    configText: 'configText',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    enterpriseId: 'enterpriseId'
  };

  export type ConfigurationScalarFieldEnum = (typeof ConfigurationScalarFieldEnum)[keyof typeof ConfigurationScalarFieldEnum]


  export const TagScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    name: 'name',
    textColor: 'textColor',
    backgroundColor: 'backgroundColor',
    status: 'status',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt',
    description: 'description'
  };

  export type TagScalarFieldEnum = (typeof TagScalarFieldEnum)[keyof typeof TagScalarFieldEnum]


  export const ProductTagScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    productId: 'productId',
    tagId: 'tagId'
  };

  export type ProductTagScalarFieldEnum = (typeof ProductTagScalarFieldEnum)[keyof typeof ProductTagScalarFieldEnum]


  export const PromotionTagScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    promotionId: 'promotionId',
    tagId: 'tagId'
  };

  export type PromotionTagScalarFieldEnum = (typeof PromotionTagScalarFieldEnum)[keyof typeof PromotionTagScalarFieldEnum]


  export const PromotionScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    name: 'name',
    description: 'description',
    status: 'status',
    discountRate: 'discountRate',
    startDate: 'startDate',
    endDate: 'endDate',
    categoryId: 'categoryId',
    enterpriseId: 'enterpriseId',
    deletedAt: 'deletedAt'
  };

  export type PromotionScalarFieldEnum = (typeof PromotionScalarFieldEnum)[keyof typeof PromotionScalarFieldEnum]


  export const ComboScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    name: 'name',
    description: 'description',
    price: 'price',
    status: 'status',
    categoryId: 'categoryId',
    enterpriseId: 'enterpriseId',
    productId: 'productId'
  };

  export type ComboScalarFieldEnum = (typeof ComboScalarFieldEnum)[keyof typeof ComboScalarFieldEnum]


  export const ComboProductsScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    comboId: 'comboId',
    productId: 'productId'
  };

  export type ComboProductsScalarFieldEnum = (typeof ComboProductsScalarFieldEnum)[keyof typeof ComboProductsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    uuid?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    nickname?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    deletedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    enterpriseId?: IntFilter<"User"> | number
    orders?: OrderListRelationFilter
    enterprise?: XOR<EnterpriseNullableRelationFilter, EnterpriseWhereInput> | null
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    email?: SortOrder
    nickname?: SortOrder
    role?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    enterpriseId?: SortOrder
    orders?: OrderOrderByRelationAggregateInput
    enterprise?: EnterpriseOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    uuid?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    email?: StringFilter<"User"> | string
    nickname?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    deletedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    enterpriseId?: IntFilter<"User"> | number
    orders?: OrderListRelationFilter
    enterprise?: XOR<EnterpriseNullableRelationFilter, EnterpriseWhereInput> | null
  }, "id" | "uuid">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    email?: SortOrder
    nickname?: SortOrder
    role?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    enterpriseId?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    uuid?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    nickname?: StringWithAggregatesFilter<"User"> | string
    role?: StringWithAggregatesFilter<"User"> | string
    firstName?: StringNullableWithAggregatesFilter<"User"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    enterpriseId?: IntWithAggregatesFilter<"User"> | number
  }

  export type CategoryWhereInput = {
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    id?: IntFilter<"Category"> | number
    uuid?: StringFilter<"Category"> | string
    name?: StringFilter<"Category"> | string
    description?: StringNullableFilter<"Category"> | string | null
    status?: StringFilter<"Category"> | string
    enterpriseId?: IntFilter<"Category"> | number
    products?: ProductListRelationFilter
    enterprise?: XOR<EnterpriseRelationFilter, EnterpriseWhereInput>
    promotions?: PromotionListRelationFilter
    combos?: ComboListRelationFilter
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    enterpriseId?: SortOrder
    products?: ProductOrderByRelationAggregateInput
    enterprise?: EnterpriseOrderByWithRelationInput
    promotions?: PromotionOrderByRelationAggregateInput
    combos?: ComboOrderByRelationAggregateInput
  }

  export type CategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    uuid?: string
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    name?: StringFilter<"Category"> | string
    description?: StringNullableFilter<"Category"> | string | null
    status?: StringFilter<"Category"> | string
    enterpriseId?: IntFilter<"Category"> | number
    products?: ProductListRelationFilter
    enterprise?: XOR<EnterpriseRelationFilter, EnterpriseWhereInput>
    promotions?: PromotionListRelationFilter
    combos?: ComboListRelationFilter
  }, "id" | "uuid">

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    enterpriseId?: SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _avg?: CategoryAvgOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
    _sum?: CategorySumOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    OR?: CategoryScalarWhereWithAggregatesInput[]
    NOT?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Category"> | number
    uuid?: StringWithAggregatesFilter<"Category"> | string
    name?: StringWithAggregatesFilter<"Category"> | string
    description?: StringNullableWithAggregatesFilter<"Category"> | string | null
    status?: StringWithAggregatesFilter<"Category"> | string
    enterpriseId?: IntWithAggregatesFilter<"Category"> | number
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: IntFilter<"Product"> | number
    uuid?: StringFilter<"Product"> | string
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    type?: StringFilter<"Product"> | string
    price?: FloatFilter<"Product"> | number
    free?: BoolFilter<"Product"> | boolean
    status?: StringFilter<"Product"> | string
    additionalsMax?: IntFilter<"Product"> | number
    accompanimentsMax?: IntFilter<"Product"> | number
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Product"> | Date | string | null
    categoryId?: IntFilter<"Product"> | number
    enterpriseId?: IntFilter<"Product"> | number
    category?: XOR<CategoryRelationFilter, CategoryWhereInput>
    enterprise?: XOR<EnterpriseRelationFilter, EnterpriseWhereInput>
    accompaniments?: AccompanimentListRelationFilter
    additionals?: AdditionalListRelationFilter
    orders?: OrderListRelationFilter
    orderItems?: OrderItemListRelationFilter
    productTags?: ProductTagListRelationFilter
    combos?: ComboListRelationFilter
    ComboProducts?: ComboProductsListRelationFilter
    Combo?: ComboListRelationFilter
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    price?: SortOrder
    free?: SortOrder
    status?: SortOrder
    additionalsMax?: SortOrder
    accompanimentsMax?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    categoryId?: SortOrder
    enterpriseId?: SortOrder
    category?: CategoryOrderByWithRelationInput
    enterprise?: EnterpriseOrderByWithRelationInput
    accompaniments?: AccompanimentOrderByRelationAggregateInput
    additionals?: AdditionalOrderByRelationAggregateInput
    orders?: OrderOrderByRelationAggregateInput
    orderItems?: OrderItemOrderByRelationAggregateInput
    productTags?: ProductTagOrderByRelationAggregateInput
    combos?: ComboOrderByRelationAggregateInput
    ComboProducts?: ComboProductsOrderByRelationAggregateInput
    Combo?: ComboOrderByRelationAggregateInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    uuid?: string
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    type?: StringFilter<"Product"> | string
    price?: FloatFilter<"Product"> | number
    free?: BoolFilter<"Product"> | boolean
    status?: StringFilter<"Product"> | string
    additionalsMax?: IntFilter<"Product"> | number
    accompanimentsMax?: IntFilter<"Product"> | number
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Product"> | Date | string | null
    categoryId?: IntFilter<"Product"> | number
    enterpriseId?: IntFilter<"Product"> | number
    category?: XOR<CategoryRelationFilter, CategoryWhereInput>
    enterprise?: XOR<EnterpriseRelationFilter, EnterpriseWhereInput>
    accompaniments?: AccompanimentListRelationFilter
    additionals?: AdditionalListRelationFilter
    orders?: OrderListRelationFilter
    orderItems?: OrderItemListRelationFilter
    productTags?: ProductTagListRelationFilter
    combos?: ComboListRelationFilter
    ComboProducts?: ComboProductsListRelationFilter
    Combo?: ComboListRelationFilter
  }, "id" | "uuid">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    price?: SortOrder
    free?: SortOrder
    status?: SortOrder
    additionalsMax?: SortOrder
    accompanimentsMax?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    categoryId?: SortOrder
    enterpriseId?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Product"> | number
    uuid?: StringWithAggregatesFilter<"Product"> | string
    name?: StringWithAggregatesFilter<"Product"> | string
    description?: StringNullableWithAggregatesFilter<"Product"> | string | null
    type?: StringWithAggregatesFilter<"Product"> | string
    price?: FloatWithAggregatesFilter<"Product"> | number
    free?: BoolWithAggregatesFilter<"Product"> | boolean
    status?: StringWithAggregatesFilter<"Product"> | string
    additionalsMax?: IntWithAggregatesFilter<"Product"> | number
    accompanimentsMax?: IntWithAggregatesFilter<"Product"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Product"> | Date | string | null
    categoryId?: IntWithAggregatesFilter<"Product"> | number
    enterpriseId?: IntWithAggregatesFilter<"Product"> | number
  }

  export type AccompanimentWhereInput = {
    AND?: AccompanimentWhereInput | AccompanimentWhereInput[]
    OR?: AccompanimentWhereInput[]
    NOT?: AccompanimentWhereInput | AccompanimentWhereInput[]
    id?: IntFilter<"Accompaniment"> | number
    uuid?: StringFilter<"Accompaniment"> | string
    productId?: IntFilter<"Accompaniment"> | number
    product?: XOR<ProductRelationFilter, ProductWhereInput>
  }

  export type AccompanimentOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    productId?: SortOrder
    product?: ProductOrderByWithRelationInput
  }

  export type AccompanimentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    uuid?: string
    AND?: AccompanimentWhereInput | AccompanimentWhereInput[]
    OR?: AccompanimentWhereInput[]
    NOT?: AccompanimentWhereInput | AccompanimentWhereInput[]
    productId?: IntFilter<"Accompaniment"> | number
    product?: XOR<ProductRelationFilter, ProductWhereInput>
  }, "id" | "uuid">

  export type AccompanimentOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    productId?: SortOrder
    _count?: AccompanimentCountOrderByAggregateInput
    _avg?: AccompanimentAvgOrderByAggregateInput
    _max?: AccompanimentMaxOrderByAggregateInput
    _min?: AccompanimentMinOrderByAggregateInput
    _sum?: AccompanimentSumOrderByAggregateInput
  }

  export type AccompanimentScalarWhereWithAggregatesInput = {
    AND?: AccompanimentScalarWhereWithAggregatesInput | AccompanimentScalarWhereWithAggregatesInput[]
    OR?: AccompanimentScalarWhereWithAggregatesInput[]
    NOT?: AccompanimentScalarWhereWithAggregatesInput | AccompanimentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Accompaniment"> | number
    uuid?: StringWithAggregatesFilter<"Accompaniment"> | string
    productId?: IntWithAggregatesFilter<"Accompaniment"> | number
  }

  export type AdditionalWhereInput = {
    AND?: AdditionalWhereInput | AdditionalWhereInput[]
    OR?: AdditionalWhereInput[]
    NOT?: AdditionalWhereInput | AdditionalWhereInput[]
    id?: IntFilter<"Additional"> | number
    uuid?: StringFilter<"Additional"> | string
    productId?: IntFilter<"Additional"> | number
    product?: XOR<ProductRelationFilter, ProductWhereInput>
  }

  export type AdditionalOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    productId?: SortOrder
    product?: ProductOrderByWithRelationInput
  }

  export type AdditionalWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    uuid?: string
    AND?: AdditionalWhereInput | AdditionalWhereInput[]
    OR?: AdditionalWhereInput[]
    NOT?: AdditionalWhereInput | AdditionalWhereInput[]
    productId?: IntFilter<"Additional"> | number
    product?: XOR<ProductRelationFilter, ProductWhereInput>
  }, "id" | "uuid">

  export type AdditionalOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    productId?: SortOrder
    _count?: AdditionalCountOrderByAggregateInput
    _avg?: AdditionalAvgOrderByAggregateInput
    _max?: AdditionalMaxOrderByAggregateInput
    _min?: AdditionalMinOrderByAggregateInput
    _sum?: AdditionalSumOrderByAggregateInput
  }

  export type AdditionalScalarWhereWithAggregatesInput = {
    AND?: AdditionalScalarWhereWithAggregatesInput | AdditionalScalarWhereWithAggregatesInput[]
    OR?: AdditionalScalarWhereWithAggregatesInput[]
    NOT?: AdditionalScalarWhereWithAggregatesInput | AdditionalScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Additional"> | number
    uuid?: StringWithAggregatesFilter<"Additional"> | string
    productId?: IntWithAggregatesFilter<"Additional"> | number
  }

  export type OrderWhereInput = {
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    id?: IntFilter<"Order"> | number
    uuid?: StringFilter<"Order"> | string
    totalPrice?: FloatFilter<"Order"> | number
    status?: StringFilter<"Order"> | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    orderDate?: DateTimeFilter<"Order"> | Date | string
    userId?: IntFilter<"Order"> | number
    enterpriseId?: IntFilter<"Order"> | number
    user?: XOR<UserRelationFilter, UserWhereInput>
    products?: ProductListRelationFilter
    enterprise?: XOR<EnterpriseRelationFilter, EnterpriseWhereInput>
    orderItems?: OrderItemListRelationFilter
    orderHistories?: OrderHistoryListRelationFilter
  }

  export type OrderOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    totalPrice?: SortOrder
    status?: SortOrder
    updatedAt?: SortOrder
    orderDate?: SortOrder
    userId?: SortOrder
    enterpriseId?: SortOrder
    user?: UserOrderByWithRelationInput
    products?: ProductOrderByRelationAggregateInput
    enterprise?: EnterpriseOrderByWithRelationInput
    orderItems?: OrderItemOrderByRelationAggregateInput
    orderHistories?: OrderHistoryOrderByRelationAggregateInput
  }

  export type OrderWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    uuid?: string
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    totalPrice?: FloatFilter<"Order"> | number
    status?: StringFilter<"Order"> | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    orderDate?: DateTimeFilter<"Order"> | Date | string
    userId?: IntFilter<"Order"> | number
    enterpriseId?: IntFilter<"Order"> | number
    user?: XOR<UserRelationFilter, UserWhereInput>
    products?: ProductListRelationFilter
    enterprise?: XOR<EnterpriseRelationFilter, EnterpriseWhereInput>
    orderItems?: OrderItemListRelationFilter
    orderHistories?: OrderHistoryListRelationFilter
  }, "id" | "uuid">

  export type OrderOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    totalPrice?: SortOrder
    status?: SortOrder
    updatedAt?: SortOrder
    orderDate?: SortOrder
    userId?: SortOrder
    enterpriseId?: SortOrder
    _count?: OrderCountOrderByAggregateInput
    _avg?: OrderAvgOrderByAggregateInput
    _max?: OrderMaxOrderByAggregateInput
    _min?: OrderMinOrderByAggregateInput
    _sum?: OrderSumOrderByAggregateInput
  }

  export type OrderScalarWhereWithAggregatesInput = {
    AND?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    OR?: OrderScalarWhereWithAggregatesInput[]
    NOT?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Order"> | number
    uuid?: StringWithAggregatesFilter<"Order"> | string
    totalPrice?: FloatWithAggregatesFilter<"Order"> | number
    status?: StringWithAggregatesFilter<"Order"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    orderDate?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    userId?: IntWithAggregatesFilter<"Order"> | number
    enterpriseId?: IntWithAggregatesFilter<"Order"> | number
  }

  export type OrderItemWhereInput = {
    AND?: OrderItemWhereInput | OrderItemWhereInput[]
    OR?: OrderItemWhereInput[]
    NOT?: OrderItemWhereInput | OrderItemWhereInput[]
    id?: IntFilter<"OrderItem"> | number
    uuid?: StringFilter<"OrderItem"> | string
    quantity?: IntFilter<"OrderItem"> | number
    price?: FloatFilter<"OrderItem"> | number
    productId?: IntFilter<"OrderItem"> | number
    orderId?: IntFilter<"OrderItem"> | number
    product?: XOR<ProductRelationFilter, ProductWhereInput>
    order?: XOR<OrderRelationFilter, OrderWhereInput>
  }

  export type OrderItemOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    productId?: SortOrder
    orderId?: SortOrder
    product?: ProductOrderByWithRelationInput
    order?: OrderOrderByWithRelationInput
  }

  export type OrderItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    uuid?: string
    AND?: OrderItemWhereInput | OrderItemWhereInput[]
    OR?: OrderItemWhereInput[]
    NOT?: OrderItemWhereInput | OrderItemWhereInput[]
    quantity?: IntFilter<"OrderItem"> | number
    price?: FloatFilter<"OrderItem"> | number
    productId?: IntFilter<"OrderItem"> | number
    orderId?: IntFilter<"OrderItem"> | number
    product?: XOR<ProductRelationFilter, ProductWhereInput>
    order?: XOR<OrderRelationFilter, OrderWhereInput>
  }, "id" | "uuid">

  export type OrderItemOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    productId?: SortOrder
    orderId?: SortOrder
    _count?: OrderItemCountOrderByAggregateInput
    _avg?: OrderItemAvgOrderByAggregateInput
    _max?: OrderItemMaxOrderByAggregateInput
    _min?: OrderItemMinOrderByAggregateInput
    _sum?: OrderItemSumOrderByAggregateInput
  }

  export type OrderItemScalarWhereWithAggregatesInput = {
    AND?: OrderItemScalarWhereWithAggregatesInput | OrderItemScalarWhereWithAggregatesInput[]
    OR?: OrderItemScalarWhereWithAggregatesInput[]
    NOT?: OrderItemScalarWhereWithAggregatesInput | OrderItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"OrderItem"> | number
    uuid?: StringWithAggregatesFilter<"OrderItem"> | string
    quantity?: IntWithAggregatesFilter<"OrderItem"> | number
    price?: FloatWithAggregatesFilter<"OrderItem"> | number
    productId?: IntWithAggregatesFilter<"OrderItem"> | number
    orderId?: IntWithAggregatesFilter<"OrderItem"> | number
  }

  export type OrderHistoryWhereInput = {
    AND?: OrderHistoryWhereInput | OrderHistoryWhereInput[]
    OR?: OrderHistoryWhereInput[]
    NOT?: OrderHistoryWhereInput | OrderHistoryWhereInput[]
    id?: IntFilter<"OrderHistory"> | number
    uuid?: StringFilter<"OrderHistory"> | string
    status?: StringFilter<"OrderHistory"> | string
    description?: StringNullableFilter<"OrderHistory"> | string | null
    orderId?: IntFilter<"OrderHistory"> | number
    createdAt?: DateTimeFilter<"OrderHistory"> | Date | string
    order?: XOR<OrderRelationFilter, OrderWhereInput>
  }

  export type OrderHistoryOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    status?: SortOrder
    description?: SortOrderInput | SortOrder
    orderId?: SortOrder
    createdAt?: SortOrder
    order?: OrderOrderByWithRelationInput
  }

  export type OrderHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    uuid?: string
    AND?: OrderHistoryWhereInput | OrderHistoryWhereInput[]
    OR?: OrderHistoryWhereInput[]
    NOT?: OrderHistoryWhereInput | OrderHistoryWhereInput[]
    status?: StringFilter<"OrderHistory"> | string
    description?: StringNullableFilter<"OrderHistory"> | string | null
    orderId?: IntFilter<"OrderHistory"> | number
    createdAt?: DateTimeFilter<"OrderHistory"> | Date | string
    order?: XOR<OrderRelationFilter, OrderWhereInput>
  }, "id" | "uuid">

  export type OrderHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    status?: SortOrder
    description?: SortOrderInput | SortOrder
    orderId?: SortOrder
    createdAt?: SortOrder
    _count?: OrderHistoryCountOrderByAggregateInput
    _avg?: OrderHistoryAvgOrderByAggregateInput
    _max?: OrderHistoryMaxOrderByAggregateInput
    _min?: OrderHistoryMinOrderByAggregateInput
    _sum?: OrderHistorySumOrderByAggregateInput
  }

  export type OrderHistoryScalarWhereWithAggregatesInput = {
    AND?: OrderHistoryScalarWhereWithAggregatesInput | OrderHistoryScalarWhereWithAggregatesInput[]
    OR?: OrderHistoryScalarWhereWithAggregatesInput[]
    NOT?: OrderHistoryScalarWhereWithAggregatesInput | OrderHistoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"OrderHistory"> | number
    uuid?: StringWithAggregatesFilter<"OrderHistory"> | string
    status?: StringWithAggregatesFilter<"OrderHistory"> | string
    description?: StringNullableWithAggregatesFilter<"OrderHistory"> | string | null
    orderId?: IntWithAggregatesFilter<"OrderHistory"> | number
    createdAt?: DateTimeWithAggregatesFilter<"OrderHistory"> | Date | string
  }

  export type EnterpriseWhereInput = {
    AND?: EnterpriseWhereInput | EnterpriseWhereInput[]
    OR?: EnterpriseWhereInput[]
    NOT?: EnterpriseWhereInput | EnterpriseWhereInput[]
    id?: IntFilter<"Enterprise"> | number
    uuid?: StringFilter<"Enterprise"> | string
    name?: StringFilter<"Enterprise"> | string
    responsiblePerson?: StringNullableFilter<"Enterprise"> | string | null
    phoneNumber?: StringNullableFilter<"Enterprise"> | string | null
    email?: StringNullableFilter<"Enterprise"> | string | null
    description?: StringNullableFilter<"Enterprise"> | string | null
    status?: StringFilter<"Enterprise"> | string
    createdAt?: DateTimeFilter<"Enterprise"> | Date | string
    updatedAt?: DateTimeFilter<"Enterprise"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Enterprise"> | Date | string | null
    users?: UserListRelationFilter
    categories?: CategoryListRelationFilter
    products?: ProductListRelationFilter
    configurations?: ConfigurationListRelationFilter
    orders?: OrderListRelationFilter
    promotions?: PromotionListRelationFilter
    combos?: ComboListRelationFilter
  }

  export type EnterpriseOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    responsiblePerson?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    users?: UserOrderByRelationAggregateInput
    categories?: CategoryOrderByRelationAggregateInput
    products?: ProductOrderByRelationAggregateInput
    configurations?: ConfigurationOrderByRelationAggregateInput
    orders?: OrderOrderByRelationAggregateInput
    promotions?: PromotionOrderByRelationAggregateInput
    combos?: ComboOrderByRelationAggregateInput
  }

  export type EnterpriseWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    uuid?: string
    AND?: EnterpriseWhereInput | EnterpriseWhereInput[]
    OR?: EnterpriseWhereInput[]
    NOT?: EnterpriseWhereInput | EnterpriseWhereInput[]
    name?: StringFilter<"Enterprise"> | string
    responsiblePerson?: StringNullableFilter<"Enterprise"> | string | null
    phoneNumber?: StringNullableFilter<"Enterprise"> | string | null
    email?: StringNullableFilter<"Enterprise"> | string | null
    description?: StringNullableFilter<"Enterprise"> | string | null
    status?: StringFilter<"Enterprise"> | string
    createdAt?: DateTimeFilter<"Enterprise"> | Date | string
    updatedAt?: DateTimeFilter<"Enterprise"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Enterprise"> | Date | string | null
    users?: UserListRelationFilter
    categories?: CategoryListRelationFilter
    products?: ProductListRelationFilter
    configurations?: ConfigurationListRelationFilter
    orders?: OrderListRelationFilter
    promotions?: PromotionListRelationFilter
    combos?: ComboListRelationFilter
  }, "id" | "uuid">

  export type EnterpriseOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    responsiblePerson?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: EnterpriseCountOrderByAggregateInput
    _avg?: EnterpriseAvgOrderByAggregateInput
    _max?: EnterpriseMaxOrderByAggregateInput
    _min?: EnterpriseMinOrderByAggregateInput
    _sum?: EnterpriseSumOrderByAggregateInput
  }

  export type EnterpriseScalarWhereWithAggregatesInput = {
    AND?: EnterpriseScalarWhereWithAggregatesInput | EnterpriseScalarWhereWithAggregatesInput[]
    OR?: EnterpriseScalarWhereWithAggregatesInput[]
    NOT?: EnterpriseScalarWhereWithAggregatesInput | EnterpriseScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Enterprise"> | number
    uuid?: StringWithAggregatesFilter<"Enterprise"> | string
    name?: StringWithAggregatesFilter<"Enterprise"> | string
    responsiblePerson?: StringNullableWithAggregatesFilter<"Enterprise"> | string | null
    phoneNumber?: StringNullableWithAggregatesFilter<"Enterprise"> | string | null
    email?: StringNullableWithAggregatesFilter<"Enterprise"> | string | null
    description?: StringNullableWithAggregatesFilter<"Enterprise"> | string | null
    status?: StringWithAggregatesFilter<"Enterprise"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Enterprise"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Enterprise"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Enterprise"> | Date | string | null
  }

  export type ConfigurationWhereInput = {
    AND?: ConfigurationWhereInput | ConfigurationWhereInput[]
    OR?: ConfigurationWhereInput[]
    NOT?: ConfigurationWhereInput | ConfigurationWhereInput[]
    id?: IntFilter<"Configuration"> | number
    uuid?: StringFilter<"Configuration"> | string
    configKey?: StringFilter<"Configuration"> | string
    configValue?: StringFilter<"Configuration"> | string
    configText?: StringNullableFilter<"Configuration"> | string | null
    createdAt?: DateTimeFilter<"Configuration"> | Date | string
    updatedAt?: DateTimeFilter<"Configuration"> | Date | string
    enterpriseId?: IntFilter<"Configuration"> | number
    enterprise?: XOR<EnterpriseRelationFilter, EnterpriseWhereInput>
  }

  export type ConfigurationOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    configKey?: SortOrder
    configValue?: SortOrder
    configText?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    enterpriseId?: SortOrder
    enterprise?: EnterpriseOrderByWithRelationInput
  }

  export type ConfigurationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    uuid?: string
    AND?: ConfigurationWhereInput | ConfigurationWhereInput[]
    OR?: ConfigurationWhereInput[]
    NOT?: ConfigurationWhereInput | ConfigurationWhereInput[]
    configKey?: StringFilter<"Configuration"> | string
    configValue?: StringFilter<"Configuration"> | string
    configText?: StringNullableFilter<"Configuration"> | string | null
    createdAt?: DateTimeFilter<"Configuration"> | Date | string
    updatedAt?: DateTimeFilter<"Configuration"> | Date | string
    enterpriseId?: IntFilter<"Configuration"> | number
    enterprise?: XOR<EnterpriseRelationFilter, EnterpriseWhereInput>
  }, "id" | "uuid">

  export type ConfigurationOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    configKey?: SortOrder
    configValue?: SortOrder
    configText?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    enterpriseId?: SortOrder
    _count?: ConfigurationCountOrderByAggregateInput
    _avg?: ConfigurationAvgOrderByAggregateInput
    _max?: ConfigurationMaxOrderByAggregateInput
    _min?: ConfigurationMinOrderByAggregateInput
    _sum?: ConfigurationSumOrderByAggregateInput
  }

  export type ConfigurationScalarWhereWithAggregatesInput = {
    AND?: ConfigurationScalarWhereWithAggregatesInput | ConfigurationScalarWhereWithAggregatesInput[]
    OR?: ConfigurationScalarWhereWithAggregatesInput[]
    NOT?: ConfigurationScalarWhereWithAggregatesInput | ConfigurationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Configuration"> | number
    uuid?: StringWithAggregatesFilter<"Configuration"> | string
    configKey?: StringWithAggregatesFilter<"Configuration"> | string
    configValue?: StringWithAggregatesFilter<"Configuration"> | string
    configText?: StringNullableWithAggregatesFilter<"Configuration"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Configuration"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Configuration"> | Date | string
    enterpriseId?: IntWithAggregatesFilter<"Configuration"> | number
  }

  export type TagWhereInput = {
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    id?: IntFilter<"Tag"> | number
    uuid?: StringFilter<"Tag"> | string
    name?: StringFilter<"Tag"> | string
    textColor?: StringFilter<"Tag"> | string
    backgroundColor?: StringFilter<"Tag"> | string
    status?: StringFilter<"Tag"> | string
    updatedAt?: DateTimeFilter<"Tag"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Tag"> | Date | string | null
    description?: StringNullableFilter<"Tag"> | string | null
    productTags?: ProductTagListRelationFilter
    promotionTags?: PromotionTagListRelationFilter
  }

  export type TagOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    textColor?: SortOrder
    backgroundColor?: SortOrder
    status?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    productTags?: ProductTagOrderByRelationAggregateInput
    promotionTags?: PromotionTagOrderByRelationAggregateInput
  }

  export type TagWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    uuid?: string
    name?: string
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    textColor?: StringFilter<"Tag"> | string
    backgroundColor?: StringFilter<"Tag"> | string
    status?: StringFilter<"Tag"> | string
    updatedAt?: DateTimeFilter<"Tag"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Tag"> | Date | string | null
    description?: StringNullableFilter<"Tag"> | string | null
    productTags?: ProductTagListRelationFilter
    promotionTags?: PromotionTagListRelationFilter
  }, "id" | "uuid" | "name">

  export type TagOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    textColor?: SortOrder
    backgroundColor?: SortOrder
    status?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    _count?: TagCountOrderByAggregateInput
    _avg?: TagAvgOrderByAggregateInput
    _max?: TagMaxOrderByAggregateInput
    _min?: TagMinOrderByAggregateInput
    _sum?: TagSumOrderByAggregateInput
  }

  export type TagScalarWhereWithAggregatesInput = {
    AND?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    OR?: TagScalarWhereWithAggregatesInput[]
    NOT?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Tag"> | number
    uuid?: StringWithAggregatesFilter<"Tag"> | string
    name?: StringWithAggregatesFilter<"Tag"> | string
    textColor?: StringWithAggregatesFilter<"Tag"> | string
    backgroundColor?: StringWithAggregatesFilter<"Tag"> | string
    status?: StringWithAggregatesFilter<"Tag"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"Tag"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Tag"> | Date | string | null
    description?: StringNullableWithAggregatesFilter<"Tag"> | string | null
  }

  export type ProductTagWhereInput = {
    AND?: ProductTagWhereInput | ProductTagWhereInput[]
    OR?: ProductTagWhereInput[]
    NOT?: ProductTagWhereInput | ProductTagWhereInput[]
    id?: IntFilter<"ProductTag"> | number
    uuid?: StringFilter<"ProductTag"> | string
    productId?: IntFilter<"ProductTag"> | number
    tagId?: IntFilter<"ProductTag"> | number
    product?: XOR<ProductRelationFilter, ProductWhereInput>
    tag?: XOR<TagRelationFilter, TagWhereInput>
  }

  export type ProductTagOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    productId?: SortOrder
    tagId?: SortOrder
    product?: ProductOrderByWithRelationInput
    tag?: TagOrderByWithRelationInput
  }

  export type ProductTagWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    uuid?: string
    AND?: ProductTagWhereInput | ProductTagWhereInput[]
    OR?: ProductTagWhereInput[]
    NOT?: ProductTagWhereInput | ProductTagWhereInput[]
    productId?: IntFilter<"ProductTag"> | number
    tagId?: IntFilter<"ProductTag"> | number
    product?: XOR<ProductRelationFilter, ProductWhereInput>
    tag?: XOR<TagRelationFilter, TagWhereInput>
  }, "id" | "uuid">

  export type ProductTagOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    productId?: SortOrder
    tagId?: SortOrder
    _count?: ProductTagCountOrderByAggregateInput
    _avg?: ProductTagAvgOrderByAggregateInput
    _max?: ProductTagMaxOrderByAggregateInput
    _min?: ProductTagMinOrderByAggregateInput
    _sum?: ProductTagSumOrderByAggregateInput
  }

  export type ProductTagScalarWhereWithAggregatesInput = {
    AND?: ProductTagScalarWhereWithAggregatesInput | ProductTagScalarWhereWithAggregatesInput[]
    OR?: ProductTagScalarWhereWithAggregatesInput[]
    NOT?: ProductTagScalarWhereWithAggregatesInput | ProductTagScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProductTag"> | number
    uuid?: StringWithAggregatesFilter<"ProductTag"> | string
    productId?: IntWithAggregatesFilter<"ProductTag"> | number
    tagId?: IntWithAggregatesFilter<"ProductTag"> | number
  }

  export type PromotionTagWhereInput = {
    AND?: PromotionTagWhereInput | PromotionTagWhereInput[]
    OR?: PromotionTagWhereInput[]
    NOT?: PromotionTagWhereInput | PromotionTagWhereInput[]
    id?: IntFilter<"PromotionTag"> | number
    uuid?: StringFilter<"PromotionTag"> | string
    promotionId?: IntFilter<"PromotionTag"> | number
    tagId?: IntFilter<"PromotionTag"> | number
    promotion?: XOR<PromotionRelationFilter, PromotionWhereInput>
    tag?: XOR<TagRelationFilter, TagWhereInput>
  }

  export type PromotionTagOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    promotionId?: SortOrder
    tagId?: SortOrder
    promotion?: PromotionOrderByWithRelationInput
    tag?: TagOrderByWithRelationInput
  }

  export type PromotionTagWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    uuid?: string
    AND?: PromotionTagWhereInput | PromotionTagWhereInput[]
    OR?: PromotionTagWhereInput[]
    NOT?: PromotionTagWhereInput | PromotionTagWhereInput[]
    promotionId?: IntFilter<"PromotionTag"> | number
    tagId?: IntFilter<"PromotionTag"> | number
    promotion?: XOR<PromotionRelationFilter, PromotionWhereInput>
    tag?: XOR<TagRelationFilter, TagWhereInput>
  }, "id" | "uuid">

  export type PromotionTagOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    promotionId?: SortOrder
    tagId?: SortOrder
    _count?: PromotionTagCountOrderByAggregateInput
    _avg?: PromotionTagAvgOrderByAggregateInput
    _max?: PromotionTagMaxOrderByAggregateInput
    _min?: PromotionTagMinOrderByAggregateInput
    _sum?: PromotionTagSumOrderByAggregateInput
  }

  export type PromotionTagScalarWhereWithAggregatesInput = {
    AND?: PromotionTagScalarWhereWithAggregatesInput | PromotionTagScalarWhereWithAggregatesInput[]
    OR?: PromotionTagScalarWhereWithAggregatesInput[]
    NOT?: PromotionTagScalarWhereWithAggregatesInput | PromotionTagScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PromotionTag"> | number
    uuid?: StringWithAggregatesFilter<"PromotionTag"> | string
    promotionId?: IntWithAggregatesFilter<"PromotionTag"> | number
    tagId?: IntWithAggregatesFilter<"PromotionTag"> | number
  }

  export type PromotionWhereInput = {
    AND?: PromotionWhereInput | PromotionWhereInput[]
    OR?: PromotionWhereInput[]
    NOT?: PromotionWhereInput | PromotionWhereInput[]
    id?: IntFilter<"Promotion"> | number
    uuid?: StringFilter<"Promotion"> | string
    name?: StringFilter<"Promotion"> | string
    description?: StringNullableFilter<"Promotion"> | string | null
    status?: StringFilter<"Promotion"> | string
    discountRate?: FloatFilter<"Promotion"> | number
    startDate?: DateTimeFilter<"Promotion"> | Date | string
    endDate?: DateTimeFilter<"Promotion"> | Date | string
    categoryId?: IntFilter<"Promotion"> | number
    enterpriseId?: IntFilter<"Promotion"> | number
    deletedAt?: DateTimeNullableFilter<"Promotion"> | Date | string | null
    category?: XOR<CategoryRelationFilter, CategoryWhereInput>
    enterprise?: XOR<EnterpriseRelationFilter, EnterpriseWhereInput>
    promotionTags?: PromotionTagListRelationFilter
  }

  export type PromotionOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    discountRate?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    categoryId?: SortOrder
    enterpriseId?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    category?: CategoryOrderByWithRelationInput
    enterprise?: EnterpriseOrderByWithRelationInput
    promotionTags?: PromotionTagOrderByRelationAggregateInput
  }

  export type PromotionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    uuid?: string
    AND?: PromotionWhereInput | PromotionWhereInput[]
    OR?: PromotionWhereInput[]
    NOT?: PromotionWhereInput | PromotionWhereInput[]
    name?: StringFilter<"Promotion"> | string
    description?: StringNullableFilter<"Promotion"> | string | null
    status?: StringFilter<"Promotion"> | string
    discountRate?: FloatFilter<"Promotion"> | number
    startDate?: DateTimeFilter<"Promotion"> | Date | string
    endDate?: DateTimeFilter<"Promotion"> | Date | string
    categoryId?: IntFilter<"Promotion"> | number
    enterpriseId?: IntFilter<"Promotion"> | number
    deletedAt?: DateTimeNullableFilter<"Promotion"> | Date | string | null
    category?: XOR<CategoryRelationFilter, CategoryWhereInput>
    enterprise?: XOR<EnterpriseRelationFilter, EnterpriseWhereInput>
    promotionTags?: PromotionTagListRelationFilter
  }, "id" | "uuid">

  export type PromotionOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    discountRate?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    categoryId?: SortOrder
    enterpriseId?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: PromotionCountOrderByAggregateInput
    _avg?: PromotionAvgOrderByAggregateInput
    _max?: PromotionMaxOrderByAggregateInput
    _min?: PromotionMinOrderByAggregateInput
    _sum?: PromotionSumOrderByAggregateInput
  }

  export type PromotionScalarWhereWithAggregatesInput = {
    AND?: PromotionScalarWhereWithAggregatesInput | PromotionScalarWhereWithAggregatesInput[]
    OR?: PromotionScalarWhereWithAggregatesInput[]
    NOT?: PromotionScalarWhereWithAggregatesInput | PromotionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Promotion"> | number
    uuid?: StringWithAggregatesFilter<"Promotion"> | string
    name?: StringWithAggregatesFilter<"Promotion"> | string
    description?: StringNullableWithAggregatesFilter<"Promotion"> | string | null
    status?: StringWithAggregatesFilter<"Promotion"> | string
    discountRate?: FloatWithAggregatesFilter<"Promotion"> | number
    startDate?: DateTimeWithAggregatesFilter<"Promotion"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Promotion"> | Date | string
    categoryId?: IntWithAggregatesFilter<"Promotion"> | number
    enterpriseId?: IntWithAggregatesFilter<"Promotion"> | number
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Promotion"> | Date | string | null
  }

  export type ComboWhereInput = {
    AND?: ComboWhereInput | ComboWhereInput[]
    OR?: ComboWhereInput[]
    NOT?: ComboWhereInput | ComboWhereInput[]
    id?: IntFilter<"Combo"> | number
    uuid?: StringFilter<"Combo"> | string
    name?: StringFilter<"Combo"> | string
    description?: StringNullableFilter<"Combo"> | string | null
    price?: FloatFilter<"Combo"> | number
    status?: StringFilter<"Combo"> | string
    categoryId?: IntFilter<"Combo"> | number
    enterpriseId?: IntFilter<"Combo"> | number
    productId?: IntNullableFilter<"Combo"> | number | null
    category?: XOR<CategoryRelationFilter, CategoryWhereInput>
    enterprise?: XOR<EnterpriseRelationFilter, EnterpriseWhereInput>
    products?: ProductListRelationFilter
    ComboProducts?: ComboProductsListRelationFilter
    Product?: XOR<ProductNullableRelationFilter, ProductWhereInput> | null
  }

  export type ComboOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    status?: SortOrder
    categoryId?: SortOrder
    enterpriseId?: SortOrder
    productId?: SortOrderInput | SortOrder
    category?: CategoryOrderByWithRelationInput
    enterprise?: EnterpriseOrderByWithRelationInput
    products?: ProductOrderByRelationAggregateInput
    ComboProducts?: ComboProductsOrderByRelationAggregateInput
    Product?: ProductOrderByWithRelationInput
  }

  export type ComboWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    uuid?: string
    AND?: ComboWhereInput | ComboWhereInput[]
    OR?: ComboWhereInput[]
    NOT?: ComboWhereInput | ComboWhereInput[]
    name?: StringFilter<"Combo"> | string
    description?: StringNullableFilter<"Combo"> | string | null
    price?: FloatFilter<"Combo"> | number
    status?: StringFilter<"Combo"> | string
    categoryId?: IntFilter<"Combo"> | number
    enterpriseId?: IntFilter<"Combo"> | number
    productId?: IntNullableFilter<"Combo"> | number | null
    category?: XOR<CategoryRelationFilter, CategoryWhereInput>
    enterprise?: XOR<EnterpriseRelationFilter, EnterpriseWhereInput>
    products?: ProductListRelationFilter
    ComboProducts?: ComboProductsListRelationFilter
    Product?: XOR<ProductNullableRelationFilter, ProductWhereInput> | null
  }, "id" | "uuid">

  export type ComboOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    status?: SortOrder
    categoryId?: SortOrder
    enterpriseId?: SortOrder
    productId?: SortOrderInput | SortOrder
    _count?: ComboCountOrderByAggregateInput
    _avg?: ComboAvgOrderByAggregateInput
    _max?: ComboMaxOrderByAggregateInput
    _min?: ComboMinOrderByAggregateInput
    _sum?: ComboSumOrderByAggregateInput
  }

  export type ComboScalarWhereWithAggregatesInput = {
    AND?: ComboScalarWhereWithAggregatesInput | ComboScalarWhereWithAggregatesInput[]
    OR?: ComboScalarWhereWithAggregatesInput[]
    NOT?: ComboScalarWhereWithAggregatesInput | ComboScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Combo"> | number
    uuid?: StringWithAggregatesFilter<"Combo"> | string
    name?: StringWithAggregatesFilter<"Combo"> | string
    description?: StringNullableWithAggregatesFilter<"Combo"> | string | null
    price?: FloatWithAggregatesFilter<"Combo"> | number
    status?: StringWithAggregatesFilter<"Combo"> | string
    categoryId?: IntWithAggregatesFilter<"Combo"> | number
    enterpriseId?: IntWithAggregatesFilter<"Combo"> | number
    productId?: IntNullableWithAggregatesFilter<"Combo"> | number | null
  }

  export type ComboProductsWhereInput = {
    AND?: ComboProductsWhereInput | ComboProductsWhereInput[]
    OR?: ComboProductsWhereInput[]
    NOT?: ComboProductsWhereInput | ComboProductsWhereInput[]
    id?: IntFilter<"ComboProducts"> | number
    uuid?: StringFilter<"ComboProducts"> | string
    comboId?: IntFilter<"ComboProducts"> | number
    productId?: IntFilter<"ComboProducts"> | number
    combo?: XOR<ComboRelationFilter, ComboWhereInput>
    product?: XOR<ProductRelationFilter, ProductWhereInput>
  }

  export type ComboProductsOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    comboId?: SortOrder
    productId?: SortOrder
    combo?: ComboOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type ComboProductsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    uuid?: string
    AND?: ComboProductsWhereInput | ComboProductsWhereInput[]
    OR?: ComboProductsWhereInput[]
    NOT?: ComboProductsWhereInput | ComboProductsWhereInput[]
    comboId?: IntFilter<"ComboProducts"> | number
    productId?: IntFilter<"ComboProducts"> | number
    combo?: XOR<ComboRelationFilter, ComboWhereInput>
    product?: XOR<ProductRelationFilter, ProductWhereInput>
  }, "id" | "uuid">

  export type ComboProductsOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    comboId?: SortOrder
    productId?: SortOrder
    _count?: ComboProductsCountOrderByAggregateInput
    _avg?: ComboProductsAvgOrderByAggregateInput
    _max?: ComboProductsMaxOrderByAggregateInput
    _min?: ComboProductsMinOrderByAggregateInput
    _sum?: ComboProductsSumOrderByAggregateInput
  }

  export type ComboProductsScalarWhereWithAggregatesInput = {
    AND?: ComboProductsScalarWhereWithAggregatesInput | ComboProductsScalarWhereWithAggregatesInput[]
    OR?: ComboProductsScalarWhereWithAggregatesInput[]
    NOT?: ComboProductsScalarWhereWithAggregatesInput | ComboProductsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ComboProducts"> | number
    uuid?: StringWithAggregatesFilter<"ComboProducts"> | string
    comboId?: IntWithAggregatesFilter<"ComboProducts"> | number
    productId?: IntWithAggregatesFilter<"ComboProducts"> | number
  }

  export type UserCreateInput = {
    uuid: string
    email: string
    nickname: string
    role: string
    firstName?: string | null
    lastName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    orders?: OrderCreateNestedManyWithoutUserInput
    enterprise?: EnterpriseCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    uuid: string
    email: string
    nickname: string
    role: string
    firstName?: string | null
    lastName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    enterpriseId: number
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orders?: OrderUpdateManyWithoutUserNestedInput
    enterprise?: EnterpriseUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enterpriseId?: IntFieldUpdateOperationsInput | number
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    uuid: string
    email: string
    nickname: string
    role: string
    firstName?: string | null
    lastName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    enterpriseId: number
  }

  export type UserUpdateManyMutationInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enterpriseId?: IntFieldUpdateOperationsInput | number
  }

  export type CategoryCreateInput = {
    uuid: string
    name: string
    description?: string | null
    status?: string
    products?: ProductCreateNestedManyWithoutCategoryInput
    enterprise: EnterpriseCreateNestedOneWithoutCategoriesInput
    promotions?: PromotionCreateNestedManyWithoutCategoryInput
    combos?: ComboCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateInput = {
    id?: number
    uuid: string
    name: string
    description?: string | null
    status?: string
    enterpriseId: number
    products?: ProductUncheckedCreateNestedManyWithoutCategoryInput
    promotions?: PromotionUncheckedCreateNestedManyWithoutCategoryInput
    combos?: ComboUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUpdateInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    products?: ProductUpdateManyWithoutCategoryNestedInput
    enterprise?: EnterpriseUpdateOneRequiredWithoutCategoriesNestedInput
    promotions?: PromotionUpdateManyWithoutCategoryNestedInput
    combos?: ComboUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    enterpriseId?: IntFieldUpdateOperationsInput | number
    products?: ProductUncheckedUpdateManyWithoutCategoryNestedInput
    promotions?: PromotionUncheckedUpdateManyWithoutCategoryNestedInput
    combos?: ComboUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryCreateManyInput = {
    id?: number
    uuid: string
    name: string
    description?: string | null
    status?: string
    enterpriseId: number
  }

  export type CategoryUpdateManyMutationInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type CategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    enterpriseId?: IntFieldUpdateOperationsInput | number
  }

  export type ProductCreateInput = {
    uuid: string
    name: string
    description?: string | null
    type?: string
    price: number
    free?: boolean
    status?: string
    additionalsMax?: number
    accompanimentsMax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    category: CategoryCreateNestedOneWithoutProductsInput
    enterprise: EnterpriseCreateNestedOneWithoutProductsInput
    accompaniments?: AccompanimentCreateNestedManyWithoutProductInput
    additionals?: AdditionalCreateNestedManyWithoutProductInput
    orders?: OrderCreateNestedManyWithoutProductsInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    productTags?: ProductTagCreateNestedManyWithoutProductInput
    combos?: ComboCreateNestedManyWithoutProductsInput
    ComboProducts?: ComboProductsCreateNestedManyWithoutProductInput
    Combo?: ComboCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id?: number
    uuid: string
    name: string
    description?: string | null
    type?: string
    price: number
    free?: boolean
    status?: string
    additionalsMax?: number
    accompanimentsMax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    categoryId: number
    enterpriseId: number
    accompaniments?: AccompanimentUncheckedCreateNestedManyWithoutProductInput
    additionals?: AdditionalUncheckedCreateNestedManyWithoutProductInput
    orders?: OrderUncheckedCreateNestedManyWithoutProductsInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    productTags?: ProductTagUncheckedCreateNestedManyWithoutProductInput
    combos?: ComboUncheckedCreateNestedManyWithoutProductsInput
    ComboProducts?: ComboProductsUncheckedCreateNestedManyWithoutProductInput
    Combo?: ComboUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    free?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    additionalsMax?: IntFieldUpdateOperationsInput | number
    accompanimentsMax?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: CategoryUpdateOneRequiredWithoutProductsNestedInput
    enterprise?: EnterpriseUpdateOneRequiredWithoutProductsNestedInput
    accompaniments?: AccompanimentUpdateManyWithoutProductNestedInput
    additionals?: AdditionalUpdateManyWithoutProductNestedInput
    orders?: OrderUpdateManyWithoutProductsNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    productTags?: ProductTagUpdateManyWithoutProductNestedInput
    combos?: ComboUpdateManyWithoutProductsNestedInput
    ComboProducts?: ComboProductsUpdateManyWithoutProductNestedInput
    Combo?: ComboUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    free?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    additionalsMax?: IntFieldUpdateOperationsInput | number
    accompanimentsMax?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categoryId?: IntFieldUpdateOperationsInput | number
    enterpriseId?: IntFieldUpdateOperationsInput | number
    accompaniments?: AccompanimentUncheckedUpdateManyWithoutProductNestedInput
    additionals?: AdditionalUncheckedUpdateManyWithoutProductNestedInput
    orders?: OrderUncheckedUpdateManyWithoutProductsNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    productTags?: ProductTagUncheckedUpdateManyWithoutProductNestedInput
    combos?: ComboUncheckedUpdateManyWithoutProductsNestedInput
    ComboProducts?: ComboProductsUncheckedUpdateManyWithoutProductNestedInput
    Combo?: ComboUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id?: number
    uuid: string
    name: string
    description?: string | null
    type?: string
    price: number
    free?: boolean
    status?: string
    additionalsMax?: number
    accompanimentsMax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    categoryId: number
    enterpriseId: number
  }

  export type ProductUpdateManyMutationInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    free?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    additionalsMax?: IntFieldUpdateOperationsInput | number
    accompanimentsMax?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    free?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    additionalsMax?: IntFieldUpdateOperationsInput | number
    accompanimentsMax?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categoryId?: IntFieldUpdateOperationsInput | number
    enterpriseId?: IntFieldUpdateOperationsInput | number
  }

  export type AccompanimentCreateInput = {
    uuid: string
    product: ProductCreateNestedOneWithoutAccompanimentsInput
  }

  export type AccompanimentUncheckedCreateInput = {
    id?: number
    uuid: string
    productId: number
  }

  export type AccompanimentUpdateInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    product?: ProductUpdateOneRequiredWithoutAccompanimentsNestedInput
  }

  export type AccompanimentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    productId?: IntFieldUpdateOperationsInput | number
  }

  export type AccompanimentCreateManyInput = {
    id?: number
    uuid: string
    productId: number
  }

  export type AccompanimentUpdateManyMutationInput = {
    uuid?: StringFieldUpdateOperationsInput | string
  }

  export type AccompanimentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    productId?: IntFieldUpdateOperationsInput | number
  }

  export type AdditionalCreateInput = {
    uuid: string
    product: ProductCreateNestedOneWithoutAdditionalsInput
  }

  export type AdditionalUncheckedCreateInput = {
    id?: number
    uuid: string
    productId: number
  }

  export type AdditionalUpdateInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    product?: ProductUpdateOneRequiredWithoutAdditionalsNestedInput
  }

  export type AdditionalUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    productId?: IntFieldUpdateOperationsInput | number
  }

  export type AdditionalCreateManyInput = {
    id?: number
    uuid: string
    productId: number
  }

  export type AdditionalUpdateManyMutationInput = {
    uuid?: StringFieldUpdateOperationsInput | string
  }

  export type AdditionalUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    productId?: IntFieldUpdateOperationsInput | number
  }

  export type OrderCreateInput = {
    uuid: string
    totalPrice: number
    status?: string
    updatedAt?: Date | string
    orderDate?: Date | string
    user: UserCreateNestedOneWithoutOrdersInput
    products?: ProductCreateNestedManyWithoutOrdersInput
    enterprise: EnterpriseCreateNestedOneWithoutOrdersInput
    orderItems?: OrderItemCreateNestedManyWithoutOrderInput
    orderHistories?: OrderHistoryCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateInput = {
    id?: number
    uuid: string
    totalPrice: number
    status?: string
    updatedAt?: Date | string
    orderDate?: Date | string
    userId: number
    enterpriseId: number
    products?: ProductUncheckedCreateNestedManyWithoutOrdersInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    orderHistories?: OrderHistoryUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderUpdateInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    products?: ProductUpdateManyWithoutOrdersNestedInput
    enterprise?: EnterpriseUpdateOneRequiredWithoutOrdersNestedInput
    orderItems?: OrderItemUpdateManyWithoutOrderNestedInput
    orderHistories?: OrderHistoryUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    enterpriseId?: IntFieldUpdateOperationsInput | number
    products?: ProductUncheckedUpdateManyWithoutOrdersNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    orderHistories?: OrderHistoryUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderCreateManyInput = {
    id?: number
    uuid: string
    totalPrice: number
    status?: string
    updatedAt?: Date | string
    orderDate?: Date | string
    userId: number
    enterpriseId: number
  }

  export type OrderUpdateManyMutationInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    enterpriseId?: IntFieldUpdateOperationsInput | number
  }

  export type OrderItemCreateInput = {
    uuid: string
    quantity: number
    price: number
    product: ProductCreateNestedOneWithoutOrderItemsInput
    order: OrderCreateNestedOneWithoutOrderItemsInput
  }

  export type OrderItemUncheckedCreateInput = {
    id?: number
    uuid: string
    quantity: number
    price: number
    productId: number
    orderId: number
  }

  export type OrderItemUpdateInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    product?: ProductUpdateOneRequiredWithoutOrderItemsNestedInput
    order?: OrderUpdateOneRequiredWithoutOrderItemsNestedInput
  }

  export type OrderItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
  }

  export type OrderItemCreateManyInput = {
    id?: number
    uuid: string
    quantity: number
    price: number
    productId: number
    orderId: number
  }

  export type OrderItemUpdateManyMutationInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type OrderItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
  }

  export type OrderHistoryCreateInput = {
    uuid: string
    status: string
    description?: string | null
    createdAt?: Date | string
    order: OrderCreateNestedOneWithoutOrderHistoriesInput
  }

  export type OrderHistoryUncheckedCreateInput = {
    id?: number
    uuid: string
    status: string
    description?: string | null
    orderId: number
    createdAt?: Date | string
  }

  export type OrderHistoryUpdateInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutOrderHistoriesNestedInput
  }

  export type OrderHistoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderHistoryCreateManyInput = {
    id?: number
    uuid: string
    status: string
    description?: string | null
    orderId: number
    createdAt?: Date | string
  }

  export type OrderHistoryUpdateManyMutationInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderHistoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnterpriseCreateInput = {
    uuid: string
    name: string
    responsiblePerson?: string | null
    phoneNumber?: string | null
    email?: string | null
    description?: string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    users?: UserCreateNestedManyWithoutEnterpriseInput
    categories?: CategoryCreateNestedManyWithoutEnterpriseInput
    products?: ProductCreateNestedManyWithoutEnterpriseInput
    configurations?: ConfigurationCreateNestedManyWithoutEnterpriseInput
    orders?: OrderCreateNestedManyWithoutEnterpriseInput
    promotions?: PromotionCreateNestedManyWithoutEnterpriseInput
    combos?: ComboCreateNestedManyWithoutEnterpriseInput
  }

  export type EnterpriseUncheckedCreateInput = {
    id?: number
    uuid: string
    name: string
    responsiblePerson?: string | null
    phoneNumber?: string | null
    email?: string | null
    description?: string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    users?: UserUncheckedCreateNestedManyWithoutEnterpriseInput
    categories?: CategoryUncheckedCreateNestedManyWithoutEnterpriseInput
    products?: ProductUncheckedCreateNestedManyWithoutEnterpriseInput
    configurations?: ConfigurationUncheckedCreateNestedManyWithoutEnterpriseInput
    orders?: OrderUncheckedCreateNestedManyWithoutEnterpriseInput
    promotions?: PromotionUncheckedCreateNestedManyWithoutEnterpriseInput
    combos?: ComboUncheckedCreateNestedManyWithoutEnterpriseInput
  }

  export type EnterpriseUpdateInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    responsiblePerson?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: UserUpdateManyWithoutEnterpriseNestedInput
    categories?: CategoryUpdateManyWithoutEnterpriseNestedInput
    products?: ProductUpdateManyWithoutEnterpriseNestedInput
    configurations?: ConfigurationUpdateManyWithoutEnterpriseNestedInput
    orders?: OrderUpdateManyWithoutEnterpriseNestedInput
    promotions?: PromotionUpdateManyWithoutEnterpriseNestedInput
    combos?: ComboUpdateManyWithoutEnterpriseNestedInput
  }

  export type EnterpriseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    responsiblePerson?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: UserUncheckedUpdateManyWithoutEnterpriseNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutEnterpriseNestedInput
    products?: ProductUncheckedUpdateManyWithoutEnterpriseNestedInput
    configurations?: ConfigurationUncheckedUpdateManyWithoutEnterpriseNestedInput
    orders?: OrderUncheckedUpdateManyWithoutEnterpriseNestedInput
    promotions?: PromotionUncheckedUpdateManyWithoutEnterpriseNestedInput
    combos?: ComboUncheckedUpdateManyWithoutEnterpriseNestedInput
  }

  export type EnterpriseCreateManyInput = {
    id?: number
    uuid: string
    name: string
    responsiblePerson?: string | null
    phoneNumber?: string | null
    email?: string | null
    description?: string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type EnterpriseUpdateManyMutationInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    responsiblePerson?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EnterpriseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    responsiblePerson?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ConfigurationCreateInput = {
    uuid: string
    configKey: string
    configValue: string
    configText?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    enterprise: EnterpriseCreateNestedOneWithoutConfigurationsInput
  }

  export type ConfigurationUncheckedCreateInput = {
    id?: number
    uuid: string
    configKey: string
    configValue: string
    configText?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    enterpriseId: number
  }

  export type ConfigurationUpdateInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    configKey?: StringFieldUpdateOperationsInput | string
    configValue?: StringFieldUpdateOperationsInput | string
    configText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enterprise?: EnterpriseUpdateOneRequiredWithoutConfigurationsNestedInput
  }

  export type ConfigurationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    configKey?: StringFieldUpdateOperationsInput | string
    configValue?: StringFieldUpdateOperationsInput | string
    configText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enterpriseId?: IntFieldUpdateOperationsInput | number
  }

  export type ConfigurationCreateManyInput = {
    id?: number
    uuid: string
    configKey: string
    configValue: string
    configText?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    enterpriseId: number
  }

  export type ConfigurationUpdateManyMutationInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    configKey?: StringFieldUpdateOperationsInput | string
    configValue?: StringFieldUpdateOperationsInput | string
    configText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfigurationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    configKey?: StringFieldUpdateOperationsInput | string
    configValue?: StringFieldUpdateOperationsInput | string
    configText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enterpriseId?: IntFieldUpdateOperationsInput | number
  }

  export type TagCreateInput = {
    uuid: string
    name: string
    textColor: string
    backgroundColor: string
    status?: string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    description?: string | null
    productTags?: ProductTagCreateNestedManyWithoutTagInput
    promotionTags?: PromotionTagCreateNestedManyWithoutTagInput
  }

  export type TagUncheckedCreateInput = {
    id?: number
    uuid: string
    name: string
    textColor: string
    backgroundColor: string
    status?: string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    description?: string | null
    productTags?: ProductTagUncheckedCreateNestedManyWithoutTagInput
    promotionTags?: PromotionTagUncheckedCreateNestedManyWithoutTagInput
  }

  export type TagUpdateInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    textColor?: StringFieldUpdateOperationsInput | string
    backgroundColor?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    productTags?: ProductTagUpdateManyWithoutTagNestedInput
    promotionTags?: PromotionTagUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    textColor?: StringFieldUpdateOperationsInput | string
    backgroundColor?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    productTags?: ProductTagUncheckedUpdateManyWithoutTagNestedInput
    promotionTags?: PromotionTagUncheckedUpdateManyWithoutTagNestedInput
  }

  export type TagCreateManyInput = {
    id?: number
    uuid: string
    name: string
    textColor: string
    backgroundColor: string
    status?: string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    description?: string | null
  }

  export type TagUpdateManyMutationInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    textColor?: StringFieldUpdateOperationsInput | string
    backgroundColor?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TagUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    textColor?: StringFieldUpdateOperationsInput | string
    backgroundColor?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductTagCreateInput = {
    uuid: string
    product: ProductCreateNestedOneWithoutProductTagsInput
    tag: TagCreateNestedOneWithoutProductTagsInput
  }

  export type ProductTagUncheckedCreateInput = {
    id?: number
    uuid: string
    productId: number
    tagId: number
  }

  export type ProductTagUpdateInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    product?: ProductUpdateOneRequiredWithoutProductTagsNestedInput
    tag?: TagUpdateOneRequiredWithoutProductTagsNestedInput
  }

  export type ProductTagUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    productId?: IntFieldUpdateOperationsInput | number
    tagId?: IntFieldUpdateOperationsInput | number
  }

  export type ProductTagCreateManyInput = {
    id?: number
    uuid: string
    productId: number
    tagId: number
  }

  export type ProductTagUpdateManyMutationInput = {
    uuid?: StringFieldUpdateOperationsInput | string
  }

  export type ProductTagUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    productId?: IntFieldUpdateOperationsInput | number
    tagId?: IntFieldUpdateOperationsInput | number
  }

  export type PromotionTagCreateInput = {
    uuid: string
    promotion: PromotionCreateNestedOneWithoutPromotionTagsInput
    tag: TagCreateNestedOneWithoutPromotionTagsInput
  }

  export type PromotionTagUncheckedCreateInput = {
    id?: number
    uuid: string
    promotionId: number
    tagId: number
  }

  export type PromotionTagUpdateInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    promotion?: PromotionUpdateOneRequiredWithoutPromotionTagsNestedInput
    tag?: TagUpdateOneRequiredWithoutPromotionTagsNestedInput
  }

  export type PromotionTagUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    promotionId?: IntFieldUpdateOperationsInput | number
    tagId?: IntFieldUpdateOperationsInput | number
  }

  export type PromotionTagCreateManyInput = {
    id?: number
    uuid: string
    promotionId: number
    tagId: number
  }

  export type PromotionTagUpdateManyMutationInput = {
    uuid?: StringFieldUpdateOperationsInput | string
  }

  export type PromotionTagUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    promotionId?: IntFieldUpdateOperationsInput | number
    tagId?: IntFieldUpdateOperationsInput | number
  }

  export type PromotionCreateInput = {
    uuid: string
    name: string
    description?: string | null
    status: string
    discountRate: number
    startDate: Date | string
    endDate: Date | string
    deletedAt?: Date | string | null
    category: CategoryCreateNestedOneWithoutPromotionsInput
    enterprise: EnterpriseCreateNestedOneWithoutPromotionsInput
    promotionTags?: PromotionTagCreateNestedManyWithoutPromotionInput
  }

  export type PromotionUncheckedCreateInput = {
    id?: number
    uuid: string
    name: string
    description?: string | null
    status: string
    discountRate: number
    startDate: Date | string
    endDate: Date | string
    categoryId: number
    enterpriseId: number
    deletedAt?: Date | string | null
    promotionTags?: PromotionTagUncheckedCreateNestedManyWithoutPromotionInput
  }

  export type PromotionUpdateInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    discountRate?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: CategoryUpdateOneRequiredWithoutPromotionsNestedInput
    enterprise?: EnterpriseUpdateOneRequiredWithoutPromotionsNestedInput
    promotionTags?: PromotionTagUpdateManyWithoutPromotionNestedInput
  }

  export type PromotionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    discountRate?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    categoryId?: IntFieldUpdateOperationsInput | number
    enterpriseId?: IntFieldUpdateOperationsInput | number
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    promotionTags?: PromotionTagUncheckedUpdateManyWithoutPromotionNestedInput
  }

  export type PromotionCreateManyInput = {
    id?: number
    uuid: string
    name: string
    description?: string | null
    status: string
    discountRate: number
    startDate: Date | string
    endDate: Date | string
    categoryId: number
    enterpriseId: number
    deletedAt?: Date | string | null
  }

  export type PromotionUpdateManyMutationInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    discountRate?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PromotionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    discountRate?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    categoryId?: IntFieldUpdateOperationsInput | number
    enterpriseId?: IntFieldUpdateOperationsInput | number
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ComboCreateInput = {
    uuid: string
    name: string
    description?: string | null
    price: number
    status: string
    category: CategoryCreateNestedOneWithoutCombosInput
    enterprise: EnterpriseCreateNestedOneWithoutCombosInput
    products?: ProductCreateNestedManyWithoutCombosInput
    ComboProducts?: ComboProductsCreateNestedManyWithoutComboInput
    Product?: ProductCreateNestedOneWithoutComboInput
  }

  export type ComboUncheckedCreateInput = {
    id?: number
    uuid: string
    name: string
    description?: string | null
    price: number
    status: string
    categoryId: number
    enterpriseId: number
    productId?: number | null
    products?: ProductUncheckedCreateNestedManyWithoutCombosInput
    ComboProducts?: ComboProductsUncheckedCreateNestedManyWithoutComboInput
  }

  export type ComboUpdateInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    category?: CategoryUpdateOneRequiredWithoutCombosNestedInput
    enterprise?: EnterpriseUpdateOneRequiredWithoutCombosNestedInput
    products?: ProductUpdateManyWithoutCombosNestedInput
    ComboProducts?: ComboProductsUpdateManyWithoutComboNestedInput
    Product?: ProductUpdateOneWithoutComboNestedInput
  }

  export type ComboUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    categoryId?: IntFieldUpdateOperationsInput | number
    enterpriseId?: IntFieldUpdateOperationsInput | number
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    products?: ProductUncheckedUpdateManyWithoutCombosNestedInput
    ComboProducts?: ComboProductsUncheckedUpdateManyWithoutComboNestedInput
  }

  export type ComboCreateManyInput = {
    id?: number
    uuid: string
    name: string
    description?: string | null
    price: number
    status: string
    categoryId: number
    enterpriseId: number
    productId?: number | null
  }

  export type ComboUpdateManyMutationInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
  }

  export type ComboUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    categoryId?: IntFieldUpdateOperationsInput | number
    enterpriseId?: IntFieldUpdateOperationsInput | number
    productId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ComboProductsCreateInput = {
    uuid: string
    combo: ComboCreateNestedOneWithoutComboProductsInput
    product: ProductCreateNestedOneWithoutComboProductsInput
  }

  export type ComboProductsUncheckedCreateInput = {
    id?: number
    uuid: string
    comboId: number
    productId: number
  }

  export type ComboProductsUpdateInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    combo?: ComboUpdateOneRequiredWithoutComboProductsNestedInput
    product?: ProductUpdateOneRequiredWithoutComboProductsNestedInput
  }

  export type ComboProductsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    comboId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
  }

  export type ComboProductsCreateManyInput = {
    id?: number
    uuid: string
    comboId: number
    productId: number
  }

  export type ComboProductsUpdateManyMutationInput = {
    uuid?: StringFieldUpdateOperationsInput | string
  }

  export type ComboProductsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    comboId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type OrderListRelationFilter = {
    every?: OrderWhereInput
    some?: OrderWhereInput
    none?: OrderWhereInput
  }

  export type EnterpriseNullableRelationFilter = {
    is?: EnterpriseWhereInput | null
    isNot?: EnterpriseWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type OrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    email?: SortOrder
    nickname?: SortOrder
    role?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    enterpriseId?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
    enterpriseId?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    email?: SortOrder
    nickname?: SortOrder
    role?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    enterpriseId?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    email?: SortOrder
    nickname?: SortOrder
    role?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    enterpriseId?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
    enterpriseId?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type ProductListRelationFilter = {
    every?: ProductWhereInput
    some?: ProductWhereInput
    none?: ProductWhereInput
  }

  export type EnterpriseRelationFilter = {
    is?: EnterpriseWhereInput
    isNot?: EnterpriseWhereInput
  }

  export type PromotionListRelationFilter = {
    every?: PromotionWhereInput
    some?: PromotionWhereInput
    none?: PromotionWhereInput
  }

  export type ComboListRelationFilter = {
    every?: ComboWhereInput
    some?: ComboWhereInput
    none?: ComboWhereInput
  }

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PromotionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ComboOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    enterpriseId?: SortOrder
  }

  export type CategoryAvgOrderByAggregateInput = {
    id?: SortOrder
    enterpriseId?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    enterpriseId?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    enterpriseId?: SortOrder
  }

  export type CategorySumOrderByAggregateInput = {
    id?: SortOrder
    enterpriseId?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type CategoryRelationFilter = {
    is?: CategoryWhereInput
    isNot?: CategoryWhereInput
  }

  export type AccompanimentListRelationFilter = {
    every?: AccompanimentWhereInput
    some?: AccompanimentWhereInput
    none?: AccompanimentWhereInput
  }

  export type AdditionalListRelationFilter = {
    every?: AdditionalWhereInput
    some?: AdditionalWhereInput
    none?: AdditionalWhereInput
  }

  export type OrderItemListRelationFilter = {
    every?: OrderItemWhereInput
    some?: OrderItemWhereInput
    none?: OrderItemWhereInput
  }

  export type ProductTagListRelationFilter = {
    every?: ProductTagWhereInput
    some?: ProductTagWhereInput
    none?: ProductTagWhereInput
  }

  export type ComboProductsListRelationFilter = {
    every?: ComboProductsWhereInput
    some?: ComboProductsWhereInput
    none?: ComboProductsWhereInput
  }

  export type AccompanimentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdditionalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ComboProductsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    price?: SortOrder
    free?: SortOrder
    status?: SortOrder
    additionalsMax?: SortOrder
    accompanimentsMax?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    categoryId?: SortOrder
    enterpriseId?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    additionalsMax?: SortOrder
    accompanimentsMax?: SortOrder
    categoryId?: SortOrder
    enterpriseId?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    price?: SortOrder
    free?: SortOrder
    status?: SortOrder
    additionalsMax?: SortOrder
    accompanimentsMax?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    categoryId?: SortOrder
    enterpriseId?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    price?: SortOrder
    free?: SortOrder
    status?: SortOrder
    additionalsMax?: SortOrder
    accompanimentsMax?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    categoryId?: SortOrder
    enterpriseId?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    additionalsMax?: SortOrder
    accompanimentsMax?: SortOrder
    categoryId?: SortOrder
    enterpriseId?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type ProductRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type AccompanimentCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    productId?: SortOrder
  }

  export type AccompanimentAvgOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
  }

  export type AccompanimentMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    productId?: SortOrder
  }

  export type AccompanimentMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    productId?: SortOrder
  }

  export type AccompanimentSumOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
  }

  export type AdditionalCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    productId?: SortOrder
  }

  export type AdditionalAvgOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
  }

  export type AdditionalMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    productId?: SortOrder
  }

  export type AdditionalMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    productId?: SortOrder
  }

  export type AdditionalSumOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type OrderHistoryListRelationFilter = {
    every?: OrderHistoryWhereInput
    some?: OrderHistoryWhereInput
    none?: OrderHistoryWhereInput
  }

  export type OrderHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    totalPrice?: SortOrder
    status?: SortOrder
    updatedAt?: SortOrder
    orderDate?: SortOrder
    userId?: SortOrder
    enterpriseId?: SortOrder
  }

  export type OrderAvgOrderByAggregateInput = {
    id?: SortOrder
    totalPrice?: SortOrder
    userId?: SortOrder
    enterpriseId?: SortOrder
  }

  export type OrderMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    totalPrice?: SortOrder
    status?: SortOrder
    updatedAt?: SortOrder
    orderDate?: SortOrder
    userId?: SortOrder
    enterpriseId?: SortOrder
  }

  export type OrderMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    totalPrice?: SortOrder
    status?: SortOrder
    updatedAt?: SortOrder
    orderDate?: SortOrder
    userId?: SortOrder
    enterpriseId?: SortOrder
  }

  export type OrderSumOrderByAggregateInput = {
    id?: SortOrder
    totalPrice?: SortOrder
    userId?: SortOrder
    enterpriseId?: SortOrder
  }

  export type OrderRelationFilter = {
    is?: OrderWhereInput
    isNot?: OrderWhereInput
  }

  export type OrderItemCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    productId?: SortOrder
    orderId?: SortOrder
  }

  export type OrderItemAvgOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    productId?: SortOrder
    orderId?: SortOrder
  }

  export type OrderItemMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    productId?: SortOrder
    orderId?: SortOrder
  }

  export type OrderItemMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    productId?: SortOrder
    orderId?: SortOrder
  }

  export type OrderItemSumOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    productId?: SortOrder
    orderId?: SortOrder
  }

  export type OrderHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    status?: SortOrder
    description?: SortOrder
    orderId?: SortOrder
    createdAt?: SortOrder
  }

  export type OrderHistoryAvgOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
  }

  export type OrderHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    status?: SortOrder
    description?: SortOrder
    orderId?: SortOrder
    createdAt?: SortOrder
  }

  export type OrderHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    status?: SortOrder
    description?: SortOrder
    orderId?: SortOrder
    createdAt?: SortOrder
  }

  export type OrderHistorySumOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type CategoryListRelationFilter = {
    every?: CategoryWhereInput
    some?: CategoryWhereInput
    none?: CategoryWhereInput
  }

  export type ConfigurationListRelationFilter = {
    every?: ConfigurationWhereInput
    some?: ConfigurationWhereInput
    none?: ConfigurationWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConfigurationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EnterpriseCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    responsiblePerson?: SortOrder
    phoneNumber?: SortOrder
    email?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type EnterpriseAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnterpriseMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    responsiblePerson?: SortOrder
    phoneNumber?: SortOrder
    email?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type EnterpriseMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    responsiblePerson?: SortOrder
    phoneNumber?: SortOrder
    email?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type EnterpriseSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ConfigurationCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    configKey?: SortOrder
    configValue?: SortOrder
    configText?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    enterpriseId?: SortOrder
  }

  export type ConfigurationAvgOrderByAggregateInput = {
    id?: SortOrder
    enterpriseId?: SortOrder
  }

  export type ConfigurationMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    configKey?: SortOrder
    configValue?: SortOrder
    configText?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    enterpriseId?: SortOrder
  }

  export type ConfigurationMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    configKey?: SortOrder
    configValue?: SortOrder
    configText?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    enterpriseId?: SortOrder
  }

  export type ConfigurationSumOrderByAggregateInput = {
    id?: SortOrder
    enterpriseId?: SortOrder
  }

  export type PromotionTagListRelationFilter = {
    every?: PromotionTagWhereInput
    some?: PromotionTagWhereInput
    none?: PromotionTagWhereInput
  }

  export type PromotionTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TagCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    textColor?: SortOrder
    backgroundColor?: SortOrder
    status?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    description?: SortOrder
  }

  export type TagAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TagMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    textColor?: SortOrder
    backgroundColor?: SortOrder
    status?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    description?: SortOrder
  }

  export type TagMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    textColor?: SortOrder
    backgroundColor?: SortOrder
    status?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    description?: SortOrder
  }

  export type TagSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TagRelationFilter = {
    is?: TagWhereInput
    isNot?: TagWhereInput
  }

  export type ProductTagCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    productId?: SortOrder
    tagId?: SortOrder
  }

  export type ProductTagAvgOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    tagId?: SortOrder
  }

  export type ProductTagMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    productId?: SortOrder
    tagId?: SortOrder
  }

  export type ProductTagMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    productId?: SortOrder
    tagId?: SortOrder
  }

  export type ProductTagSumOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    tagId?: SortOrder
  }

  export type PromotionRelationFilter = {
    is?: PromotionWhereInput
    isNot?: PromotionWhereInput
  }

  export type PromotionTagCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    promotionId?: SortOrder
    tagId?: SortOrder
  }

  export type PromotionTagAvgOrderByAggregateInput = {
    id?: SortOrder
    promotionId?: SortOrder
    tagId?: SortOrder
  }

  export type PromotionTagMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    promotionId?: SortOrder
    tagId?: SortOrder
  }

  export type PromotionTagMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    promotionId?: SortOrder
    tagId?: SortOrder
  }

  export type PromotionTagSumOrderByAggregateInput = {
    id?: SortOrder
    promotionId?: SortOrder
    tagId?: SortOrder
  }

  export type PromotionCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    discountRate?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    categoryId?: SortOrder
    enterpriseId?: SortOrder
    deletedAt?: SortOrder
  }

  export type PromotionAvgOrderByAggregateInput = {
    id?: SortOrder
    discountRate?: SortOrder
    categoryId?: SortOrder
    enterpriseId?: SortOrder
  }

  export type PromotionMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    discountRate?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    categoryId?: SortOrder
    enterpriseId?: SortOrder
    deletedAt?: SortOrder
  }

  export type PromotionMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    discountRate?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    categoryId?: SortOrder
    enterpriseId?: SortOrder
    deletedAt?: SortOrder
  }

  export type PromotionSumOrderByAggregateInput = {
    id?: SortOrder
    discountRate?: SortOrder
    categoryId?: SortOrder
    enterpriseId?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type ProductNullableRelationFilter = {
    is?: ProductWhereInput | null
    isNot?: ProductWhereInput | null
  }

  export type ComboCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    status?: SortOrder
    categoryId?: SortOrder
    enterpriseId?: SortOrder
    productId?: SortOrder
  }

  export type ComboAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    categoryId?: SortOrder
    enterpriseId?: SortOrder
    productId?: SortOrder
  }

  export type ComboMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    status?: SortOrder
    categoryId?: SortOrder
    enterpriseId?: SortOrder
    productId?: SortOrder
  }

  export type ComboMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    status?: SortOrder
    categoryId?: SortOrder
    enterpriseId?: SortOrder
    productId?: SortOrder
  }

  export type ComboSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    categoryId?: SortOrder
    enterpriseId?: SortOrder
    productId?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type ComboRelationFilter = {
    is?: ComboWhereInput
    isNot?: ComboWhereInput
  }

  export type ComboProductsCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    comboId?: SortOrder
    productId?: SortOrder
  }

  export type ComboProductsAvgOrderByAggregateInput = {
    id?: SortOrder
    comboId?: SortOrder
    productId?: SortOrder
  }

  export type ComboProductsMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    comboId?: SortOrder
    productId?: SortOrder
  }

  export type ComboProductsMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    comboId?: SortOrder
    productId?: SortOrder
  }

  export type ComboProductsSumOrderByAggregateInput = {
    id?: SortOrder
    comboId?: SortOrder
    productId?: SortOrder
  }

  export type OrderCreateNestedManyWithoutUserInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type EnterpriseCreateNestedOneWithoutUsersInput = {
    create?: XOR<EnterpriseCreateWithoutUsersInput, EnterpriseUncheckedCreateWithoutUsersInput>
    connectOrCreate?: EnterpriseCreateOrConnectWithoutUsersInput
    connect?: EnterpriseWhereUniqueInput
  }

  export type OrderUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type OrderUpdateManyWithoutUserNestedInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutUserInput | OrderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutUserInput | OrderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutUserInput | OrderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type EnterpriseUpdateOneWithoutUsersNestedInput = {
    create?: XOR<EnterpriseCreateWithoutUsersInput, EnterpriseUncheckedCreateWithoutUsersInput>
    connectOrCreate?: EnterpriseCreateOrConnectWithoutUsersInput
    upsert?: EnterpriseUpsertWithoutUsersInput
    disconnect?: EnterpriseWhereInput | boolean
    delete?: EnterpriseWhereInput | boolean
    connect?: EnterpriseWhereUniqueInput
    update?: XOR<XOR<EnterpriseUpdateToOneWithWhereWithoutUsersInput, EnterpriseUpdateWithoutUsersInput>, EnterpriseUncheckedUpdateWithoutUsersInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type OrderUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutUserInput | OrderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutUserInput | OrderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutUserInput | OrderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type ProductCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type EnterpriseCreateNestedOneWithoutCategoriesInput = {
    create?: XOR<EnterpriseCreateWithoutCategoriesInput, EnterpriseUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: EnterpriseCreateOrConnectWithoutCategoriesInput
    connect?: EnterpriseWhereUniqueInput
  }

  export type PromotionCreateNestedManyWithoutCategoryInput = {
    create?: XOR<PromotionCreateWithoutCategoryInput, PromotionUncheckedCreateWithoutCategoryInput> | PromotionCreateWithoutCategoryInput[] | PromotionUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: PromotionCreateOrConnectWithoutCategoryInput | PromotionCreateOrConnectWithoutCategoryInput[]
    createMany?: PromotionCreateManyCategoryInputEnvelope
    connect?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
  }

  export type ComboCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ComboCreateWithoutCategoryInput, ComboUncheckedCreateWithoutCategoryInput> | ComboCreateWithoutCategoryInput[] | ComboUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ComboCreateOrConnectWithoutCategoryInput | ComboCreateOrConnectWithoutCategoryInput[]
    createMany?: ComboCreateManyCategoryInputEnvelope
    connect?: ComboWhereUniqueInput | ComboWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type PromotionUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<PromotionCreateWithoutCategoryInput, PromotionUncheckedCreateWithoutCategoryInput> | PromotionCreateWithoutCategoryInput[] | PromotionUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: PromotionCreateOrConnectWithoutCategoryInput | PromotionCreateOrConnectWithoutCategoryInput[]
    createMany?: PromotionCreateManyCategoryInputEnvelope
    connect?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
  }

  export type ComboUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ComboCreateWithoutCategoryInput, ComboUncheckedCreateWithoutCategoryInput> | ComboCreateWithoutCategoryInput[] | ComboUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ComboCreateOrConnectWithoutCategoryInput | ComboCreateOrConnectWithoutCategoryInput[]
    createMany?: ComboCreateManyCategoryInputEnvelope
    connect?: ComboWhereUniqueInput | ComboWhereUniqueInput[]
  }

  export type ProductUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutCategoryInput | ProductUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutCategoryInput | ProductUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutCategoryInput | ProductUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type EnterpriseUpdateOneRequiredWithoutCategoriesNestedInput = {
    create?: XOR<EnterpriseCreateWithoutCategoriesInput, EnterpriseUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: EnterpriseCreateOrConnectWithoutCategoriesInput
    upsert?: EnterpriseUpsertWithoutCategoriesInput
    connect?: EnterpriseWhereUniqueInput
    update?: XOR<XOR<EnterpriseUpdateToOneWithWhereWithoutCategoriesInput, EnterpriseUpdateWithoutCategoriesInput>, EnterpriseUncheckedUpdateWithoutCategoriesInput>
  }

  export type PromotionUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<PromotionCreateWithoutCategoryInput, PromotionUncheckedCreateWithoutCategoryInput> | PromotionCreateWithoutCategoryInput[] | PromotionUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: PromotionCreateOrConnectWithoutCategoryInput | PromotionCreateOrConnectWithoutCategoryInput[]
    upsert?: PromotionUpsertWithWhereUniqueWithoutCategoryInput | PromotionUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: PromotionCreateManyCategoryInputEnvelope
    set?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
    disconnect?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
    delete?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
    connect?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
    update?: PromotionUpdateWithWhereUniqueWithoutCategoryInput | PromotionUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: PromotionUpdateManyWithWhereWithoutCategoryInput | PromotionUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: PromotionScalarWhereInput | PromotionScalarWhereInput[]
  }

  export type ComboUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ComboCreateWithoutCategoryInput, ComboUncheckedCreateWithoutCategoryInput> | ComboCreateWithoutCategoryInput[] | ComboUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ComboCreateOrConnectWithoutCategoryInput | ComboCreateOrConnectWithoutCategoryInput[]
    upsert?: ComboUpsertWithWhereUniqueWithoutCategoryInput | ComboUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ComboCreateManyCategoryInputEnvelope
    set?: ComboWhereUniqueInput | ComboWhereUniqueInput[]
    disconnect?: ComboWhereUniqueInput | ComboWhereUniqueInput[]
    delete?: ComboWhereUniqueInput | ComboWhereUniqueInput[]
    connect?: ComboWhereUniqueInput | ComboWhereUniqueInput[]
    update?: ComboUpdateWithWhereUniqueWithoutCategoryInput | ComboUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ComboUpdateManyWithWhereWithoutCategoryInput | ComboUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ComboScalarWhereInput | ComboScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutCategoryInput | ProductUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutCategoryInput | ProductUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutCategoryInput | ProductUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type PromotionUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<PromotionCreateWithoutCategoryInput, PromotionUncheckedCreateWithoutCategoryInput> | PromotionCreateWithoutCategoryInput[] | PromotionUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: PromotionCreateOrConnectWithoutCategoryInput | PromotionCreateOrConnectWithoutCategoryInput[]
    upsert?: PromotionUpsertWithWhereUniqueWithoutCategoryInput | PromotionUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: PromotionCreateManyCategoryInputEnvelope
    set?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
    disconnect?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
    delete?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
    connect?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
    update?: PromotionUpdateWithWhereUniqueWithoutCategoryInput | PromotionUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: PromotionUpdateManyWithWhereWithoutCategoryInput | PromotionUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: PromotionScalarWhereInput | PromotionScalarWhereInput[]
  }

  export type ComboUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ComboCreateWithoutCategoryInput, ComboUncheckedCreateWithoutCategoryInput> | ComboCreateWithoutCategoryInput[] | ComboUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ComboCreateOrConnectWithoutCategoryInput | ComboCreateOrConnectWithoutCategoryInput[]
    upsert?: ComboUpsertWithWhereUniqueWithoutCategoryInput | ComboUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ComboCreateManyCategoryInputEnvelope
    set?: ComboWhereUniqueInput | ComboWhereUniqueInput[]
    disconnect?: ComboWhereUniqueInput | ComboWhereUniqueInput[]
    delete?: ComboWhereUniqueInput | ComboWhereUniqueInput[]
    connect?: ComboWhereUniqueInput | ComboWhereUniqueInput[]
    update?: ComboUpdateWithWhereUniqueWithoutCategoryInput | ComboUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ComboUpdateManyWithWhereWithoutCategoryInput | ComboUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ComboScalarWhereInput | ComboScalarWhereInput[]
  }

  export type CategoryCreateNestedOneWithoutProductsInput = {
    create?: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutProductsInput
    connect?: CategoryWhereUniqueInput
  }

  export type EnterpriseCreateNestedOneWithoutProductsInput = {
    create?: XOR<EnterpriseCreateWithoutProductsInput, EnterpriseUncheckedCreateWithoutProductsInput>
    connectOrCreate?: EnterpriseCreateOrConnectWithoutProductsInput
    connect?: EnterpriseWhereUniqueInput
  }

  export type AccompanimentCreateNestedManyWithoutProductInput = {
    create?: XOR<AccompanimentCreateWithoutProductInput, AccompanimentUncheckedCreateWithoutProductInput> | AccompanimentCreateWithoutProductInput[] | AccompanimentUncheckedCreateWithoutProductInput[]
    connectOrCreate?: AccompanimentCreateOrConnectWithoutProductInput | AccompanimentCreateOrConnectWithoutProductInput[]
    createMany?: AccompanimentCreateManyProductInputEnvelope
    connect?: AccompanimentWhereUniqueInput | AccompanimentWhereUniqueInput[]
  }

  export type AdditionalCreateNestedManyWithoutProductInput = {
    create?: XOR<AdditionalCreateWithoutProductInput, AdditionalUncheckedCreateWithoutProductInput> | AdditionalCreateWithoutProductInput[] | AdditionalUncheckedCreateWithoutProductInput[]
    connectOrCreate?: AdditionalCreateOrConnectWithoutProductInput | AdditionalCreateOrConnectWithoutProductInput[]
    createMany?: AdditionalCreateManyProductInputEnvelope
    connect?: AdditionalWhereUniqueInput | AdditionalWhereUniqueInput[]
  }

  export type OrderCreateNestedManyWithoutProductsInput = {
    create?: XOR<OrderCreateWithoutProductsInput, OrderUncheckedCreateWithoutProductsInput> | OrderCreateWithoutProductsInput[] | OrderUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutProductsInput | OrderCreateOrConnectWithoutProductsInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type OrderItemCreateNestedManyWithoutProductInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type ProductTagCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductTagCreateWithoutProductInput, ProductTagUncheckedCreateWithoutProductInput> | ProductTagCreateWithoutProductInput[] | ProductTagUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductTagCreateOrConnectWithoutProductInput | ProductTagCreateOrConnectWithoutProductInput[]
    createMany?: ProductTagCreateManyProductInputEnvelope
    connect?: ProductTagWhereUniqueInput | ProductTagWhereUniqueInput[]
  }

  export type ComboCreateNestedManyWithoutProductsInput = {
    create?: XOR<ComboCreateWithoutProductsInput, ComboUncheckedCreateWithoutProductsInput> | ComboCreateWithoutProductsInput[] | ComboUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: ComboCreateOrConnectWithoutProductsInput | ComboCreateOrConnectWithoutProductsInput[]
    connect?: ComboWhereUniqueInput | ComboWhereUniqueInput[]
  }

  export type ComboProductsCreateNestedManyWithoutProductInput = {
    create?: XOR<ComboProductsCreateWithoutProductInput, ComboProductsUncheckedCreateWithoutProductInput> | ComboProductsCreateWithoutProductInput[] | ComboProductsUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ComboProductsCreateOrConnectWithoutProductInput | ComboProductsCreateOrConnectWithoutProductInput[]
    createMany?: ComboProductsCreateManyProductInputEnvelope
    connect?: ComboProductsWhereUniqueInput | ComboProductsWhereUniqueInput[]
  }

  export type ComboCreateNestedManyWithoutProductInput = {
    create?: XOR<ComboCreateWithoutProductInput, ComboUncheckedCreateWithoutProductInput> | ComboCreateWithoutProductInput[] | ComboUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ComboCreateOrConnectWithoutProductInput | ComboCreateOrConnectWithoutProductInput[]
    createMany?: ComboCreateManyProductInputEnvelope
    connect?: ComboWhereUniqueInput | ComboWhereUniqueInput[]
  }

  export type AccompanimentUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<AccompanimentCreateWithoutProductInput, AccompanimentUncheckedCreateWithoutProductInput> | AccompanimentCreateWithoutProductInput[] | AccompanimentUncheckedCreateWithoutProductInput[]
    connectOrCreate?: AccompanimentCreateOrConnectWithoutProductInput | AccompanimentCreateOrConnectWithoutProductInput[]
    createMany?: AccompanimentCreateManyProductInputEnvelope
    connect?: AccompanimentWhereUniqueInput | AccompanimentWhereUniqueInput[]
  }

  export type AdditionalUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<AdditionalCreateWithoutProductInput, AdditionalUncheckedCreateWithoutProductInput> | AdditionalCreateWithoutProductInput[] | AdditionalUncheckedCreateWithoutProductInput[]
    connectOrCreate?: AdditionalCreateOrConnectWithoutProductInput | AdditionalCreateOrConnectWithoutProductInput[]
    createMany?: AdditionalCreateManyProductInputEnvelope
    connect?: AdditionalWhereUniqueInput | AdditionalWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutProductsInput = {
    create?: XOR<OrderCreateWithoutProductsInput, OrderUncheckedCreateWithoutProductsInput> | OrderCreateWithoutProductsInput[] | OrderUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutProductsInput | OrderCreateOrConnectWithoutProductsInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type OrderItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type ProductTagUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductTagCreateWithoutProductInput, ProductTagUncheckedCreateWithoutProductInput> | ProductTagCreateWithoutProductInput[] | ProductTagUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductTagCreateOrConnectWithoutProductInput | ProductTagCreateOrConnectWithoutProductInput[]
    createMany?: ProductTagCreateManyProductInputEnvelope
    connect?: ProductTagWhereUniqueInput | ProductTagWhereUniqueInput[]
  }

  export type ComboUncheckedCreateNestedManyWithoutProductsInput = {
    create?: XOR<ComboCreateWithoutProductsInput, ComboUncheckedCreateWithoutProductsInput> | ComboCreateWithoutProductsInput[] | ComboUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: ComboCreateOrConnectWithoutProductsInput | ComboCreateOrConnectWithoutProductsInput[]
    connect?: ComboWhereUniqueInput | ComboWhereUniqueInput[]
  }

  export type ComboProductsUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ComboProductsCreateWithoutProductInput, ComboProductsUncheckedCreateWithoutProductInput> | ComboProductsCreateWithoutProductInput[] | ComboProductsUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ComboProductsCreateOrConnectWithoutProductInput | ComboProductsCreateOrConnectWithoutProductInput[]
    createMany?: ComboProductsCreateManyProductInputEnvelope
    connect?: ComboProductsWhereUniqueInput | ComboProductsWhereUniqueInput[]
  }

  export type ComboUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ComboCreateWithoutProductInput, ComboUncheckedCreateWithoutProductInput> | ComboCreateWithoutProductInput[] | ComboUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ComboCreateOrConnectWithoutProductInput | ComboCreateOrConnectWithoutProductInput[]
    createMany?: ComboCreateManyProductInputEnvelope
    connect?: ComboWhereUniqueInput | ComboWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type CategoryUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutProductsInput
    upsert?: CategoryUpsertWithoutProductsInput
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutProductsInput, CategoryUpdateWithoutProductsInput>, CategoryUncheckedUpdateWithoutProductsInput>
  }

  export type EnterpriseUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<EnterpriseCreateWithoutProductsInput, EnterpriseUncheckedCreateWithoutProductsInput>
    connectOrCreate?: EnterpriseCreateOrConnectWithoutProductsInput
    upsert?: EnterpriseUpsertWithoutProductsInput
    connect?: EnterpriseWhereUniqueInput
    update?: XOR<XOR<EnterpriseUpdateToOneWithWhereWithoutProductsInput, EnterpriseUpdateWithoutProductsInput>, EnterpriseUncheckedUpdateWithoutProductsInput>
  }

  export type AccompanimentUpdateManyWithoutProductNestedInput = {
    create?: XOR<AccompanimentCreateWithoutProductInput, AccompanimentUncheckedCreateWithoutProductInput> | AccompanimentCreateWithoutProductInput[] | AccompanimentUncheckedCreateWithoutProductInput[]
    connectOrCreate?: AccompanimentCreateOrConnectWithoutProductInput | AccompanimentCreateOrConnectWithoutProductInput[]
    upsert?: AccompanimentUpsertWithWhereUniqueWithoutProductInput | AccompanimentUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: AccompanimentCreateManyProductInputEnvelope
    set?: AccompanimentWhereUniqueInput | AccompanimentWhereUniqueInput[]
    disconnect?: AccompanimentWhereUniqueInput | AccompanimentWhereUniqueInput[]
    delete?: AccompanimentWhereUniqueInput | AccompanimentWhereUniqueInput[]
    connect?: AccompanimentWhereUniqueInput | AccompanimentWhereUniqueInput[]
    update?: AccompanimentUpdateWithWhereUniqueWithoutProductInput | AccompanimentUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: AccompanimentUpdateManyWithWhereWithoutProductInput | AccompanimentUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: AccompanimentScalarWhereInput | AccompanimentScalarWhereInput[]
  }

  export type AdditionalUpdateManyWithoutProductNestedInput = {
    create?: XOR<AdditionalCreateWithoutProductInput, AdditionalUncheckedCreateWithoutProductInput> | AdditionalCreateWithoutProductInput[] | AdditionalUncheckedCreateWithoutProductInput[]
    connectOrCreate?: AdditionalCreateOrConnectWithoutProductInput | AdditionalCreateOrConnectWithoutProductInput[]
    upsert?: AdditionalUpsertWithWhereUniqueWithoutProductInput | AdditionalUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: AdditionalCreateManyProductInputEnvelope
    set?: AdditionalWhereUniqueInput | AdditionalWhereUniqueInput[]
    disconnect?: AdditionalWhereUniqueInput | AdditionalWhereUniqueInput[]
    delete?: AdditionalWhereUniqueInput | AdditionalWhereUniqueInput[]
    connect?: AdditionalWhereUniqueInput | AdditionalWhereUniqueInput[]
    update?: AdditionalUpdateWithWhereUniqueWithoutProductInput | AdditionalUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: AdditionalUpdateManyWithWhereWithoutProductInput | AdditionalUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: AdditionalScalarWhereInput | AdditionalScalarWhereInput[]
  }

  export type OrderUpdateManyWithoutProductsNestedInput = {
    create?: XOR<OrderCreateWithoutProductsInput, OrderUncheckedCreateWithoutProductsInput> | OrderCreateWithoutProductsInput[] | OrderUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutProductsInput | OrderCreateOrConnectWithoutProductsInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutProductsInput | OrderUpsertWithWhereUniqueWithoutProductsInput[]
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutProductsInput | OrderUpdateWithWhereUniqueWithoutProductsInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutProductsInput | OrderUpdateManyWithWhereWithoutProductsInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type OrderItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutProductInput | OrderItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutProductInput | OrderItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutProductInput | OrderItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type ProductTagUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductTagCreateWithoutProductInput, ProductTagUncheckedCreateWithoutProductInput> | ProductTagCreateWithoutProductInput[] | ProductTagUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductTagCreateOrConnectWithoutProductInput | ProductTagCreateOrConnectWithoutProductInput[]
    upsert?: ProductTagUpsertWithWhereUniqueWithoutProductInput | ProductTagUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductTagCreateManyProductInputEnvelope
    set?: ProductTagWhereUniqueInput | ProductTagWhereUniqueInput[]
    disconnect?: ProductTagWhereUniqueInput | ProductTagWhereUniqueInput[]
    delete?: ProductTagWhereUniqueInput | ProductTagWhereUniqueInput[]
    connect?: ProductTagWhereUniqueInput | ProductTagWhereUniqueInput[]
    update?: ProductTagUpdateWithWhereUniqueWithoutProductInput | ProductTagUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductTagUpdateManyWithWhereWithoutProductInput | ProductTagUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductTagScalarWhereInput | ProductTagScalarWhereInput[]
  }

  export type ComboUpdateManyWithoutProductsNestedInput = {
    create?: XOR<ComboCreateWithoutProductsInput, ComboUncheckedCreateWithoutProductsInput> | ComboCreateWithoutProductsInput[] | ComboUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: ComboCreateOrConnectWithoutProductsInput | ComboCreateOrConnectWithoutProductsInput[]
    upsert?: ComboUpsertWithWhereUniqueWithoutProductsInput | ComboUpsertWithWhereUniqueWithoutProductsInput[]
    set?: ComboWhereUniqueInput | ComboWhereUniqueInput[]
    disconnect?: ComboWhereUniqueInput | ComboWhereUniqueInput[]
    delete?: ComboWhereUniqueInput | ComboWhereUniqueInput[]
    connect?: ComboWhereUniqueInput | ComboWhereUniqueInput[]
    update?: ComboUpdateWithWhereUniqueWithoutProductsInput | ComboUpdateWithWhereUniqueWithoutProductsInput[]
    updateMany?: ComboUpdateManyWithWhereWithoutProductsInput | ComboUpdateManyWithWhereWithoutProductsInput[]
    deleteMany?: ComboScalarWhereInput | ComboScalarWhereInput[]
  }

  export type ComboProductsUpdateManyWithoutProductNestedInput = {
    create?: XOR<ComboProductsCreateWithoutProductInput, ComboProductsUncheckedCreateWithoutProductInput> | ComboProductsCreateWithoutProductInput[] | ComboProductsUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ComboProductsCreateOrConnectWithoutProductInput | ComboProductsCreateOrConnectWithoutProductInput[]
    upsert?: ComboProductsUpsertWithWhereUniqueWithoutProductInput | ComboProductsUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ComboProductsCreateManyProductInputEnvelope
    set?: ComboProductsWhereUniqueInput | ComboProductsWhereUniqueInput[]
    disconnect?: ComboProductsWhereUniqueInput | ComboProductsWhereUniqueInput[]
    delete?: ComboProductsWhereUniqueInput | ComboProductsWhereUniqueInput[]
    connect?: ComboProductsWhereUniqueInput | ComboProductsWhereUniqueInput[]
    update?: ComboProductsUpdateWithWhereUniqueWithoutProductInput | ComboProductsUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ComboProductsUpdateManyWithWhereWithoutProductInput | ComboProductsUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ComboProductsScalarWhereInput | ComboProductsScalarWhereInput[]
  }

  export type ComboUpdateManyWithoutProductNestedInput = {
    create?: XOR<ComboCreateWithoutProductInput, ComboUncheckedCreateWithoutProductInput> | ComboCreateWithoutProductInput[] | ComboUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ComboCreateOrConnectWithoutProductInput | ComboCreateOrConnectWithoutProductInput[]
    upsert?: ComboUpsertWithWhereUniqueWithoutProductInput | ComboUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ComboCreateManyProductInputEnvelope
    set?: ComboWhereUniqueInput | ComboWhereUniqueInput[]
    disconnect?: ComboWhereUniqueInput | ComboWhereUniqueInput[]
    delete?: ComboWhereUniqueInput | ComboWhereUniqueInput[]
    connect?: ComboWhereUniqueInput | ComboWhereUniqueInput[]
    update?: ComboUpdateWithWhereUniqueWithoutProductInput | ComboUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ComboUpdateManyWithWhereWithoutProductInput | ComboUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ComboScalarWhereInput | ComboScalarWhereInput[]
  }

  export type AccompanimentUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<AccompanimentCreateWithoutProductInput, AccompanimentUncheckedCreateWithoutProductInput> | AccompanimentCreateWithoutProductInput[] | AccompanimentUncheckedCreateWithoutProductInput[]
    connectOrCreate?: AccompanimentCreateOrConnectWithoutProductInput | AccompanimentCreateOrConnectWithoutProductInput[]
    upsert?: AccompanimentUpsertWithWhereUniqueWithoutProductInput | AccompanimentUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: AccompanimentCreateManyProductInputEnvelope
    set?: AccompanimentWhereUniqueInput | AccompanimentWhereUniqueInput[]
    disconnect?: AccompanimentWhereUniqueInput | AccompanimentWhereUniqueInput[]
    delete?: AccompanimentWhereUniqueInput | AccompanimentWhereUniqueInput[]
    connect?: AccompanimentWhereUniqueInput | AccompanimentWhereUniqueInput[]
    update?: AccompanimentUpdateWithWhereUniqueWithoutProductInput | AccompanimentUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: AccompanimentUpdateManyWithWhereWithoutProductInput | AccompanimentUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: AccompanimentScalarWhereInput | AccompanimentScalarWhereInput[]
  }

  export type AdditionalUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<AdditionalCreateWithoutProductInput, AdditionalUncheckedCreateWithoutProductInput> | AdditionalCreateWithoutProductInput[] | AdditionalUncheckedCreateWithoutProductInput[]
    connectOrCreate?: AdditionalCreateOrConnectWithoutProductInput | AdditionalCreateOrConnectWithoutProductInput[]
    upsert?: AdditionalUpsertWithWhereUniqueWithoutProductInput | AdditionalUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: AdditionalCreateManyProductInputEnvelope
    set?: AdditionalWhereUniqueInput | AdditionalWhereUniqueInput[]
    disconnect?: AdditionalWhereUniqueInput | AdditionalWhereUniqueInput[]
    delete?: AdditionalWhereUniqueInput | AdditionalWhereUniqueInput[]
    connect?: AdditionalWhereUniqueInput | AdditionalWhereUniqueInput[]
    update?: AdditionalUpdateWithWhereUniqueWithoutProductInput | AdditionalUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: AdditionalUpdateManyWithWhereWithoutProductInput | AdditionalUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: AdditionalScalarWhereInput | AdditionalScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutProductsNestedInput = {
    create?: XOR<OrderCreateWithoutProductsInput, OrderUncheckedCreateWithoutProductsInput> | OrderCreateWithoutProductsInput[] | OrderUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutProductsInput | OrderCreateOrConnectWithoutProductsInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutProductsInput | OrderUpsertWithWhereUniqueWithoutProductsInput[]
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutProductsInput | OrderUpdateWithWhereUniqueWithoutProductsInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutProductsInput | OrderUpdateManyWithWhereWithoutProductsInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type OrderItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutProductInput | OrderItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutProductInput | OrderItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutProductInput | OrderItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type ProductTagUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductTagCreateWithoutProductInput, ProductTagUncheckedCreateWithoutProductInput> | ProductTagCreateWithoutProductInput[] | ProductTagUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductTagCreateOrConnectWithoutProductInput | ProductTagCreateOrConnectWithoutProductInput[]
    upsert?: ProductTagUpsertWithWhereUniqueWithoutProductInput | ProductTagUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductTagCreateManyProductInputEnvelope
    set?: ProductTagWhereUniqueInput | ProductTagWhereUniqueInput[]
    disconnect?: ProductTagWhereUniqueInput | ProductTagWhereUniqueInput[]
    delete?: ProductTagWhereUniqueInput | ProductTagWhereUniqueInput[]
    connect?: ProductTagWhereUniqueInput | ProductTagWhereUniqueInput[]
    update?: ProductTagUpdateWithWhereUniqueWithoutProductInput | ProductTagUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductTagUpdateManyWithWhereWithoutProductInput | ProductTagUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductTagScalarWhereInput | ProductTagScalarWhereInput[]
  }

  export type ComboUncheckedUpdateManyWithoutProductsNestedInput = {
    create?: XOR<ComboCreateWithoutProductsInput, ComboUncheckedCreateWithoutProductsInput> | ComboCreateWithoutProductsInput[] | ComboUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: ComboCreateOrConnectWithoutProductsInput | ComboCreateOrConnectWithoutProductsInput[]
    upsert?: ComboUpsertWithWhereUniqueWithoutProductsInput | ComboUpsertWithWhereUniqueWithoutProductsInput[]
    set?: ComboWhereUniqueInput | ComboWhereUniqueInput[]
    disconnect?: ComboWhereUniqueInput | ComboWhereUniqueInput[]
    delete?: ComboWhereUniqueInput | ComboWhereUniqueInput[]
    connect?: ComboWhereUniqueInput | ComboWhereUniqueInput[]
    update?: ComboUpdateWithWhereUniqueWithoutProductsInput | ComboUpdateWithWhereUniqueWithoutProductsInput[]
    updateMany?: ComboUpdateManyWithWhereWithoutProductsInput | ComboUpdateManyWithWhereWithoutProductsInput[]
    deleteMany?: ComboScalarWhereInput | ComboScalarWhereInput[]
  }

  export type ComboProductsUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ComboProductsCreateWithoutProductInput, ComboProductsUncheckedCreateWithoutProductInput> | ComboProductsCreateWithoutProductInput[] | ComboProductsUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ComboProductsCreateOrConnectWithoutProductInput | ComboProductsCreateOrConnectWithoutProductInput[]
    upsert?: ComboProductsUpsertWithWhereUniqueWithoutProductInput | ComboProductsUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ComboProductsCreateManyProductInputEnvelope
    set?: ComboProductsWhereUniqueInput | ComboProductsWhereUniqueInput[]
    disconnect?: ComboProductsWhereUniqueInput | ComboProductsWhereUniqueInput[]
    delete?: ComboProductsWhereUniqueInput | ComboProductsWhereUniqueInput[]
    connect?: ComboProductsWhereUniqueInput | ComboProductsWhereUniqueInput[]
    update?: ComboProductsUpdateWithWhereUniqueWithoutProductInput | ComboProductsUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ComboProductsUpdateManyWithWhereWithoutProductInput | ComboProductsUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ComboProductsScalarWhereInput | ComboProductsScalarWhereInput[]
  }

  export type ComboUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ComboCreateWithoutProductInput, ComboUncheckedCreateWithoutProductInput> | ComboCreateWithoutProductInput[] | ComboUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ComboCreateOrConnectWithoutProductInput | ComboCreateOrConnectWithoutProductInput[]
    upsert?: ComboUpsertWithWhereUniqueWithoutProductInput | ComboUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ComboCreateManyProductInputEnvelope
    set?: ComboWhereUniqueInput | ComboWhereUniqueInput[]
    disconnect?: ComboWhereUniqueInput | ComboWhereUniqueInput[]
    delete?: ComboWhereUniqueInput | ComboWhereUniqueInput[]
    connect?: ComboWhereUniqueInput | ComboWhereUniqueInput[]
    update?: ComboUpdateWithWhereUniqueWithoutProductInput | ComboUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ComboUpdateManyWithWhereWithoutProductInput | ComboUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ComboScalarWhereInput | ComboScalarWhereInput[]
  }

  export type ProductCreateNestedOneWithoutAccompanimentsInput = {
    create?: XOR<ProductCreateWithoutAccompanimentsInput, ProductUncheckedCreateWithoutAccompanimentsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutAccompanimentsInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutAccompanimentsNestedInput = {
    create?: XOR<ProductCreateWithoutAccompanimentsInput, ProductUncheckedCreateWithoutAccompanimentsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutAccompanimentsInput
    upsert?: ProductUpsertWithoutAccompanimentsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutAccompanimentsInput, ProductUpdateWithoutAccompanimentsInput>, ProductUncheckedUpdateWithoutAccompanimentsInput>
  }

  export type ProductCreateNestedOneWithoutAdditionalsInput = {
    create?: XOR<ProductCreateWithoutAdditionalsInput, ProductUncheckedCreateWithoutAdditionalsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutAdditionalsInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutAdditionalsNestedInput = {
    create?: XOR<ProductCreateWithoutAdditionalsInput, ProductUncheckedCreateWithoutAdditionalsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutAdditionalsInput
    upsert?: ProductUpsertWithoutAdditionalsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutAdditionalsInput, ProductUpdateWithoutAdditionalsInput>, ProductUncheckedUpdateWithoutAdditionalsInput>
  }

  export type UserCreateNestedOneWithoutOrdersInput = {
    create?: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrdersInput
    connect?: UserWhereUniqueInput
  }

  export type ProductCreateNestedManyWithoutOrdersInput = {
    create?: XOR<ProductCreateWithoutOrdersInput, ProductUncheckedCreateWithoutOrdersInput> | ProductCreateWithoutOrdersInput[] | ProductUncheckedCreateWithoutOrdersInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutOrdersInput | ProductCreateOrConnectWithoutOrdersInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type EnterpriseCreateNestedOneWithoutOrdersInput = {
    create?: XOR<EnterpriseCreateWithoutOrdersInput, EnterpriseUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: EnterpriseCreateOrConnectWithoutOrdersInput
    connect?: EnterpriseWhereUniqueInput
  }

  export type OrderItemCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type OrderHistoryCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderHistoryCreateWithoutOrderInput, OrderHistoryUncheckedCreateWithoutOrderInput> | OrderHistoryCreateWithoutOrderInput[] | OrderHistoryUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderHistoryCreateOrConnectWithoutOrderInput | OrderHistoryCreateOrConnectWithoutOrderInput[]
    createMany?: OrderHistoryCreateManyOrderInputEnvelope
    connect?: OrderHistoryWhereUniqueInput | OrderHistoryWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutOrdersInput = {
    create?: XOR<ProductCreateWithoutOrdersInput, ProductUncheckedCreateWithoutOrdersInput> | ProductCreateWithoutOrdersInput[] | ProductUncheckedCreateWithoutOrdersInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutOrdersInput | ProductCreateOrConnectWithoutOrdersInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type OrderItemUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type OrderHistoryUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderHistoryCreateWithoutOrderInput, OrderHistoryUncheckedCreateWithoutOrderInput> | OrderHistoryCreateWithoutOrderInput[] | OrderHistoryUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderHistoryCreateOrConnectWithoutOrderInput | OrderHistoryCreateOrConnectWithoutOrderInput[]
    createMany?: OrderHistoryCreateManyOrderInputEnvelope
    connect?: OrderHistoryWhereUniqueInput | OrderHistoryWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrdersInput
    upsert?: UserUpsertWithoutOrdersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOrdersInput, UserUpdateWithoutOrdersInput>, UserUncheckedUpdateWithoutOrdersInput>
  }

  export type ProductUpdateManyWithoutOrdersNestedInput = {
    create?: XOR<ProductCreateWithoutOrdersInput, ProductUncheckedCreateWithoutOrdersInput> | ProductCreateWithoutOrdersInput[] | ProductUncheckedCreateWithoutOrdersInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutOrdersInput | ProductCreateOrConnectWithoutOrdersInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutOrdersInput | ProductUpsertWithWhereUniqueWithoutOrdersInput[]
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutOrdersInput | ProductUpdateWithWhereUniqueWithoutOrdersInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutOrdersInput | ProductUpdateManyWithWhereWithoutOrdersInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type EnterpriseUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<EnterpriseCreateWithoutOrdersInput, EnterpriseUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: EnterpriseCreateOrConnectWithoutOrdersInput
    upsert?: EnterpriseUpsertWithoutOrdersInput
    connect?: EnterpriseWhereUniqueInput
    update?: XOR<XOR<EnterpriseUpdateToOneWithWhereWithoutOrdersInput, EnterpriseUpdateWithoutOrdersInput>, EnterpriseUncheckedUpdateWithoutOrdersInput>
  }

  export type OrderItemUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutOrderInput | OrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutOrderInput | OrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutOrderInput | OrderItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type OrderHistoryUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderHistoryCreateWithoutOrderInput, OrderHistoryUncheckedCreateWithoutOrderInput> | OrderHistoryCreateWithoutOrderInput[] | OrderHistoryUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderHistoryCreateOrConnectWithoutOrderInput | OrderHistoryCreateOrConnectWithoutOrderInput[]
    upsert?: OrderHistoryUpsertWithWhereUniqueWithoutOrderInput | OrderHistoryUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderHistoryCreateManyOrderInputEnvelope
    set?: OrderHistoryWhereUniqueInput | OrderHistoryWhereUniqueInput[]
    disconnect?: OrderHistoryWhereUniqueInput | OrderHistoryWhereUniqueInput[]
    delete?: OrderHistoryWhereUniqueInput | OrderHistoryWhereUniqueInput[]
    connect?: OrderHistoryWhereUniqueInput | OrderHistoryWhereUniqueInput[]
    update?: OrderHistoryUpdateWithWhereUniqueWithoutOrderInput | OrderHistoryUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderHistoryUpdateManyWithWhereWithoutOrderInput | OrderHistoryUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderHistoryScalarWhereInput | OrderHistoryScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutOrdersNestedInput = {
    create?: XOR<ProductCreateWithoutOrdersInput, ProductUncheckedCreateWithoutOrdersInput> | ProductCreateWithoutOrdersInput[] | ProductUncheckedCreateWithoutOrdersInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutOrdersInput | ProductCreateOrConnectWithoutOrdersInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutOrdersInput | ProductUpsertWithWhereUniqueWithoutOrdersInput[]
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutOrdersInput | ProductUpdateWithWhereUniqueWithoutOrdersInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutOrdersInput | ProductUpdateManyWithWhereWithoutOrdersInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type OrderItemUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutOrderInput | OrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutOrderInput | OrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutOrderInput | OrderItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type OrderHistoryUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderHistoryCreateWithoutOrderInput, OrderHistoryUncheckedCreateWithoutOrderInput> | OrderHistoryCreateWithoutOrderInput[] | OrderHistoryUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderHistoryCreateOrConnectWithoutOrderInput | OrderHistoryCreateOrConnectWithoutOrderInput[]
    upsert?: OrderHistoryUpsertWithWhereUniqueWithoutOrderInput | OrderHistoryUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderHistoryCreateManyOrderInputEnvelope
    set?: OrderHistoryWhereUniqueInput | OrderHistoryWhereUniqueInput[]
    disconnect?: OrderHistoryWhereUniqueInput | OrderHistoryWhereUniqueInput[]
    delete?: OrderHistoryWhereUniqueInput | OrderHistoryWhereUniqueInput[]
    connect?: OrderHistoryWhereUniqueInput | OrderHistoryWhereUniqueInput[]
    update?: OrderHistoryUpdateWithWhereUniqueWithoutOrderInput | OrderHistoryUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderHistoryUpdateManyWithWhereWithoutOrderInput | OrderHistoryUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderHistoryScalarWhereInput | OrderHistoryScalarWhereInput[]
  }

  export type ProductCreateNestedOneWithoutOrderItemsInput = {
    create?: XOR<ProductCreateWithoutOrderItemsInput, ProductUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutOrderItemsInput
    connect?: ProductWhereUniqueInput
  }

  export type OrderCreateNestedOneWithoutOrderItemsInput = {
    create?: XOR<OrderCreateWithoutOrderItemsInput, OrderUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutOrderItemsInput
    connect?: OrderWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutOrderItemsNestedInput = {
    create?: XOR<ProductCreateWithoutOrderItemsInput, ProductUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutOrderItemsInput
    upsert?: ProductUpsertWithoutOrderItemsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutOrderItemsInput, ProductUpdateWithoutOrderItemsInput>, ProductUncheckedUpdateWithoutOrderItemsInput>
  }

  export type OrderUpdateOneRequiredWithoutOrderItemsNestedInput = {
    create?: XOR<OrderCreateWithoutOrderItemsInput, OrderUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutOrderItemsInput
    upsert?: OrderUpsertWithoutOrderItemsInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutOrderItemsInput, OrderUpdateWithoutOrderItemsInput>, OrderUncheckedUpdateWithoutOrderItemsInput>
  }

  export type OrderCreateNestedOneWithoutOrderHistoriesInput = {
    create?: XOR<OrderCreateWithoutOrderHistoriesInput, OrderUncheckedCreateWithoutOrderHistoriesInput>
    connectOrCreate?: OrderCreateOrConnectWithoutOrderHistoriesInput
    connect?: OrderWhereUniqueInput
  }

  export type OrderUpdateOneRequiredWithoutOrderHistoriesNestedInput = {
    create?: XOR<OrderCreateWithoutOrderHistoriesInput, OrderUncheckedCreateWithoutOrderHistoriesInput>
    connectOrCreate?: OrderCreateOrConnectWithoutOrderHistoriesInput
    upsert?: OrderUpsertWithoutOrderHistoriesInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutOrderHistoriesInput, OrderUpdateWithoutOrderHistoriesInput>, OrderUncheckedUpdateWithoutOrderHistoriesInput>
  }

  export type UserCreateNestedManyWithoutEnterpriseInput = {
    create?: XOR<UserCreateWithoutEnterpriseInput, UserUncheckedCreateWithoutEnterpriseInput> | UserCreateWithoutEnterpriseInput[] | UserUncheckedCreateWithoutEnterpriseInput[]
    connectOrCreate?: UserCreateOrConnectWithoutEnterpriseInput | UserCreateOrConnectWithoutEnterpriseInput[]
    createMany?: UserCreateManyEnterpriseInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type CategoryCreateNestedManyWithoutEnterpriseInput = {
    create?: XOR<CategoryCreateWithoutEnterpriseInput, CategoryUncheckedCreateWithoutEnterpriseInput> | CategoryCreateWithoutEnterpriseInput[] | CategoryUncheckedCreateWithoutEnterpriseInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutEnterpriseInput | CategoryCreateOrConnectWithoutEnterpriseInput[]
    createMany?: CategoryCreateManyEnterpriseInputEnvelope
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type ProductCreateNestedManyWithoutEnterpriseInput = {
    create?: XOR<ProductCreateWithoutEnterpriseInput, ProductUncheckedCreateWithoutEnterpriseInput> | ProductCreateWithoutEnterpriseInput[] | ProductUncheckedCreateWithoutEnterpriseInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutEnterpriseInput | ProductCreateOrConnectWithoutEnterpriseInput[]
    createMany?: ProductCreateManyEnterpriseInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ConfigurationCreateNestedManyWithoutEnterpriseInput = {
    create?: XOR<ConfigurationCreateWithoutEnterpriseInput, ConfigurationUncheckedCreateWithoutEnterpriseInput> | ConfigurationCreateWithoutEnterpriseInput[] | ConfigurationUncheckedCreateWithoutEnterpriseInput[]
    connectOrCreate?: ConfigurationCreateOrConnectWithoutEnterpriseInput | ConfigurationCreateOrConnectWithoutEnterpriseInput[]
    createMany?: ConfigurationCreateManyEnterpriseInputEnvelope
    connect?: ConfigurationWhereUniqueInput | ConfigurationWhereUniqueInput[]
  }

  export type OrderCreateNestedManyWithoutEnterpriseInput = {
    create?: XOR<OrderCreateWithoutEnterpriseInput, OrderUncheckedCreateWithoutEnterpriseInput> | OrderCreateWithoutEnterpriseInput[] | OrderUncheckedCreateWithoutEnterpriseInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutEnterpriseInput | OrderCreateOrConnectWithoutEnterpriseInput[]
    createMany?: OrderCreateManyEnterpriseInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type PromotionCreateNestedManyWithoutEnterpriseInput = {
    create?: XOR<PromotionCreateWithoutEnterpriseInput, PromotionUncheckedCreateWithoutEnterpriseInput> | PromotionCreateWithoutEnterpriseInput[] | PromotionUncheckedCreateWithoutEnterpriseInput[]
    connectOrCreate?: PromotionCreateOrConnectWithoutEnterpriseInput | PromotionCreateOrConnectWithoutEnterpriseInput[]
    createMany?: PromotionCreateManyEnterpriseInputEnvelope
    connect?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
  }

  export type ComboCreateNestedManyWithoutEnterpriseInput = {
    create?: XOR<ComboCreateWithoutEnterpriseInput, ComboUncheckedCreateWithoutEnterpriseInput> | ComboCreateWithoutEnterpriseInput[] | ComboUncheckedCreateWithoutEnterpriseInput[]
    connectOrCreate?: ComboCreateOrConnectWithoutEnterpriseInput | ComboCreateOrConnectWithoutEnterpriseInput[]
    createMany?: ComboCreateManyEnterpriseInputEnvelope
    connect?: ComboWhereUniqueInput | ComboWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutEnterpriseInput = {
    create?: XOR<UserCreateWithoutEnterpriseInput, UserUncheckedCreateWithoutEnterpriseInput> | UserCreateWithoutEnterpriseInput[] | UserUncheckedCreateWithoutEnterpriseInput[]
    connectOrCreate?: UserCreateOrConnectWithoutEnterpriseInput | UserCreateOrConnectWithoutEnterpriseInput[]
    createMany?: UserCreateManyEnterpriseInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type CategoryUncheckedCreateNestedManyWithoutEnterpriseInput = {
    create?: XOR<CategoryCreateWithoutEnterpriseInput, CategoryUncheckedCreateWithoutEnterpriseInput> | CategoryCreateWithoutEnterpriseInput[] | CategoryUncheckedCreateWithoutEnterpriseInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutEnterpriseInput | CategoryCreateOrConnectWithoutEnterpriseInput[]
    createMany?: CategoryCreateManyEnterpriseInputEnvelope
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutEnterpriseInput = {
    create?: XOR<ProductCreateWithoutEnterpriseInput, ProductUncheckedCreateWithoutEnterpriseInput> | ProductCreateWithoutEnterpriseInput[] | ProductUncheckedCreateWithoutEnterpriseInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutEnterpriseInput | ProductCreateOrConnectWithoutEnterpriseInput[]
    createMany?: ProductCreateManyEnterpriseInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ConfigurationUncheckedCreateNestedManyWithoutEnterpriseInput = {
    create?: XOR<ConfigurationCreateWithoutEnterpriseInput, ConfigurationUncheckedCreateWithoutEnterpriseInput> | ConfigurationCreateWithoutEnterpriseInput[] | ConfigurationUncheckedCreateWithoutEnterpriseInput[]
    connectOrCreate?: ConfigurationCreateOrConnectWithoutEnterpriseInput | ConfigurationCreateOrConnectWithoutEnterpriseInput[]
    createMany?: ConfigurationCreateManyEnterpriseInputEnvelope
    connect?: ConfigurationWhereUniqueInput | ConfigurationWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutEnterpriseInput = {
    create?: XOR<OrderCreateWithoutEnterpriseInput, OrderUncheckedCreateWithoutEnterpriseInput> | OrderCreateWithoutEnterpriseInput[] | OrderUncheckedCreateWithoutEnterpriseInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutEnterpriseInput | OrderCreateOrConnectWithoutEnterpriseInput[]
    createMany?: OrderCreateManyEnterpriseInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type PromotionUncheckedCreateNestedManyWithoutEnterpriseInput = {
    create?: XOR<PromotionCreateWithoutEnterpriseInput, PromotionUncheckedCreateWithoutEnterpriseInput> | PromotionCreateWithoutEnterpriseInput[] | PromotionUncheckedCreateWithoutEnterpriseInput[]
    connectOrCreate?: PromotionCreateOrConnectWithoutEnterpriseInput | PromotionCreateOrConnectWithoutEnterpriseInput[]
    createMany?: PromotionCreateManyEnterpriseInputEnvelope
    connect?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
  }

  export type ComboUncheckedCreateNestedManyWithoutEnterpriseInput = {
    create?: XOR<ComboCreateWithoutEnterpriseInput, ComboUncheckedCreateWithoutEnterpriseInput> | ComboCreateWithoutEnterpriseInput[] | ComboUncheckedCreateWithoutEnterpriseInput[]
    connectOrCreate?: ComboCreateOrConnectWithoutEnterpriseInput | ComboCreateOrConnectWithoutEnterpriseInput[]
    createMany?: ComboCreateManyEnterpriseInputEnvelope
    connect?: ComboWhereUniqueInput | ComboWhereUniqueInput[]
  }

  export type UserUpdateManyWithoutEnterpriseNestedInput = {
    create?: XOR<UserCreateWithoutEnterpriseInput, UserUncheckedCreateWithoutEnterpriseInput> | UserCreateWithoutEnterpriseInput[] | UserUncheckedCreateWithoutEnterpriseInput[]
    connectOrCreate?: UserCreateOrConnectWithoutEnterpriseInput | UserCreateOrConnectWithoutEnterpriseInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutEnterpriseInput | UserUpsertWithWhereUniqueWithoutEnterpriseInput[]
    createMany?: UserCreateManyEnterpriseInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutEnterpriseInput | UserUpdateWithWhereUniqueWithoutEnterpriseInput[]
    updateMany?: UserUpdateManyWithWhereWithoutEnterpriseInput | UserUpdateManyWithWhereWithoutEnterpriseInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type CategoryUpdateManyWithoutEnterpriseNestedInput = {
    create?: XOR<CategoryCreateWithoutEnterpriseInput, CategoryUncheckedCreateWithoutEnterpriseInput> | CategoryCreateWithoutEnterpriseInput[] | CategoryUncheckedCreateWithoutEnterpriseInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutEnterpriseInput | CategoryCreateOrConnectWithoutEnterpriseInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutEnterpriseInput | CategoryUpsertWithWhereUniqueWithoutEnterpriseInput[]
    createMany?: CategoryCreateManyEnterpriseInputEnvelope
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutEnterpriseInput | CategoryUpdateWithWhereUniqueWithoutEnterpriseInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutEnterpriseInput | CategoryUpdateManyWithWhereWithoutEnterpriseInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type ProductUpdateManyWithoutEnterpriseNestedInput = {
    create?: XOR<ProductCreateWithoutEnterpriseInput, ProductUncheckedCreateWithoutEnterpriseInput> | ProductCreateWithoutEnterpriseInput[] | ProductUncheckedCreateWithoutEnterpriseInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutEnterpriseInput | ProductCreateOrConnectWithoutEnterpriseInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutEnterpriseInput | ProductUpsertWithWhereUniqueWithoutEnterpriseInput[]
    createMany?: ProductCreateManyEnterpriseInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutEnterpriseInput | ProductUpdateWithWhereUniqueWithoutEnterpriseInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutEnterpriseInput | ProductUpdateManyWithWhereWithoutEnterpriseInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ConfigurationUpdateManyWithoutEnterpriseNestedInput = {
    create?: XOR<ConfigurationCreateWithoutEnterpriseInput, ConfigurationUncheckedCreateWithoutEnterpriseInput> | ConfigurationCreateWithoutEnterpriseInput[] | ConfigurationUncheckedCreateWithoutEnterpriseInput[]
    connectOrCreate?: ConfigurationCreateOrConnectWithoutEnterpriseInput | ConfigurationCreateOrConnectWithoutEnterpriseInput[]
    upsert?: ConfigurationUpsertWithWhereUniqueWithoutEnterpriseInput | ConfigurationUpsertWithWhereUniqueWithoutEnterpriseInput[]
    createMany?: ConfigurationCreateManyEnterpriseInputEnvelope
    set?: ConfigurationWhereUniqueInput | ConfigurationWhereUniqueInput[]
    disconnect?: ConfigurationWhereUniqueInput | ConfigurationWhereUniqueInput[]
    delete?: ConfigurationWhereUniqueInput | ConfigurationWhereUniqueInput[]
    connect?: ConfigurationWhereUniqueInput | ConfigurationWhereUniqueInput[]
    update?: ConfigurationUpdateWithWhereUniqueWithoutEnterpriseInput | ConfigurationUpdateWithWhereUniqueWithoutEnterpriseInput[]
    updateMany?: ConfigurationUpdateManyWithWhereWithoutEnterpriseInput | ConfigurationUpdateManyWithWhereWithoutEnterpriseInput[]
    deleteMany?: ConfigurationScalarWhereInput | ConfigurationScalarWhereInput[]
  }

  export type OrderUpdateManyWithoutEnterpriseNestedInput = {
    create?: XOR<OrderCreateWithoutEnterpriseInput, OrderUncheckedCreateWithoutEnterpriseInput> | OrderCreateWithoutEnterpriseInput[] | OrderUncheckedCreateWithoutEnterpriseInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutEnterpriseInput | OrderCreateOrConnectWithoutEnterpriseInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutEnterpriseInput | OrderUpsertWithWhereUniqueWithoutEnterpriseInput[]
    createMany?: OrderCreateManyEnterpriseInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutEnterpriseInput | OrderUpdateWithWhereUniqueWithoutEnterpriseInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutEnterpriseInput | OrderUpdateManyWithWhereWithoutEnterpriseInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type PromotionUpdateManyWithoutEnterpriseNestedInput = {
    create?: XOR<PromotionCreateWithoutEnterpriseInput, PromotionUncheckedCreateWithoutEnterpriseInput> | PromotionCreateWithoutEnterpriseInput[] | PromotionUncheckedCreateWithoutEnterpriseInput[]
    connectOrCreate?: PromotionCreateOrConnectWithoutEnterpriseInput | PromotionCreateOrConnectWithoutEnterpriseInput[]
    upsert?: PromotionUpsertWithWhereUniqueWithoutEnterpriseInput | PromotionUpsertWithWhereUniqueWithoutEnterpriseInput[]
    createMany?: PromotionCreateManyEnterpriseInputEnvelope
    set?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
    disconnect?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
    delete?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
    connect?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
    update?: PromotionUpdateWithWhereUniqueWithoutEnterpriseInput | PromotionUpdateWithWhereUniqueWithoutEnterpriseInput[]
    updateMany?: PromotionUpdateManyWithWhereWithoutEnterpriseInput | PromotionUpdateManyWithWhereWithoutEnterpriseInput[]
    deleteMany?: PromotionScalarWhereInput | PromotionScalarWhereInput[]
  }

  export type ComboUpdateManyWithoutEnterpriseNestedInput = {
    create?: XOR<ComboCreateWithoutEnterpriseInput, ComboUncheckedCreateWithoutEnterpriseInput> | ComboCreateWithoutEnterpriseInput[] | ComboUncheckedCreateWithoutEnterpriseInput[]
    connectOrCreate?: ComboCreateOrConnectWithoutEnterpriseInput | ComboCreateOrConnectWithoutEnterpriseInput[]
    upsert?: ComboUpsertWithWhereUniqueWithoutEnterpriseInput | ComboUpsertWithWhereUniqueWithoutEnterpriseInput[]
    createMany?: ComboCreateManyEnterpriseInputEnvelope
    set?: ComboWhereUniqueInput | ComboWhereUniqueInput[]
    disconnect?: ComboWhereUniqueInput | ComboWhereUniqueInput[]
    delete?: ComboWhereUniqueInput | ComboWhereUniqueInput[]
    connect?: ComboWhereUniqueInput | ComboWhereUniqueInput[]
    update?: ComboUpdateWithWhereUniqueWithoutEnterpriseInput | ComboUpdateWithWhereUniqueWithoutEnterpriseInput[]
    updateMany?: ComboUpdateManyWithWhereWithoutEnterpriseInput | ComboUpdateManyWithWhereWithoutEnterpriseInput[]
    deleteMany?: ComboScalarWhereInput | ComboScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutEnterpriseNestedInput = {
    create?: XOR<UserCreateWithoutEnterpriseInput, UserUncheckedCreateWithoutEnterpriseInput> | UserCreateWithoutEnterpriseInput[] | UserUncheckedCreateWithoutEnterpriseInput[]
    connectOrCreate?: UserCreateOrConnectWithoutEnterpriseInput | UserCreateOrConnectWithoutEnterpriseInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutEnterpriseInput | UserUpsertWithWhereUniqueWithoutEnterpriseInput[]
    createMany?: UserCreateManyEnterpriseInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutEnterpriseInput | UserUpdateWithWhereUniqueWithoutEnterpriseInput[]
    updateMany?: UserUpdateManyWithWhereWithoutEnterpriseInput | UserUpdateManyWithWhereWithoutEnterpriseInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type CategoryUncheckedUpdateManyWithoutEnterpriseNestedInput = {
    create?: XOR<CategoryCreateWithoutEnterpriseInput, CategoryUncheckedCreateWithoutEnterpriseInput> | CategoryCreateWithoutEnterpriseInput[] | CategoryUncheckedCreateWithoutEnterpriseInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutEnterpriseInput | CategoryCreateOrConnectWithoutEnterpriseInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutEnterpriseInput | CategoryUpsertWithWhereUniqueWithoutEnterpriseInput[]
    createMany?: CategoryCreateManyEnterpriseInputEnvelope
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutEnterpriseInput | CategoryUpdateWithWhereUniqueWithoutEnterpriseInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutEnterpriseInput | CategoryUpdateManyWithWhereWithoutEnterpriseInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutEnterpriseNestedInput = {
    create?: XOR<ProductCreateWithoutEnterpriseInput, ProductUncheckedCreateWithoutEnterpriseInput> | ProductCreateWithoutEnterpriseInput[] | ProductUncheckedCreateWithoutEnterpriseInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutEnterpriseInput | ProductCreateOrConnectWithoutEnterpriseInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutEnterpriseInput | ProductUpsertWithWhereUniqueWithoutEnterpriseInput[]
    createMany?: ProductCreateManyEnterpriseInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutEnterpriseInput | ProductUpdateWithWhereUniqueWithoutEnterpriseInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutEnterpriseInput | ProductUpdateManyWithWhereWithoutEnterpriseInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ConfigurationUncheckedUpdateManyWithoutEnterpriseNestedInput = {
    create?: XOR<ConfigurationCreateWithoutEnterpriseInput, ConfigurationUncheckedCreateWithoutEnterpriseInput> | ConfigurationCreateWithoutEnterpriseInput[] | ConfigurationUncheckedCreateWithoutEnterpriseInput[]
    connectOrCreate?: ConfigurationCreateOrConnectWithoutEnterpriseInput | ConfigurationCreateOrConnectWithoutEnterpriseInput[]
    upsert?: ConfigurationUpsertWithWhereUniqueWithoutEnterpriseInput | ConfigurationUpsertWithWhereUniqueWithoutEnterpriseInput[]
    createMany?: ConfigurationCreateManyEnterpriseInputEnvelope
    set?: ConfigurationWhereUniqueInput | ConfigurationWhereUniqueInput[]
    disconnect?: ConfigurationWhereUniqueInput | ConfigurationWhereUniqueInput[]
    delete?: ConfigurationWhereUniqueInput | ConfigurationWhereUniqueInput[]
    connect?: ConfigurationWhereUniqueInput | ConfigurationWhereUniqueInput[]
    update?: ConfigurationUpdateWithWhereUniqueWithoutEnterpriseInput | ConfigurationUpdateWithWhereUniqueWithoutEnterpriseInput[]
    updateMany?: ConfigurationUpdateManyWithWhereWithoutEnterpriseInput | ConfigurationUpdateManyWithWhereWithoutEnterpriseInput[]
    deleteMany?: ConfigurationScalarWhereInput | ConfigurationScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutEnterpriseNestedInput = {
    create?: XOR<OrderCreateWithoutEnterpriseInput, OrderUncheckedCreateWithoutEnterpriseInput> | OrderCreateWithoutEnterpriseInput[] | OrderUncheckedCreateWithoutEnterpriseInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutEnterpriseInput | OrderCreateOrConnectWithoutEnterpriseInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutEnterpriseInput | OrderUpsertWithWhereUniqueWithoutEnterpriseInput[]
    createMany?: OrderCreateManyEnterpriseInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutEnterpriseInput | OrderUpdateWithWhereUniqueWithoutEnterpriseInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutEnterpriseInput | OrderUpdateManyWithWhereWithoutEnterpriseInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type PromotionUncheckedUpdateManyWithoutEnterpriseNestedInput = {
    create?: XOR<PromotionCreateWithoutEnterpriseInput, PromotionUncheckedCreateWithoutEnterpriseInput> | PromotionCreateWithoutEnterpriseInput[] | PromotionUncheckedCreateWithoutEnterpriseInput[]
    connectOrCreate?: PromotionCreateOrConnectWithoutEnterpriseInput | PromotionCreateOrConnectWithoutEnterpriseInput[]
    upsert?: PromotionUpsertWithWhereUniqueWithoutEnterpriseInput | PromotionUpsertWithWhereUniqueWithoutEnterpriseInput[]
    createMany?: PromotionCreateManyEnterpriseInputEnvelope
    set?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
    disconnect?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
    delete?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
    connect?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
    update?: PromotionUpdateWithWhereUniqueWithoutEnterpriseInput | PromotionUpdateWithWhereUniqueWithoutEnterpriseInput[]
    updateMany?: PromotionUpdateManyWithWhereWithoutEnterpriseInput | PromotionUpdateManyWithWhereWithoutEnterpriseInput[]
    deleteMany?: PromotionScalarWhereInput | PromotionScalarWhereInput[]
  }

  export type ComboUncheckedUpdateManyWithoutEnterpriseNestedInput = {
    create?: XOR<ComboCreateWithoutEnterpriseInput, ComboUncheckedCreateWithoutEnterpriseInput> | ComboCreateWithoutEnterpriseInput[] | ComboUncheckedCreateWithoutEnterpriseInput[]
    connectOrCreate?: ComboCreateOrConnectWithoutEnterpriseInput | ComboCreateOrConnectWithoutEnterpriseInput[]
    upsert?: ComboUpsertWithWhereUniqueWithoutEnterpriseInput | ComboUpsertWithWhereUniqueWithoutEnterpriseInput[]
    createMany?: ComboCreateManyEnterpriseInputEnvelope
    set?: ComboWhereUniqueInput | ComboWhereUniqueInput[]
    disconnect?: ComboWhereUniqueInput | ComboWhereUniqueInput[]
    delete?: ComboWhereUniqueInput | ComboWhereUniqueInput[]
    connect?: ComboWhereUniqueInput | ComboWhereUniqueInput[]
    update?: ComboUpdateWithWhereUniqueWithoutEnterpriseInput | ComboUpdateWithWhereUniqueWithoutEnterpriseInput[]
    updateMany?: ComboUpdateManyWithWhereWithoutEnterpriseInput | ComboUpdateManyWithWhereWithoutEnterpriseInput[]
    deleteMany?: ComboScalarWhereInput | ComboScalarWhereInput[]
  }

  export type EnterpriseCreateNestedOneWithoutConfigurationsInput = {
    create?: XOR<EnterpriseCreateWithoutConfigurationsInput, EnterpriseUncheckedCreateWithoutConfigurationsInput>
    connectOrCreate?: EnterpriseCreateOrConnectWithoutConfigurationsInput
    connect?: EnterpriseWhereUniqueInput
  }

  export type EnterpriseUpdateOneRequiredWithoutConfigurationsNestedInput = {
    create?: XOR<EnterpriseCreateWithoutConfigurationsInput, EnterpriseUncheckedCreateWithoutConfigurationsInput>
    connectOrCreate?: EnterpriseCreateOrConnectWithoutConfigurationsInput
    upsert?: EnterpriseUpsertWithoutConfigurationsInput
    connect?: EnterpriseWhereUniqueInput
    update?: XOR<XOR<EnterpriseUpdateToOneWithWhereWithoutConfigurationsInput, EnterpriseUpdateWithoutConfigurationsInput>, EnterpriseUncheckedUpdateWithoutConfigurationsInput>
  }

  export type ProductTagCreateNestedManyWithoutTagInput = {
    create?: XOR<ProductTagCreateWithoutTagInput, ProductTagUncheckedCreateWithoutTagInput> | ProductTagCreateWithoutTagInput[] | ProductTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: ProductTagCreateOrConnectWithoutTagInput | ProductTagCreateOrConnectWithoutTagInput[]
    createMany?: ProductTagCreateManyTagInputEnvelope
    connect?: ProductTagWhereUniqueInput | ProductTagWhereUniqueInput[]
  }

  export type PromotionTagCreateNestedManyWithoutTagInput = {
    create?: XOR<PromotionTagCreateWithoutTagInput, PromotionTagUncheckedCreateWithoutTagInput> | PromotionTagCreateWithoutTagInput[] | PromotionTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: PromotionTagCreateOrConnectWithoutTagInput | PromotionTagCreateOrConnectWithoutTagInput[]
    createMany?: PromotionTagCreateManyTagInputEnvelope
    connect?: PromotionTagWhereUniqueInput | PromotionTagWhereUniqueInput[]
  }

  export type ProductTagUncheckedCreateNestedManyWithoutTagInput = {
    create?: XOR<ProductTagCreateWithoutTagInput, ProductTagUncheckedCreateWithoutTagInput> | ProductTagCreateWithoutTagInput[] | ProductTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: ProductTagCreateOrConnectWithoutTagInput | ProductTagCreateOrConnectWithoutTagInput[]
    createMany?: ProductTagCreateManyTagInputEnvelope
    connect?: ProductTagWhereUniqueInput | ProductTagWhereUniqueInput[]
  }

  export type PromotionTagUncheckedCreateNestedManyWithoutTagInput = {
    create?: XOR<PromotionTagCreateWithoutTagInput, PromotionTagUncheckedCreateWithoutTagInput> | PromotionTagCreateWithoutTagInput[] | PromotionTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: PromotionTagCreateOrConnectWithoutTagInput | PromotionTagCreateOrConnectWithoutTagInput[]
    createMany?: PromotionTagCreateManyTagInputEnvelope
    connect?: PromotionTagWhereUniqueInput | PromotionTagWhereUniqueInput[]
  }

  export type ProductTagUpdateManyWithoutTagNestedInput = {
    create?: XOR<ProductTagCreateWithoutTagInput, ProductTagUncheckedCreateWithoutTagInput> | ProductTagCreateWithoutTagInput[] | ProductTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: ProductTagCreateOrConnectWithoutTagInput | ProductTagCreateOrConnectWithoutTagInput[]
    upsert?: ProductTagUpsertWithWhereUniqueWithoutTagInput | ProductTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: ProductTagCreateManyTagInputEnvelope
    set?: ProductTagWhereUniqueInput | ProductTagWhereUniqueInput[]
    disconnect?: ProductTagWhereUniqueInput | ProductTagWhereUniqueInput[]
    delete?: ProductTagWhereUniqueInput | ProductTagWhereUniqueInput[]
    connect?: ProductTagWhereUniqueInput | ProductTagWhereUniqueInput[]
    update?: ProductTagUpdateWithWhereUniqueWithoutTagInput | ProductTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: ProductTagUpdateManyWithWhereWithoutTagInput | ProductTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: ProductTagScalarWhereInput | ProductTagScalarWhereInput[]
  }

  export type PromotionTagUpdateManyWithoutTagNestedInput = {
    create?: XOR<PromotionTagCreateWithoutTagInput, PromotionTagUncheckedCreateWithoutTagInput> | PromotionTagCreateWithoutTagInput[] | PromotionTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: PromotionTagCreateOrConnectWithoutTagInput | PromotionTagCreateOrConnectWithoutTagInput[]
    upsert?: PromotionTagUpsertWithWhereUniqueWithoutTagInput | PromotionTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: PromotionTagCreateManyTagInputEnvelope
    set?: PromotionTagWhereUniqueInput | PromotionTagWhereUniqueInput[]
    disconnect?: PromotionTagWhereUniqueInput | PromotionTagWhereUniqueInput[]
    delete?: PromotionTagWhereUniqueInput | PromotionTagWhereUniqueInput[]
    connect?: PromotionTagWhereUniqueInput | PromotionTagWhereUniqueInput[]
    update?: PromotionTagUpdateWithWhereUniqueWithoutTagInput | PromotionTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: PromotionTagUpdateManyWithWhereWithoutTagInput | PromotionTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: PromotionTagScalarWhereInput | PromotionTagScalarWhereInput[]
  }

  export type ProductTagUncheckedUpdateManyWithoutTagNestedInput = {
    create?: XOR<ProductTagCreateWithoutTagInput, ProductTagUncheckedCreateWithoutTagInput> | ProductTagCreateWithoutTagInput[] | ProductTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: ProductTagCreateOrConnectWithoutTagInput | ProductTagCreateOrConnectWithoutTagInput[]
    upsert?: ProductTagUpsertWithWhereUniqueWithoutTagInput | ProductTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: ProductTagCreateManyTagInputEnvelope
    set?: ProductTagWhereUniqueInput | ProductTagWhereUniqueInput[]
    disconnect?: ProductTagWhereUniqueInput | ProductTagWhereUniqueInput[]
    delete?: ProductTagWhereUniqueInput | ProductTagWhereUniqueInput[]
    connect?: ProductTagWhereUniqueInput | ProductTagWhereUniqueInput[]
    update?: ProductTagUpdateWithWhereUniqueWithoutTagInput | ProductTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: ProductTagUpdateManyWithWhereWithoutTagInput | ProductTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: ProductTagScalarWhereInput | ProductTagScalarWhereInput[]
  }

  export type PromotionTagUncheckedUpdateManyWithoutTagNestedInput = {
    create?: XOR<PromotionTagCreateWithoutTagInput, PromotionTagUncheckedCreateWithoutTagInput> | PromotionTagCreateWithoutTagInput[] | PromotionTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: PromotionTagCreateOrConnectWithoutTagInput | PromotionTagCreateOrConnectWithoutTagInput[]
    upsert?: PromotionTagUpsertWithWhereUniqueWithoutTagInput | PromotionTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: PromotionTagCreateManyTagInputEnvelope
    set?: PromotionTagWhereUniqueInput | PromotionTagWhereUniqueInput[]
    disconnect?: PromotionTagWhereUniqueInput | PromotionTagWhereUniqueInput[]
    delete?: PromotionTagWhereUniqueInput | PromotionTagWhereUniqueInput[]
    connect?: PromotionTagWhereUniqueInput | PromotionTagWhereUniqueInput[]
    update?: PromotionTagUpdateWithWhereUniqueWithoutTagInput | PromotionTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: PromotionTagUpdateManyWithWhereWithoutTagInput | PromotionTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: PromotionTagScalarWhereInput | PromotionTagScalarWhereInput[]
  }

  export type ProductCreateNestedOneWithoutProductTagsInput = {
    create?: XOR<ProductCreateWithoutProductTagsInput, ProductUncheckedCreateWithoutProductTagsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProductTagsInput
    connect?: ProductWhereUniqueInput
  }

  export type TagCreateNestedOneWithoutProductTagsInput = {
    create?: XOR<TagCreateWithoutProductTagsInput, TagUncheckedCreateWithoutProductTagsInput>
    connectOrCreate?: TagCreateOrConnectWithoutProductTagsInput
    connect?: TagWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutProductTagsNestedInput = {
    create?: XOR<ProductCreateWithoutProductTagsInput, ProductUncheckedCreateWithoutProductTagsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProductTagsInput
    upsert?: ProductUpsertWithoutProductTagsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutProductTagsInput, ProductUpdateWithoutProductTagsInput>, ProductUncheckedUpdateWithoutProductTagsInput>
  }

  export type TagUpdateOneRequiredWithoutProductTagsNestedInput = {
    create?: XOR<TagCreateWithoutProductTagsInput, TagUncheckedCreateWithoutProductTagsInput>
    connectOrCreate?: TagCreateOrConnectWithoutProductTagsInput
    upsert?: TagUpsertWithoutProductTagsInput
    connect?: TagWhereUniqueInput
    update?: XOR<XOR<TagUpdateToOneWithWhereWithoutProductTagsInput, TagUpdateWithoutProductTagsInput>, TagUncheckedUpdateWithoutProductTagsInput>
  }

  export type PromotionCreateNestedOneWithoutPromotionTagsInput = {
    create?: XOR<PromotionCreateWithoutPromotionTagsInput, PromotionUncheckedCreateWithoutPromotionTagsInput>
    connectOrCreate?: PromotionCreateOrConnectWithoutPromotionTagsInput
    connect?: PromotionWhereUniqueInput
  }

  export type TagCreateNestedOneWithoutPromotionTagsInput = {
    create?: XOR<TagCreateWithoutPromotionTagsInput, TagUncheckedCreateWithoutPromotionTagsInput>
    connectOrCreate?: TagCreateOrConnectWithoutPromotionTagsInput
    connect?: TagWhereUniqueInput
  }

  export type PromotionUpdateOneRequiredWithoutPromotionTagsNestedInput = {
    create?: XOR<PromotionCreateWithoutPromotionTagsInput, PromotionUncheckedCreateWithoutPromotionTagsInput>
    connectOrCreate?: PromotionCreateOrConnectWithoutPromotionTagsInput
    upsert?: PromotionUpsertWithoutPromotionTagsInput
    connect?: PromotionWhereUniqueInput
    update?: XOR<XOR<PromotionUpdateToOneWithWhereWithoutPromotionTagsInput, PromotionUpdateWithoutPromotionTagsInput>, PromotionUncheckedUpdateWithoutPromotionTagsInput>
  }

  export type TagUpdateOneRequiredWithoutPromotionTagsNestedInput = {
    create?: XOR<TagCreateWithoutPromotionTagsInput, TagUncheckedCreateWithoutPromotionTagsInput>
    connectOrCreate?: TagCreateOrConnectWithoutPromotionTagsInput
    upsert?: TagUpsertWithoutPromotionTagsInput
    connect?: TagWhereUniqueInput
    update?: XOR<XOR<TagUpdateToOneWithWhereWithoutPromotionTagsInput, TagUpdateWithoutPromotionTagsInput>, TagUncheckedUpdateWithoutPromotionTagsInput>
  }

  export type CategoryCreateNestedOneWithoutPromotionsInput = {
    create?: XOR<CategoryCreateWithoutPromotionsInput, CategoryUncheckedCreateWithoutPromotionsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutPromotionsInput
    connect?: CategoryWhereUniqueInput
  }

  export type EnterpriseCreateNestedOneWithoutPromotionsInput = {
    create?: XOR<EnterpriseCreateWithoutPromotionsInput, EnterpriseUncheckedCreateWithoutPromotionsInput>
    connectOrCreate?: EnterpriseCreateOrConnectWithoutPromotionsInput
    connect?: EnterpriseWhereUniqueInput
  }

  export type PromotionTagCreateNestedManyWithoutPromotionInput = {
    create?: XOR<PromotionTagCreateWithoutPromotionInput, PromotionTagUncheckedCreateWithoutPromotionInput> | PromotionTagCreateWithoutPromotionInput[] | PromotionTagUncheckedCreateWithoutPromotionInput[]
    connectOrCreate?: PromotionTagCreateOrConnectWithoutPromotionInput | PromotionTagCreateOrConnectWithoutPromotionInput[]
    createMany?: PromotionTagCreateManyPromotionInputEnvelope
    connect?: PromotionTagWhereUniqueInput | PromotionTagWhereUniqueInput[]
  }

  export type PromotionTagUncheckedCreateNestedManyWithoutPromotionInput = {
    create?: XOR<PromotionTagCreateWithoutPromotionInput, PromotionTagUncheckedCreateWithoutPromotionInput> | PromotionTagCreateWithoutPromotionInput[] | PromotionTagUncheckedCreateWithoutPromotionInput[]
    connectOrCreate?: PromotionTagCreateOrConnectWithoutPromotionInput | PromotionTagCreateOrConnectWithoutPromotionInput[]
    createMany?: PromotionTagCreateManyPromotionInputEnvelope
    connect?: PromotionTagWhereUniqueInput | PromotionTagWhereUniqueInput[]
  }

  export type CategoryUpdateOneRequiredWithoutPromotionsNestedInput = {
    create?: XOR<CategoryCreateWithoutPromotionsInput, CategoryUncheckedCreateWithoutPromotionsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutPromotionsInput
    upsert?: CategoryUpsertWithoutPromotionsInput
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutPromotionsInput, CategoryUpdateWithoutPromotionsInput>, CategoryUncheckedUpdateWithoutPromotionsInput>
  }

  export type EnterpriseUpdateOneRequiredWithoutPromotionsNestedInput = {
    create?: XOR<EnterpriseCreateWithoutPromotionsInput, EnterpriseUncheckedCreateWithoutPromotionsInput>
    connectOrCreate?: EnterpriseCreateOrConnectWithoutPromotionsInput
    upsert?: EnterpriseUpsertWithoutPromotionsInput
    connect?: EnterpriseWhereUniqueInput
    update?: XOR<XOR<EnterpriseUpdateToOneWithWhereWithoutPromotionsInput, EnterpriseUpdateWithoutPromotionsInput>, EnterpriseUncheckedUpdateWithoutPromotionsInput>
  }

  export type PromotionTagUpdateManyWithoutPromotionNestedInput = {
    create?: XOR<PromotionTagCreateWithoutPromotionInput, PromotionTagUncheckedCreateWithoutPromotionInput> | PromotionTagCreateWithoutPromotionInput[] | PromotionTagUncheckedCreateWithoutPromotionInput[]
    connectOrCreate?: PromotionTagCreateOrConnectWithoutPromotionInput | PromotionTagCreateOrConnectWithoutPromotionInput[]
    upsert?: PromotionTagUpsertWithWhereUniqueWithoutPromotionInput | PromotionTagUpsertWithWhereUniqueWithoutPromotionInput[]
    createMany?: PromotionTagCreateManyPromotionInputEnvelope
    set?: PromotionTagWhereUniqueInput | PromotionTagWhereUniqueInput[]
    disconnect?: PromotionTagWhereUniqueInput | PromotionTagWhereUniqueInput[]
    delete?: PromotionTagWhereUniqueInput | PromotionTagWhereUniqueInput[]
    connect?: PromotionTagWhereUniqueInput | PromotionTagWhereUniqueInput[]
    update?: PromotionTagUpdateWithWhereUniqueWithoutPromotionInput | PromotionTagUpdateWithWhereUniqueWithoutPromotionInput[]
    updateMany?: PromotionTagUpdateManyWithWhereWithoutPromotionInput | PromotionTagUpdateManyWithWhereWithoutPromotionInput[]
    deleteMany?: PromotionTagScalarWhereInput | PromotionTagScalarWhereInput[]
  }

  export type PromotionTagUncheckedUpdateManyWithoutPromotionNestedInput = {
    create?: XOR<PromotionTagCreateWithoutPromotionInput, PromotionTagUncheckedCreateWithoutPromotionInput> | PromotionTagCreateWithoutPromotionInput[] | PromotionTagUncheckedCreateWithoutPromotionInput[]
    connectOrCreate?: PromotionTagCreateOrConnectWithoutPromotionInput | PromotionTagCreateOrConnectWithoutPromotionInput[]
    upsert?: PromotionTagUpsertWithWhereUniqueWithoutPromotionInput | PromotionTagUpsertWithWhereUniqueWithoutPromotionInput[]
    createMany?: PromotionTagCreateManyPromotionInputEnvelope
    set?: PromotionTagWhereUniqueInput | PromotionTagWhereUniqueInput[]
    disconnect?: PromotionTagWhereUniqueInput | PromotionTagWhereUniqueInput[]
    delete?: PromotionTagWhereUniqueInput | PromotionTagWhereUniqueInput[]
    connect?: PromotionTagWhereUniqueInput | PromotionTagWhereUniqueInput[]
    update?: PromotionTagUpdateWithWhereUniqueWithoutPromotionInput | PromotionTagUpdateWithWhereUniqueWithoutPromotionInput[]
    updateMany?: PromotionTagUpdateManyWithWhereWithoutPromotionInput | PromotionTagUpdateManyWithWhereWithoutPromotionInput[]
    deleteMany?: PromotionTagScalarWhereInput | PromotionTagScalarWhereInput[]
  }

  export type CategoryCreateNestedOneWithoutCombosInput = {
    create?: XOR<CategoryCreateWithoutCombosInput, CategoryUncheckedCreateWithoutCombosInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutCombosInput
    connect?: CategoryWhereUniqueInput
  }

  export type EnterpriseCreateNestedOneWithoutCombosInput = {
    create?: XOR<EnterpriseCreateWithoutCombosInput, EnterpriseUncheckedCreateWithoutCombosInput>
    connectOrCreate?: EnterpriseCreateOrConnectWithoutCombosInput
    connect?: EnterpriseWhereUniqueInput
  }

  export type ProductCreateNestedManyWithoutCombosInput = {
    create?: XOR<ProductCreateWithoutCombosInput, ProductUncheckedCreateWithoutCombosInput> | ProductCreateWithoutCombosInput[] | ProductUncheckedCreateWithoutCombosInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCombosInput | ProductCreateOrConnectWithoutCombosInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ComboProductsCreateNestedManyWithoutComboInput = {
    create?: XOR<ComboProductsCreateWithoutComboInput, ComboProductsUncheckedCreateWithoutComboInput> | ComboProductsCreateWithoutComboInput[] | ComboProductsUncheckedCreateWithoutComboInput[]
    connectOrCreate?: ComboProductsCreateOrConnectWithoutComboInput | ComboProductsCreateOrConnectWithoutComboInput[]
    createMany?: ComboProductsCreateManyComboInputEnvelope
    connect?: ComboProductsWhereUniqueInput | ComboProductsWhereUniqueInput[]
  }

  export type ProductCreateNestedOneWithoutComboInput = {
    create?: XOR<ProductCreateWithoutComboInput, ProductUncheckedCreateWithoutComboInput>
    connectOrCreate?: ProductCreateOrConnectWithoutComboInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductUncheckedCreateNestedManyWithoutCombosInput = {
    create?: XOR<ProductCreateWithoutCombosInput, ProductUncheckedCreateWithoutCombosInput> | ProductCreateWithoutCombosInput[] | ProductUncheckedCreateWithoutCombosInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCombosInput | ProductCreateOrConnectWithoutCombosInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ComboProductsUncheckedCreateNestedManyWithoutComboInput = {
    create?: XOR<ComboProductsCreateWithoutComboInput, ComboProductsUncheckedCreateWithoutComboInput> | ComboProductsCreateWithoutComboInput[] | ComboProductsUncheckedCreateWithoutComboInput[]
    connectOrCreate?: ComboProductsCreateOrConnectWithoutComboInput | ComboProductsCreateOrConnectWithoutComboInput[]
    createMany?: ComboProductsCreateManyComboInputEnvelope
    connect?: ComboProductsWhereUniqueInput | ComboProductsWhereUniqueInput[]
  }

  export type CategoryUpdateOneRequiredWithoutCombosNestedInput = {
    create?: XOR<CategoryCreateWithoutCombosInput, CategoryUncheckedCreateWithoutCombosInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutCombosInput
    upsert?: CategoryUpsertWithoutCombosInput
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutCombosInput, CategoryUpdateWithoutCombosInput>, CategoryUncheckedUpdateWithoutCombosInput>
  }

  export type EnterpriseUpdateOneRequiredWithoutCombosNestedInput = {
    create?: XOR<EnterpriseCreateWithoutCombosInput, EnterpriseUncheckedCreateWithoutCombosInput>
    connectOrCreate?: EnterpriseCreateOrConnectWithoutCombosInput
    upsert?: EnterpriseUpsertWithoutCombosInput
    connect?: EnterpriseWhereUniqueInput
    update?: XOR<XOR<EnterpriseUpdateToOneWithWhereWithoutCombosInput, EnterpriseUpdateWithoutCombosInput>, EnterpriseUncheckedUpdateWithoutCombosInput>
  }

  export type ProductUpdateManyWithoutCombosNestedInput = {
    create?: XOR<ProductCreateWithoutCombosInput, ProductUncheckedCreateWithoutCombosInput> | ProductCreateWithoutCombosInput[] | ProductUncheckedCreateWithoutCombosInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCombosInput | ProductCreateOrConnectWithoutCombosInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutCombosInput | ProductUpsertWithWhereUniqueWithoutCombosInput[]
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutCombosInput | ProductUpdateWithWhereUniqueWithoutCombosInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutCombosInput | ProductUpdateManyWithWhereWithoutCombosInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ComboProductsUpdateManyWithoutComboNestedInput = {
    create?: XOR<ComboProductsCreateWithoutComboInput, ComboProductsUncheckedCreateWithoutComboInput> | ComboProductsCreateWithoutComboInput[] | ComboProductsUncheckedCreateWithoutComboInput[]
    connectOrCreate?: ComboProductsCreateOrConnectWithoutComboInput | ComboProductsCreateOrConnectWithoutComboInput[]
    upsert?: ComboProductsUpsertWithWhereUniqueWithoutComboInput | ComboProductsUpsertWithWhereUniqueWithoutComboInput[]
    createMany?: ComboProductsCreateManyComboInputEnvelope
    set?: ComboProductsWhereUniqueInput | ComboProductsWhereUniqueInput[]
    disconnect?: ComboProductsWhereUniqueInput | ComboProductsWhereUniqueInput[]
    delete?: ComboProductsWhereUniqueInput | ComboProductsWhereUniqueInput[]
    connect?: ComboProductsWhereUniqueInput | ComboProductsWhereUniqueInput[]
    update?: ComboProductsUpdateWithWhereUniqueWithoutComboInput | ComboProductsUpdateWithWhereUniqueWithoutComboInput[]
    updateMany?: ComboProductsUpdateManyWithWhereWithoutComboInput | ComboProductsUpdateManyWithWhereWithoutComboInput[]
    deleteMany?: ComboProductsScalarWhereInput | ComboProductsScalarWhereInput[]
  }

  export type ProductUpdateOneWithoutComboNestedInput = {
    create?: XOR<ProductCreateWithoutComboInput, ProductUncheckedCreateWithoutComboInput>
    connectOrCreate?: ProductCreateOrConnectWithoutComboInput
    upsert?: ProductUpsertWithoutComboInput
    disconnect?: ProductWhereInput | boolean
    delete?: ProductWhereInput | boolean
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutComboInput, ProductUpdateWithoutComboInput>, ProductUncheckedUpdateWithoutComboInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProductUncheckedUpdateManyWithoutCombosNestedInput = {
    create?: XOR<ProductCreateWithoutCombosInput, ProductUncheckedCreateWithoutCombosInput> | ProductCreateWithoutCombosInput[] | ProductUncheckedCreateWithoutCombosInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCombosInput | ProductCreateOrConnectWithoutCombosInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutCombosInput | ProductUpsertWithWhereUniqueWithoutCombosInput[]
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutCombosInput | ProductUpdateWithWhereUniqueWithoutCombosInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutCombosInput | ProductUpdateManyWithWhereWithoutCombosInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ComboProductsUncheckedUpdateManyWithoutComboNestedInput = {
    create?: XOR<ComboProductsCreateWithoutComboInput, ComboProductsUncheckedCreateWithoutComboInput> | ComboProductsCreateWithoutComboInput[] | ComboProductsUncheckedCreateWithoutComboInput[]
    connectOrCreate?: ComboProductsCreateOrConnectWithoutComboInput | ComboProductsCreateOrConnectWithoutComboInput[]
    upsert?: ComboProductsUpsertWithWhereUniqueWithoutComboInput | ComboProductsUpsertWithWhereUniqueWithoutComboInput[]
    createMany?: ComboProductsCreateManyComboInputEnvelope
    set?: ComboProductsWhereUniqueInput | ComboProductsWhereUniqueInput[]
    disconnect?: ComboProductsWhereUniqueInput | ComboProductsWhereUniqueInput[]
    delete?: ComboProductsWhereUniqueInput | ComboProductsWhereUniqueInput[]
    connect?: ComboProductsWhereUniqueInput | ComboProductsWhereUniqueInput[]
    update?: ComboProductsUpdateWithWhereUniqueWithoutComboInput | ComboProductsUpdateWithWhereUniqueWithoutComboInput[]
    updateMany?: ComboProductsUpdateManyWithWhereWithoutComboInput | ComboProductsUpdateManyWithWhereWithoutComboInput[]
    deleteMany?: ComboProductsScalarWhereInput | ComboProductsScalarWhereInput[]
  }

  export type ComboCreateNestedOneWithoutComboProductsInput = {
    create?: XOR<ComboCreateWithoutComboProductsInput, ComboUncheckedCreateWithoutComboProductsInput>
    connectOrCreate?: ComboCreateOrConnectWithoutComboProductsInput
    connect?: ComboWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutComboProductsInput = {
    create?: XOR<ProductCreateWithoutComboProductsInput, ProductUncheckedCreateWithoutComboProductsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutComboProductsInput
    connect?: ProductWhereUniqueInput
  }

  export type ComboUpdateOneRequiredWithoutComboProductsNestedInput = {
    create?: XOR<ComboCreateWithoutComboProductsInput, ComboUncheckedCreateWithoutComboProductsInput>
    connectOrCreate?: ComboCreateOrConnectWithoutComboProductsInput
    upsert?: ComboUpsertWithoutComboProductsInput
    connect?: ComboWhereUniqueInput
    update?: XOR<XOR<ComboUpdateToOneWithWhereWithoutComboProductsInput, ComboUpdateWithoutComboProductsInput>, ComboUncheckedUpdateWithoutComboProductsInput>
  }

  export type ProductUpdateOneRequiredWithoutComboProductsNestedInput = {
    create?: XOR<ProductCreateWithoutComboProductsInput, ProductUncheckedCreateWithoutComboProductsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutComboProductsInput
    upsert?: ProductUpsertWithoutComboProductsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutComboProductsInput, ProductUpdateWithoutComboProductsInput>, ProductUncheckedUpdateWithoutComboProductsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type OrderCreateWithoutUserInput = {
    uuid: string
    totalPrice: number
    status?: string
    updatedAt?: Date | string
    orderDate?: Date | string
    products?: ProductCreateNestedManyWithoutOrdersInput
    enterprise: EnterpriseCreateNestedOneWithoutOrdersInput
    orderItems?: OrderItemCreateNestedManyWithoutOrderInput
    orderHistories?: OrderHistoryCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutUserInput = {
    id?: number
    uuid: string
    totalPrice: number
    status?: string
    updatedAt?: Date | string
    orderDate?: Date | string
    enterpriseId: number
    products?: ProductUncheckedCreateNestedManyWithoutOrdersInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    orderHistories?: OrderHistoryUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutUserInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput>
  }

  export type OrderCreateManyUserInputEnvelope = {
    data: OrderCreateManyUserInput | OrderCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type EnterpriseCreateWithoutUsersInput = {
    uuid: string
    name: string
    responsiblePerson?: string | null
    phoneNumber?: string | null
    email?: string | null
    description?: string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    categories?: CategoryCreateNestedManyWithoutEnterpriseInput
    products?: ProductCreateNestedManyWithoutEnterpriseInput
    configurations?: ConfigurationCreateNestedManyWithoutEnterpriseInput
    orders?: OrderCreateNestedManyWithoutEnterpriseInput
    promotions?: PromotionCreateNestedManyWithoutEnterpriseInput
    combos?: ComboCreateNestedManyWithoutEnterpriseInput
  }

  export type EnterpriseUncheckedCreateWithoutUsersInput = {
    id?: number
    uuid: string
    name: string
    responsiblePerson?: string | null
    phoneNumber?: string | null
    email?: string | null
    description?: string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    categories?: CategoryUncheckedCreateNestedManyWithoutEnterpriseInput
    products?: ProductUncheckedCreateNestedManyWithoutEnterpriseInput
    configurations?: ConfigurationUncheckedCreateNestedManyWithoutEnterpriseInput
    orders?: OrderUncheckedCreateNestedManyWithoutEnterpriseInput
    promotions?: PromotionUncheckedCreateNestedManyWithoutEnterpriseInput
    combos?: ComboUncheckedCreateNestedManyWithoutEnterpriseInput
  }

  export type EnterpriseCreateOrConnectWithoutUsersInput = {
    where: EnterpriseWhereUniqueInput
    create: XOR<EnterpriseCreateWithoutUsersInput, EnterpriseUncheckedCreateWithoutUsersInput>
  }

  export type OrderUpsertWithWhereUniqueWithoutUserInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutUserInput, OrderUncheckedUpdateWithoutUserInput>
    create: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutUserInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutUserInput, OrderUncheckedUpdateWithoutUserInput>
  }

  export type OrderUpdateManyWithWhereWithoutUserInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutUserInput>
  }

  export type OrderScalarWhereInput = {
    AND?: OrderScalarWhereInput | OrderScalarWhereInput[]
    OR?: OrderScalarWhereInput[]
    NOT?: OrderScalarWhereInput | OrderScalarWhereInput[]
    id?: IntFilter<"Order"> | number
    uuid?: StringFilter<"Order"> | string
    totalPrice?: FloatFilter<"Order"> | number
    status?: StringFilter<"Order"> | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    orderDate?: DateTimeFilter<"Order"> | Date | string
    userId?: IntFilter<"Order"> | number
    enterpriseId?: IntFilter<"Order"> | number
  }

  export type EnterpriseUpsertWithoutUsersInput = {
    update: XOR<EnterpriseUpdateWithoutUsersInput, EnterpriseUncheckedUpdateWithoutUsersInput>
    create: XOR<EnterpriseCreateWithoutUsersInput, EnterpriseUncheckedCreateWithoutUsersInput>
    where?: EnterpriseWhereInput
  }

  export type EnterpriseUpdateToOneWithWhereWithoutUsersInput = {
    where?: EnterpriseWhereInput
    data: XOR<EnterpriseUpdateWithoutUsersInput, EnterpriseUncheckedUpdateWithoutUsersInput>
  }

  export type EnterpriseUpdateWithoutUsersInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    responsiblePerson?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categories?: CategoryUpdateManyWithoutEnterpriseNestedInput
    products?: ProductUpdateManyWithoutEnterpriseNestedInput
    configurations?: ConfigurationUpdateManyWithoutEnterpriseNestedInput
    orders?: OrderUpdateManyWithoutEnterpriseNestedInput
    promotions?: PromotionUpdateManyWithoutEnterpriseNestedInput
    combos?: ComboUpdateManyWithoutEnterpriseNestedInput
  }

  export type EnterpriseUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    responsiblePerson?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categories?: CategoryUncheckedUpdateManyWithoutEnterpriseNestedInput
    products?: ProductUncheckedUpdateManyWithoutEnterpriseNestedInput
    configurations?: ConfigurationUncheckedUpdateManyWithoutEnterpriseNestedInput
    orders?: OrderUncheckedUpdateManyWithoutEnterpriseNestedInput
    promotions?: PromotionUncheckedUpdateManyWithoutEnterpriseNestedInput
    combos?: ComboUncheckedUpdateManyWithoutEnterpriseNestedInput
  }

  export type ProductCreateWithoutCategoryInput = {
    uuid: string
    name: string
    description?: string | null
    type?: string
    price: number
    free?: boolean
    status?: string
    additionalsMax?: number
    accompanimentsMax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    enterprise: EnterpriseCreateNestedOneWithoutProductsInput
    accompaniments?: AccompanimentCreateNestedManyWithoutProductInput
    additionals?: AdditionalCreateNestedManyWithoutProductInput
    orders?: OrderCreateNestedManyWithoutProductsInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    productTags?: ProductTagCreateNestedManyWithoutProductInput
    combos?: ComboCreateNestedManyWithoutProductsInput
    ComboProducts?: ComboProductsCreateNestedManyWithoutProductInput
    Combo?: ComboCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutCategoryInput = {
    id?: number
    uuid: string
    name: string
    description?: string | null
    type?: string
    price: number
    free?: boolean
    status?: string
    additionalsMax?: number
    accompanimentsMax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    enterpriseId: number
    accompaniments?: AccompanimentUncheckedCreateNestedManyWithoutProductInput
    additionals?: AdditionalUncheckedCreateNestedManyWithoutProductInput
    orders?: OrderUncheckedCreateNestedManyWithoutProductsInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    productTags?: ProductTagUncheckedCreateNestedManyWithoutProductInput
    combos?: ComboUncheckedCreateNestedManyWithoutProductsInput
    ComboProducts?: ComboProductsUncheckedCreateNestedManyWithoutProductInput
    Combo?: ComboUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutCategoryInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput>
  }

  export type ProductCreateManyCategoryInputEnvelope = {
    data: ProductCreateManyCategoryInput | ProductCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type EnterpriseCreateWithoutCategoriesInput = {
    uuid: string
    name: string
    responsiblePerson?: string | null
    phoneNumber?: string | null
    email?: string | null
    description?: string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    users?: UserCreateNestedManyWithoutEnterpriseInput
    products?: ProductCreateNestedManyWithoutEnterpriseInput
    configurations?: ConfigurationCreateNestedManyWithoutEnterpriseInput
    orders?: OrderCreateNestedManyWithoutEnterpriseInput
    promotions?: PromotionCreateNestedManyWithoutEnterpriseInput
    combos?: ComboCreateNestedManyWithoutEnterpriseInput
  }

  export type EnterpriseUncheckedCreateWithoutCategoriesInput = {
    id?: number
    uuid: string
    name: string
    responsiblePerson?: string | null
    phoneNumber?: string | null
    email?: string | null
    description?: string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    users?: UserUncheckedCreateNestedManyWithoutEnterpriseInput
    products?: ProductUncheckedCreateNestedManyWithoutEnterpriseInput
    configurations?: ConfigurationUncheckedCreateNestedManyWithoutEnterpriseInput
    orders?: OrderUncheckedCreateNestedManyWithoutEnterpriseInput
    promotions?: PromotionUncheckedCreateNestedManyWithoutEnterpriseInput
    combos?: ComboUncheckedCreateNestedManyWithoutEnterpriseInput
  }

  export type EnterpriseCreateOrConnectWithoutCategoriesInput = {
    where: EnterpriseWhereUniqueInput
    create: XOR<EnterpriseCreateWithoutCategoriesInput, EnterpriseUncheckedCreateWithoutCategoriesInput>
  }

  export type PromotionCreateWithoutCategoryInput = {
    uuid: string
    name: string
    description?: string | null
    status: string
    discountRate: number
    startDate: Date | string
    endDate: Date | string
    deletedAt?: Date | string | null
    enterprise: EnterpriseCreateNestedOneWithoutPromotionsInput
    promotionTags?: PromotionTagCreateNestedManyWithoutPromotionInput
  }

  export type PromotionUncheckedCreateWithoutCategoryInput = {
    id?: number
    uuid: string
    name: string
    description?: string | null
    status: string
    discountRate: number
    startDate: Date | string
    endDate: Date | string
    enterpriseId: number
    deletedAt?: Date | string | null
    promotionTags?: PromotionTagUncheckedCreateNestedManyWithoutPromotionInput
  }

  export type PromotionCreateOrConnectWithoutCategoryInput = {
    where: PromotionWhereUniqueInput
    create: XOR<PromotionCreateWithoutCategoryInput, PromotionUncheckedCreateWithoutCategoryInput>
  }

  export type PromotionCreateManyCategoryInputEnvelope = {
    data: PromotionCreateManyCategoryInput | PromotionCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type ComboCreateWithoutCategoryInput = {
    uuid: string
    name: string
    description?: string | null
    price: number
    status: string
    enterprise: EnterpriseCreateNestedOneWithoutCombosInput
    products?: ProductCreateNestedManyWithoutCombosInput
    ComboProducts?: ComboProductsCreateNestedManyWithoutComboInput
    Product?: ProductCreateNestedOneWithoutComboInput
  }

  export type ComboUncheckedCreateWithoutCategoryInput = {
    id?: number
    uuid: string
    name: string
    description?: string | null
    price: number
    status: string
    enterpriseId: number
    productId?: number | null
    products?: ProductUncheckedCreateNestedManyWithoutCombosInput
    ComboProducts?: ComboProductsUncheckedCreateNestedManyWithoutComboInput
  }

  export type ComboCreateOrConnectWithoutCategoryInput = {
    where: ComboWhereUniqueInput
    create: XOR<ComboCreateWithoutCategoryInput, ComboUncheckedCreateWithoutCategoryInput>
  }

  export type ComboCreateManyCategoryInputEnvelope = {
    data: ComboCreateManyCategoryInput | ComboCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithWhereUniqueWithoutCategoryInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutCategoryInput, ProductUncheckedUpdateWithoutCategoryInput>
    create: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutCategoryInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutCategoryInput, ProductUncheckedUpdateWithoutCategoryInput>
  }

  export type ProductUpdateManyWithWhereWithoutCategoryInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutCategoryInput>
  }

  export type ProductScalarWhereInput = {
    AND?: ProductScalarWhereInput | ProductScalarWhereInput[]
    OR?: ProductScalarWhereInput[]
    NOT?: ProductScalarWhereInput | ProductScalarWhereInput[]
    id?: IntFilter<"Product"> | number
    uuid?: StringFilter<"Product"> | string
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    type?: StringFilter<"Product"> | string
    price?: FloatFilter<"Product"> | number
    free?: BoolFilter<"Product"> | boolean
    status?: StringFilter<"Product"> | string
    additionalsMax?: IntFilter<"Product"> | number
    accompanimentsMax?: IntFilter<"Product"> | number
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Product"> | Date | string | null
    categoryId?: IntFilter<"Product"> | number
    enterpriseId?: IntFilter<"Product"> | number
  }

  export type EnterpriseUpsertWithoutCategoriesInput = {
    update: XOR<EnterpriseUpdateWithoutCategoriesInput, EnterpriseUncheckedUpdateWithoutCategoriesInput>
    create: XOR<EnterpriseCreateWithoutCategoriesInput, EnterpriseUncheckedCreateWithoutCategoriesInput>
    where?: EnterpriseWhereInput
  }

  export type EnterpriseUpdateToOneWithWhereWithoutCategoriesInput = {
    where?: EnterpriseWhereInput
    data: XOR<EnterpriseUpdateWithoutCategoriesInput, EnterpriseUncheckedUpdateWithoutCategoriesInput>
  }

  export type EnterpriseUpdateWithoutCategoriesInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    responsiblePerson?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: UserUpdateManyWithoutEnterpriseNestedInput
    products?: ProductUpdateManyWithoutEnterpriseNestedInput
    configurations?: ConfigurationUpdateManyWithoutEnterpriseNestedInput
    orders?: OrderUpdateManyWithoutEnterpriseNestedInput
    promotions?: PromotionUpdateManyWithoutEnterpriseNestedInput
    combos?: ComboUpdateManyWithoutEnterpriseNestedInput
  }

  export type EnterpriseUncheckedUpdateWithoutCategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    responsiblePerson?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: UserUncheckedUpdateManyWithoutEnterpriseNestedInput
    products?: ProductUncheckedUpdateManyWithoutEnterpriseNestedInput
    configurations?: ConfigurationUncheckedUpdateManyWithoutEnterpriseNestedInput
    orders?: OrderUncheckedUpdateManyWithoutEnterpriseNestedInput
    promotions?: PromotionUncheckedUpdateManyWithoutEnterpriseNestedInput
    combos?: ComboUncheckedUpdateManyWithoutEnterpriseNestedInput
  }

  export type PromotionUpsertWithWhereUniqueWithoutCategoryInput = {
    where: PromotionWhereUniqueInput
    update: XOR<PromotionUpdateWithoutCategoryInput, PromotionUncheckedUpdateWithoutCategoryInput>
    create: XOR<PromotionCreateWithoutCategoryInput, PromotionUncheckedCreateWithoutCategoryInput>
  }

  export type PromotionUpdateWithWhereUniqueWithoutCategoryInput = {
    where: PromotionWhereUniqueInput
    data: XOR<PromotionUpdateWithoutCategoryInput, PromotionUncheckedUpdateWithoutCategoryInput>
  }

  export type PromotionUpdateManyWithWhereWithoutCategoryInput = {
    where: PromotionScalarWhereInput
    data: XOR<PromotionUpdateManyMutationInput, PromotionUncheckedUpdateManyWithoutCategoryInput>
  }

  export type PromotionScalarWhereInput = {
    AND?: PromotionScalarWhereInput | PromotionScalarWhereInput[]
    OR?: PromotionScalarWhereInput[]
    NOT?: PromotionScalarWhereInput | PromotionScalarWhereInput[]
    id?: IntFilter<"Promotion"> | number
    uuid?: StringFilter<"Promotion"> | string
    name?: StringFilter<"Promotion"> | string
    description?: StringNullableFilter<"Promotion"> | string | null
    status?: StringFilter<"Promotion"> | string
    discountRate?: FloatFilter<"Promotion"> | number
    startDate?: DateTimeFilter<"Promotion"> | Date | string
    endDate?: DateTimeFilter<"Promotion"> | Date | string
    categoryId?: IntFilter<"Promotion"> | number
    enterpriseId?: IntFilter<"Promotion"> | number
    deletedAt?: DateTimeNullableFilter<"Promotion"> | Date | string | null
  }

  export type ComboUpsertWithWhereUniqueWithoutCategoryInput = {
    where: ComboWhereUniqueInput
    update: XOR<ComboUpdateWithoutCategoryInput, ComboUncheckedUpdateWithoutCategoryInput>
    create: XOR<ComboCreateWithoutCategoryInput, ComboUncheckedCreateWithoutCategoryInput>
  }

  export type ComboUpdateWithWhereUniqueWithoutCategoryInput = {
    where: ComboWhereUniqueInput
    data: XOR<ComboUpdateWithoutCategoryInput, ComboUncheckedUpdateWithoutCategoryInput>
  }

  export type ComboUpdateManyWithWhereWithoutCategoryInput = {
    where: ComboScalarWhereInput
    data: XOR<ComboUpdateManyMutationInput, ComboUncheckedUpdateManyWithoutCategoryInput>
  }

  export type ComboScalarWhereInput = {
    AND?: ComboScalarWhereInput | ComboScalarWhereInput[]
    OR?: ComboScalarWhereInput[]
    NOT?: ComboScalarWhereInput | ComboScalarWhereInput[]
    id?: IntFilter<"Combo"> | number
    uuid?: StringFilter<"Combo"> | string
    name?: StringFilter<"Combo"> | string
    description?: StringNullableFilter<"Combo"> | string | null
    price?: FloatFilter<"Combo"> | number
    status?: StringFilter<"Combo"> | string
    categoryId?: IntFilter<"Combo"> | number
    enterpriseId?: IntFilter<"Combo"> | number
    productId?: IntNullableFilter<"Combo"> | number | null
  }

  export type CategoryCreateWithoutProductsInput = {
    uuid: string
    name: string
    description?: string | null
    status?: string
    enterprise: EnterpriseCreateNestedOneWithoutCategoriesInput
    promotions?: PromotionCreateNestedManyWithoutCategoryInput
    combos?: ComboCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutProductsInput = {
    id?: number
    uuid: string
    name: string
    description?: string | null
    status?: string
    enterpriseId: number
    promotions?: PromotionUncheckedCreateNestedManyWithoutCategoryInput
    combos?: ComboUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutProductsInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
  }

  export type EnterpriseCreateWithoutProductsInput = {
    uuid: string
    name: string
    responsiblePerson?: string | null
    phoneNumber?: string | null
    email?: string | null
    description?: string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    users?: UserCreateNestedManyWithoutEnterpriseInput
    categories?: CategoryCreateNestedManyWithoutEnterpriseInput
    configurations?: ConfigurationCreateNestedManyWithoutEnterpriseInput
    orders?: OrderCreateNestedManyWithoutEnterpriseInput
    promotions?: PromotionCreateNestedManyWithoutEnterpriseInput
    combos?: ComboCreateNestedManyWithoutEnterpriseInput
  }

  export type EnterpriseUncheckedCreateWithoutProductsInput = {
    id?: number
    uuid: string
    name: string
    responsiblePerson?: string | null
    phoneNumber?: string | null
    email?: string | null
    description?: string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    users?: UserUncheckedCreateNestedManyWithoutEnterpriseInput
    categories?: CategoryUncheckedCreateNestedManyWithoutEnterpriseInput
    configurations?: ConfigurationUncheckedCreateNestedManyWithoutEnterpriseInput
    orders?: OrderUncheckedCreateNestedManyWithoutEnterpriseInput
    promotions?: PromotionUncheckedCreateNestedManyWithoutEnterpriseInput
    combos?: ComboUncheckedCreateNestedManyWithoutEnterpriseInput
  }

  export type EnterpriseCreateOrConnectWithoutProductsInput = {
    where: EnterpriseWhereUniqueInput
    create: XOR<EnterpriseCreateWithoutProductsInput, EnterpriseUncheckedCreateWithoutProductsInput>
  }

  export type AccompanimentCreateWithoutProductInput = {
    uuid: string
  }

  export type AccompanimentUncheckedCreateWithoutProductInput = {
    id?: number
    uuid: string
  }

  export type AccompanimentCreateOrConnectWithoutProductInput = {
    where: AccompanimentWhereUniqueInput
    create: XOR<AccompanimentCreateWithoutProductInput, AccompanimentUncheckedCreateWithoutProductInput>
  }

  export type AccompanimentCreateManyProductInputEnvelope = {
    data: AccompanimentCreateManyProductInput | AccompanimentCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type AdditionalCreateWithoutProductInput = {
    uuid: string
  }

  export type AdditionalUncheckedCreateWithoutProductInput = {
    id?: number
    uuid: string
  }

  export type AdditionalCreateOrConnectWithoutProductInput = {
    where: AdditionalWhereUniqueInput
    create: XOR<AdditionalCreateWithoutProductInput, AdditionalUncheckedCreateWithoutProductInput>
  }

  export type AdditionalCreateManyProductInputEnvelope = {
    data: AdditionalCreateManyProductInput | AdditionalCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutProductsInput = {
    uuid: string
    totalPrice: number
    status?: string
    updatedAt?: Date | string
    orderDate?: Date | string
    user: UserCreateNestedOneWithoutOrdersInput
    enterprise: EnterpriseCreateNestedOneWithoutOrdersInput
    orderItems?: OrderItemCreateNestedManyWithoutOrderInput
    orderHistories?: OrderHistoryCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutProductsInput = {
    id?: number
    uuid: string
    totalPrice: number
    status?: string
    updatedAt?: Date | string
    orderDate?: Date | string
    userId: number
    enterpriseId: number
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    orderHistories?: OrderHistoryUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutProductsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutProductsInput, OrderUncheckedCreateWithoutProductsInput>
  }

  export type OrderItemCreateWithoutProductInput = {
    uuid: string
    quantity: number
    price: number
    order: OrderCreateNestedOneWithoutOrderItemsInput
  }

  export type OrderItemUncheckedCreateWithoutProductInput = {
    id?: number
    uuid: string
    quantity: number
    price: number
    orderId: number
  }

  export type OrderItemCreateOrConnectWithoutProductInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput>
  }

  export type OrderItemCreateManyProductInputEnvelope = {
    data: OrderItemCreateManyProductInput | OrderItemCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ProductTagCreateWithoutProductInput = {
    uuid: string
    tag: TagCreateNestedOneWithoutProductTagsInput
  }

  export type ProductTagUncheckedCreateWithoutProductInput = {
    id?: number
    uuid: string
    tagId: number
  }

  export type ProductTagCreateOrConnectWithoutProductInput = {
    where: ProductTagWhereUniqueInput
    create: XOR<ProductTagCreateWithoutProductInput, ProductTagUncheckedCreateWithoutProductInput>
  }

  export type ProductTagCreateManyProductInputEnvelope = {
    data: ProductTagCreateManyProductInput | ProductTagCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ComboCreateWithoutProductsInput = {
    uuid: string
    name: string
    description?: string | null
    price: number
    status: string
    category: CategoryCreateNestedOneWithoutCombosInput
    enterprise: EnterpriseCreateNestedOneWithoutCombosInput
    ComboProducts?: ComboProductsCreateNestedManyWithoutComboInput
    Product?: ProductCreateNestedOneWithoutComboInput
  }

  export type ComboUncheckedCreateWithoutProductsInput = {
    id?: number
    uuid: string
    name: string
    description?: string | null
    price: number
    status: string
    categoryId: number
    enterpriseId: number
    productId?: number | null
    ComboProducts?: ComboProductsUncheckedCreateNestedManyWithoutComboInput
  }

  export type ComboCreateOrConnectWithoutProductsInput = {
    where: ComboWhereUniqueInput
    create: XOR<ComboCreateWithoutProductsInput, ComboUncheckedCreateWithoutProductsInput>
  }

  export type ComboProductsCreateWithoutProductInput = {
    uuid: string
    combo: ComboCreateNestedOneWithoutComboProductsInput
  }

  export type ComboProductsUncheckedCreateWithoutProductInput = {
    id?: number
    uuid: string
    comboId: number
  }

  export type ComboProductsCreateOrConnectWithoutProductInput = {
    where: ComboProductsWhereUniqueInput
    create: XOR<ComboProductsCreateWithoutProductInput, ComboProductsUncheckedCreateWithoutProductInput>
  }

  export type ComboProductsCreateManyProductInputEnvelope = {
    data: ComboProductsCreateManyProductInput | ComboProductsCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ComboCreateWithoutProductInput = {
    uuid: string
    name: string
    description?: string | null
    price: number
    status: string
    category: CategoryCreateNestedOneWithoutCombosInput
    enterprise: EnterpriseCreateNestedOneWithoutCombosInput
    products?: ProductCreateNestedManyWithoutCombosInput
    ComboProducts?: ComboProductsCreateNestedManyWithoutComboInput
  }

  export type ComboUncheckedCreateWithoutProductInput = {
    id?: number
    uuid: string
    name: string
    description?: string | null
    price: number
    status: string
    categoryId: number
    enterpriseId: number
    products?: ProductUncheckedCreateNestedManyWithoutCombosInput
    ComboProducts?: ComboProductsUncheckedCreateNestedManyWithoutComboInput
  }

  export type ComboCreateOrConnectWithoutProductInput = {
    where: ComboWhereUniqueInput
    create: XOR<ComboCreateWithoutProductInput, ComboUncheckedCreateWithoutProductInput>
  }

  export type ComboCreateManyProductInputEnvelope = {
    data: ComboCreateManyProductInput | ComboCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type CategoryUpsertWithoutProductsInput = {
    update: XOR<CategoryUpdateWithoutProductsInput, CategoryUncheckedUpdateWithoutProductsInput>
    create: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutProductsInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutProductsInput, CategoryUncheckedUpdateWithoutProductsInput>
  }

  export type CategoryUpdateWithoutProductsInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    enterprise?: EnterpriseUpdateOneRequiredWithoutCategoriesNestedInput
    promotions?: PromotionUpdateManyWithoutCategoryNestedInput
    combos?: ComboUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    enterpriseId?: IntFieldUpdateOperationsInput | number
    promotions?: PromotionUncheckedUpdateManyWithoutCategoryNestedInput
    combos?: ComboUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type EnterpriseUpsertWithoutProductsInput = {
    update: XOR<EnterpriseUpdateWithoutProductsInput, EnterpriseUncheckedUpdateWithoutProductsInput>
    create: XOR<EnterpriseCreateWithoutProductsInput, EnterpriseUncheckedCreateWithoutProductsInput>
    where?: EnterpriseWhereInput
  }

  export type EnterpriseUpdateToOneWithWhereWithoutProductsInput = {
    where?: EnterpriseWhereInput
    data: XOR<EnterpriseUpdateWithoutProductsInput, EnterpriseUncheckedUpdateWithoutProductsInput>
  }

  export type EnterpriseUpdateWithoutProductsInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    responsiblePerson?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: UserUpdateManyWithoutEnterpriseNestedInput
    categories?: CategoryUpdateManyWithoutEnterpriseNestedInput
    configurations?: ConfigurationUpdateManyWithoutEnterpriseNestedInput
    orders?: OrderUpdateManyWithoutEnterpriseNestedInput
    promotions?: PromotionUpdateManyWithoutEnterpriseNestedInput
    combos?: ComboUpdateManyWithoutEnterpriseNestedInput
  }

  export type EnterpriseUncheckedUpdateWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    responsiblePerson?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: UserUncheckedUpdateManyWithoutEnterpriseNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutEnterpriseNestedInput
    configurations?: ConfigurationUncheckedUpdateManyWithoutEnterpriseNestedInput
    orders?: OrderUncheckedUpdateManyWithoutEnterpriseNestedInput
    promotions?: PromotionUncheckedUpdateManyWithoutEnterpriseNestedInput
    combos?: ComboUncheckedUpdateManyWithoutEnterpriseNestedInput
  }

  export type AccompanimentUpsertWithWhereUniqueWithoutProductInput = {
    where: AccompanimentWhereUniqueInput
    update: XOR<AccompanimentUpdateWithoutProductInput, AccompanimentUncheckedUpdateWithoutProductInput>
    create: XOR<AccompanimentCreateWithoutProductInput, AccompanimentUncheckedCreateWithoutProductInput>
  }

  export type AccompanimentUpdateWithWhereUniqueWithoutProductInput = {
    where: AccompanimentWhereUniqueInput
    data: XOR<AccompanimentUpdateWithoutProductInput, AccompanimentUncheckedUpdateWithoutProductInput>
  }

  export type AccompanimentUpdateManyWithWhereWithoutProductInput = {
    where: AccompanimentScalarWhereInput
    data: XOR<AccompanimentUpdateManyMutationInput, AccompanimentUncheckedUpdateManyWithoutProductInput>
  }

  export type AccompanimentScalarWhereInput = {
    AND?: AccompanimentScalarWhereInput | AccompanimentScalarWhereInput[]
    OR?: AccompanimentScalarWhereInput[]
    NOT?: AccompanimentScalarWhereInput | AccompanimentScalarWhereInput[]
    id?: IntFilter<"Accompaniment"> | number
    uuid?: StringFilter<"Accompaniment"> | string
    productId?: IntFilter<"Accompaniment"> | number
  }

  export type AdditionalUpsertWithWhereUniqueWithoutProductInput = {
    where: AdditionalWhereUniqueInput
    update: XOR<AdditionalUpdateWithoutProductInput, AdditionalUncheckedUpdateWithoutProductInput>
    create: XOR<AdditionalCreateWithoutProductInput, AdditionalUncheckedCreateWithoutProductInput>
  }

  export type AdditionalUpdateWithWhereUniqueWithoutProductInput = {
    where: AdditionalWhereUniqueInput
    data: XOR<AdditionalUpdateWithoutProductInput, AdditionalUncheckedUpdateWithoutProductInput>
  }

  export type AdditionalUpdateManyWithWhereWithoutProductInput = {
    where: AdditionalScalarWhereInput
    data: XOR<AdditionalUpdateManyMutationInput, AdditionalUncheckedUpdateManyWithoutProductInput>
  }

  export type AdditionalScalarWhereInput = {
    AND?: AdditionalScalarWhereInput | AdditionalScalarWhereInput[]
    OR?: AdditionalScalarWhereInput[]
    NOT?: AdditionalScalarWhereInput | AdditionalScalarWhereInput[]
    id?: IntFilter<"Additional"> | number
    uuid?: StringFilter<"Additional"> | string
    productId?: IntFilter<"Additional"> | number
  }

  export type OrderUpsertWithWhereUniqueWithoutProductsInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutProductsInput, OrderUncheckedUpdateWithoutProductsInput>
    create: XOR<OrderCreateWithoutProductsInput, OrderUncheckedCreateWithoutProductsInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutProductsInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutProductsInput, OrderUncheckedUpdateWithoutProductsInput>
  }

  export type OrderUpdateManyWithWhereWithoutProductsInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutProductsInput>
  }

  export type OrderItemUpsertWithWhereUniqueWithoutProductInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutProductInput, OrderItemUncheckedUpdateWithoutProductInput>
    create: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutProductInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutProductInput, OrderItemUncheckedUpdateWithoutProductInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutProductInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutProductInput>
  }

  export type OrderItemScalarWhereInput = {
    AND?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
    OR?: OrderItemScalarWhereInput[]
    NOT?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
    id?: IntFilter<"OrderItem"> | number
    uuid?: StringFilter<"OrderItem"> | string
    quantity?: IntFilter<"OrderItem"> | number
    price?: FloatFilter<"OrderItem"> | number
    productId?: IntFilter<"OrderItem"> | number
    orderId?: IntFilter<"OrderItem"> | number
  }

  export type ProductTagUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductTagWhereUniqueInput
    update: XOR<ProductTagUpdateWithoutProductInput, ProductTagUncheckedUpdateWithoutProductInput>
    create: XOR<ProductTagCreateWithoutProductInput, ProductTagUncheckedCreateWithoutProductInput>
  }

  export type ProductTagUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductTagWhereUniqueInput
    data: XOR<ProductTagUpdateWithoutProductInput, ProductTagUncheckedUpdateWithoutProductInput>
  }

  export type ProductTagUpdateManyWithWhereWithoutProductInput = {
    where: ProductTagScalarWhereInput
    data: XOR<ProductTagUpdateManyMutationInput, ProductTagUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductTagScalarWhereInput = {
    AND?: ProductTagScalarWhereInput | ProductTagScalarWhereInput[]
    OR?: ProductTagScalarWhereInput[]
    NOT?: ProductTagScalarWhereInput | ProductTagScalarWhereInput[]
    id?: IntFilter<"ProductTag"> | number
    uuid?: StringFilter<"ProductTag"> | string
    productId?: IntFilter<"ProductTag"> | number
    tagId?: IntFilter<"ProductTag"> | number
  }

  export type ComboUpsertWithWhereUniqueWithoutProductsInput = {
    where: ComboWhereUniqueInput
    update: XOR<ComboUpdateWithoutProductsInput, ComboUncheckedUpdateWithoutProductsInput>
    create: XOR<ComboCreateWithoutProductsInput, ComboUncheckedCreateWithoutProductsInput>
  }

  export type ComboUpdateWithWhereUniqueWithoutProductsInput = {
    where: ComboWhereUniqueInput
    data: XOR<ComboUpdateWithoutProductsInput, ComboUncheckedUpdateWithoutProductsInput>
  }

  export type ComboUpdateManyWithWhereWithoutProductsInput = {
    where: ComboScalarWhereInput
    data: XOR<ComboUpdateManyMutationInput, ComboUncheckedUpdateManyWithoutProductsInput>
  }

  export type ComboProductsUpsertWithWhereUniqueWithoutProductInput = {
    where: ComboProductsWhereUniqueInput
    update: XOR<ComboProductsUpdateWithoutProductInput, ComboProductsUncheckedUpdateWithoutProductInput>
    create: XOR<ComboProductsCreateWithoutProductInput, ComboProductsUncheckedCreateWithoutProductInput>
  }

  export type ComboProductsUpdateWithWhereUniqueWithoutProductInput = {
    where: ComboProductsWhereUniqueInput
    data: XOR<ComboProductsUpdateWithoutProductInput, ComboProductsUncheckedUpdateWithoutProductInput>
  }

  export type ComboProductsUpdateManyWithWhereWithoutProductInput = {
    where: ComboProductsScalarWhereInput
    data: XOR<ComboProductsUpdateManyMutationInput, ComboProductsUncheckedUpdateManyWithoutProductInput>
  }

  export type ComboProductsScalarWhereInput = {
    AND?: ComboProductsScalarWhereInput | ComboProductsScalarWhereInput[]
    OR?: ComboProductsScalarWhereInput[]
    NOT?: ComboProductsScalarWhereInput | ComboProductsScalarWhereInput[]
    id?: IntFilter<"ComboProducts"> | number
    uuid?: StringFilter<"ComboProducts"> | string
    comboId?: IntFilter<"ComboProducts"> | number
    productId?: IntFilter<"ComboProducts"> | number
  }

  export type ComboUpsertWithWhereUniqueWithoutProductInput = {
    where: ComboWhereUniqueInput
    update: XOR<ComboUpdateWithoutProductInput, ComboUncheckedUpdateWithoutProductInput>
    create: XOR<ComboCreateWithoutProductInput, ComboUncheckedCreateWithoutProductInput>
  }

  export type ComboUpdateWithWhereUniqueWithoutProductInput = {
    where: ComboWhereUniqueInput
    data: XOR<ComboUpdateWithoutProductInput, ComboUncheckedUpdateWithoutProductInput>
  }

  export type ComboUpdateManyWithWhereWithoutProductInput = {
    where: ComboScalarWhereInput
    data: XOR<ComboUpdateManyMutationInput, ComboUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductCreateWithoutAccompanimentsInput = {
    uuid: string
    name: string
    description?: string | null
    type?: string
    price: number
    free?: boolean
    status?: string
    additionalsMax?: number
    accompanimentsMax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    category: CategoryCreateNestedOneWithoutProductsInput
    enterprise: EnterpriseCreateNestedOneWithoutProductsInput
    additionals?: AdditionalCreateNestedManyWithoutProductInput
    orders?: OrderCreateNestedManyWithoutProductsInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    productTags?: ProductTagCreateNestedManyWithoutProductInput
    combos?: ComboCreateNestedManyWithoutProductsInput
    ComboProducts?: ComboProductsCreateNestedManyWithoutProductInput
    Combo?: ComboCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutAccompanimentsInput = {
    id?: number
    uuid: string
    name: string
    description?: string | null
    type?: string
    price: number
    free?: boolean
    status?: string
    additionalsMax?: number
    accompanimentsMax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    categoryId: number
    enterpriseId: number
    additionals?: AdditionalUncheckedCreateNestedManyWithoutProductInput
    orders?: OrderUncheckedCreateNestedManyWithoutProductsInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    productTags?: ProductTagUncheckedCreateNestedManyWithoutProductInput
    combos?: ComboUncheckedCreateNestedManyWithoutProductsInput
    ComboProducts?: ComboProductsUncheckedCreateNestedManyWithoutProductInput
    Combo?: ComboUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutAccompanimentsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutAccompanimentsInput, ProductUncheckedCreateWithoutAccompanimentsInput>
  }

  export type ProductUpsertWithoutAccompanimentsInput = {
    update: XOR<ProductUpdateWithoutAccompanimentsInput, ProductUncheckedUpdateWithoutAccompanimentsInput>
    create: XOR<ProductCreateWithoutAccompanimentsInput, ProductUncheckedCreateWithoutAccompanimentsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutAccompanimentsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutAccompanimentsInput, ProductUncheckedUpdateWithoutAccompanimentsInput>
  }

  export type ProductUpdateWithoutAccompanimentsInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    free?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    additionalsMax?: IntFieldUpdateOperationsInput | number
    accompanimentsMax?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: CategoryUpdateOneRequiredWithoutProductsNestedInput
    enterprise?: EnterpriseUpdateOneRequiredWithoutProductsNestedInput
    additionals?: AdditionalUpdateManyWithoutProductNestedInput
    orders?: OrderUpdateManyWithoutProductsNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    productTags?: ProductTagUpdateManyWithoutProductNestedInput
    combos?: ComboUpdateManyWithoutProductsNestedInput
    ComboProducts?: ComboProductsUpdateManyWithoutProductNestedInput
    Combo?: ComboUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutAccompanimentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    free?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    additionalsMax?: IntFieldUpdateOperationsInput | number
    accompanimentsMax?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categoryId?: IntFieldUpdateOperationsInput | number
    enterpriseId?: IntFieldUpdateOperationsInput | number
    additionals?: AdditionalUncheckedUpdateManyWithoutProductNestedInput
    orders?: OrderUncheckedUpdateManyWithoutProductsNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    productTags?: ProductTagUncheckedUpdateManyWithoutProductNestedInput
    combos?: ComboUncheckedUpdateManyWithoutProductsNestedInput
    ComboProducts?: ComboProductsUncheckedUpdateManyWithoutProductNestedInput
    Combo?: ComboUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateWithoutAdditionalsInput = {
    uuid: string
    name: string
    description?: string | null
    type?: string
    price: number
    free?: boolean
    status?: string
    additionalsMax?: number
    accompanimentsMax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    category: CategoryCreateNestedOneWithoutProductsInput
    enterprise: EnterpriseCreateNestedOneWithoutProductsInput
    accompaniments?: AccompanimentCreateNestedManyWithoutProductInput
    orders?: OrderCreateNestedManyWithoutProductsInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    productTags?: ProductTagCreateNestedManyWithoutProductInput
    combos?: ComboCreateNestedManyWithoutProductsInput
    ComboProducts?: ComboProductsCreateNestedManyWithoutProductInput
    Combo?: ComboCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutAdditionalsInput = {
    id?: number
    uuid: string
    name: string
    description?: string | null
    type?: string
    price: number
    free?: boolean
    status?: string
    additionalsMax?: number
    accompanimentsMax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    categoryId: number
    enterpriseId: number
    accompaniments?: AccompanimentUncheckedCreateNestedManyWithoutProductInput
    orders?: OrderUncheckedCreateNestedManyWithoutProductsInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    productTags?: ProductTagUncheckedCreateNestedManyWithoutProductInput
    combos?: ComboUncheckedCreateNestedManyWithoutProductsInput
    ComboProducts?: ComboProductsUncheckedCreateNestedManyWithoutProductInput
    Combo?: ComboUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutAdditionalsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutAdditionalsInput, ProductUncheckedCreateWithoutAdditionalsInput>
  }

  export type ProductUpsertWithoutAdditionalsInput = {
    update: XOR<ProductUpdateWithoutAdditionalsInput, ProductUncheckedUpdateWithoutAdditionalsInput>
    create: XOR<ProductCreateWithoutAdditionalsInput, ProductUncheckedCreateWithoutAdditionalsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutAdditionalsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutAdditionalsInput, ProductUncheckedUpdateWithoutAdditionalsInput>
  }

  export type ProductUpdateWithoutAdditionalsInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    free?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    additionalsMax?: IntFieldUpdateOperationsInput | number
    accompanimentsMax?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: CategoryUpdateOneRequiredWithoutProductsNestedInput
    enterprise?: EnterpriseUpdateOneRequiredWithoutProductsNestedInput
    accompaniments?: AccompanimentUpdateManyWithoutProductNestedInput
    orders?: OrderUpdateManyWithoutProductsNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    productTags?: ProductTagUpdateManyWithoutProductNestedInput
    combos?: ComboUpdateManyWithoutProductsNestedInput
    ComboProducts?: ComboProductsUpdateManyWithoutProductNestedInput
    Combo?: ComboUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutAdditionalsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    free?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    additionalsMax?: IntFieldUpdateOperationsInput | number
    accompanimentsMax?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categoryId?: IntFieldUpdateOperationsInput | number
    enterpriseId?: IntFieldUpdateOperationsInput | number
    accompaniments?: AccompanimentUncheckedUpdateManyWithoutProductNestedInput
    orders?: OrderUncheckedUpdateManyWithoutProductsNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    productTags?: ProductTagUncheckedUpdateManyWithoutProductNestedInput
    combos?: ComboUncheckedUpdateManyWithoutProductsNestedInput
    ComboProducts?: ComboProductsUncheckedUpdateManyWithoutProductNestedInput
    Combo?: ComboUncheckedUpdateManyWithoutProductNestedInput
  }

  export type UserCreateWithoutOrdersInput = {
    uuid: string
    email: string
    nickname: string
    role: string
    firstName?: string | null
    lastName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    enterprise?: EnterpriseCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutOrdersInput = {
    id?: number
    uuid: string
    email: string
    nickname: string
    role: string
    firstName?: string | null
    lastName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    enterpriseId: number
  }

  export type UserCreateOrConnectWithoutOrdersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
  }

  export type ProductCreateWithoutOrdersInput = {
    uuid: string
    name: string
    description?: string | null
    type?: string
    price: number
    free?: boolean
    status?: string
    additionalsMax?: number
    accompanimentsMax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    category: CategoryCreateNestedOneWithoutProductsInput
    enterprise: EnterpriseCreateNestedOneWithoutProductsInput
    accompaniments?: AccompanimentCreateNestedManyWithoutProductInput
    additionals?: AdditionalCreateNestedManyWithoutProductInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    productTags?: ProductTagCreateNestedManyWithoutProductInput
    combos?: ComboCreateNestedManyWithoutProductsInput
    ComboProducts?: ComboProductsCreateNestedManyWithoutProductInput
    Combo?: ComboCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutOrdersInput = {
    id?: number
    uuid: string
    name: string
    description?: string | null
    type?: string
    price: number
    free?: boolean
    status?: string
    additionalsMax?: number
    accompanimentsMax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    categoryId: number
    enterpriseId: number
    accompaniments?: AccompanimentUncheckedCreateNestedManyWithoutProductInput
    additionals?: AdditionalUncheckedCreateNestedManyWithoutProductInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    productTags?: ProductTagUncheckedCreateNestedManyWithoutProductInput
    combos?: ComboUncheckedCreateNestedManyWithoutProductsInput
    ComboProducts?: ComboProductsUncheckedCreateNestedManyWithoutProductInput
    Combo?: ComboUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutOrdersInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutOrdersInput, ProductUncheckedCreateWithoutOrdersInput>
  }

  export type EnterpriseCreateWithoutOrdersInput = {
    uuid: string
    name: string
    responsiblePerson?: string | null
    phoneNumber?: string | null
    email?: string | null
    description?: string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    users?: UserCreateNestedManyWithoutEnterpriseInput
    categories?: CategoryCreateNestedManyWithoutEnterpriseInput
    products?: ProductCreateNestedManyWithoutEnterpriseInput
    configurations?: ConfigurationCreateNestedManyWithoutEnterpriseInput
    promotions?: PromotionCreateNestedManyWithoutEnterpriseInput
    combos?: ComboCreateNestedManyWithoutEnterpriseInput
  }

  export type EnterpriseUncheckedCreateWithoutOrdersInput = {
    id?: number
    uuid: string
    name: string
    responsiblePerson?: string | null
    phoneNumber?: string | null
    email?: string | null
    description?: string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    users?: UserUncheckedCreateNestedManyWithoutEnterpriseInput
    categories?: CategoryUncheckedCreateNestedManyWithoutEnterpriseInput
    products?: ProductUncheckedCreateNestedManyWithoutEnterpriseInput
    configurations?: ConfigurationUncheckedCreateNestedManyWithoutEnterpriseInput
    promotions?: PromotionUncheckedCreateNestedManyWithoutEnterpriseInput
    combos?: ComboUncheckedCreateNestedManyWithoutEnterpriseInput
  }

  export type EnterpriseCreateOrConnectWithoutOrdersInput = {
    where: EnterpriseWhereUniqueInput
    create: XOR<EnterpriseCreateWithoutOrdersInput, EnterpriseUncheckedCreateWithoutOrdersInput>
  }

  export type OrderItemCreateWithoutOrderInput = {
    uuid: string
    quantity: number
    price: number
    product: ProductCreateNestedOneWithoutOrderItemsInput
  }

  export type OrderItemUncheckedCreateWithoutOrderInput = {
    id?: number
    uuid: string
    quantity: number
    price: number
    productId: number
  }

  export type OrderItemCreateOrConnectWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemCreateManyOrderInputEnvelope = {
    data: OrderItemCreateManyOrderInput | OrderItemCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type OrderHistoryCreateWithoutOrderInput = {
    uuid: string
    status: string
    description?: string | null
    createdAt?: Date | string
  }

  export type OrderHistoryUncheckedCreateWithoutOrderInput = {
    id?: number
    uuid: string
    status: string
    description?: string | null
    createdAt?: Date | string
  }

  export type OrderHistoryCreateOrConnectWithoutOrderInput = {
    where: OrderHistoryWhereUniqueInput
    create: XOR<OrderHistoryCreateWithoutOrderInput, OrderHistoryUncheckedCreateWithoutOrderInput>
  }

  export type OrderHistoryCreateManyOrderInputEnvelope = {
    data: OrderHistoryCreateManyOrderInput | OrderHistoryCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutOrdersInput = {
    update: XOR<UserUpdateWithoutOrdersInput, UserUncheckedUpdateWithoutOrdersInput>
    create: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOrdersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOrdersInput, UserUncheckedUpdateWithoutOrdersInput>
  }

  export type UserUpdateWithoutOrdersInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enterprise?: EnterpriseUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enterpriseId?: IntFieldUpdateOperationsInput | number
  }

  export type ProductUpsertWithWhereUniqueWithoutOrdersInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutOrdersInput, ProductUncheckedUpdateWithoutOrdersInput>
    create: XOR<ProductCreateWithoutOrdersInput, ProductUncheckedCreateWithoutOrdersInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutOrdersInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutOrdersInput, ProductUncheckedUpdateWithoutOrdersInput>
  }

  export type ProductUpdateManyWithWhereWithoutOrdersInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutOrdersInput>
  }

  export type EnterpriseUpsertWithoutOrdersInput = {
    update: XOR<EnterpriseUpdateWithoutOrdersInput, EnterpriseUncheckedUpdateWithoutOrdersInput>
    create: XOR<EnterpriseCreateWithoutOrdersInput, EnterpriseUncheckedCreateWithoutOrdersInput>
    where?: EnterpriseWhereInput
  }

  export type EnterpriseUpdateToOneWithWhereWithoutOrdersInput = {
    where?: EnterpriseWhereInput
    data: XOR<EnterpriseUpdateWithoutOrdersInput, EnterpriseUncheckedUpdateWithoutOrdersInput>
  }

  export type EnterpriseUpdateWithoutOrdersInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    responsiblePerson?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: UserUpdateManyWithoutEnterpriseNestedInput
    categories?: CategoryUpdateManyWithoutEnterpriseNestedInput
    products?: ProductUpdateManyWithoutEnterpriseNestedInput
    configurations?: ConfigurationUpdateManyWithoutEnterpriseNestedInput
    promotions?: PromotionUpdateManyWithoutEnterpriseNestedInput
    combos?: ComboUpdateManyWithoutEnterpriseNestedInput
  }

  export type EnterpriseUncheckedUpdateWithoutOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    responsiblePerson?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: UserUncheckedUpdateManyWithoutEnterpriseNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutEnterpriseNestedInput
    products?: ProductUncheckedUpdateManyWithoutEnterpriseNestedInput
    configurations?: ConfigurationUncheckedUpdateManyWithoutEnterpriseNestedInput
    promotions?: PromotionUncheckedUpdateManyWithoutEnterpriseNestedInput
    combos?: ComboUncheckedUpdateManyWithoutEnterpriseNestedInput
  }

  export type OrderItemUpsertWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutOrderInput, OrderItemUncheckedUpdateWithoutOrderInput>
    create: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutOrderInput, OrderItemUncheckedUpdateWithoutOrderInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutOrderInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutOrderInput>
  }

  export type OrderHistoryUpsertWithWhereUniqueWithoutOrderInput = {
    where: OrderHistoryWhereUniqueInput
    update: XOR<OrderHistoryUpdateWithoutOrderInput, OrderHistoryUncheckedUpdateWithoutOrderInput>
    create: XOR<OrderHistoryCreateWithoutOrderInput, OrderHistoryUncheckedCreateWithoutOrderInput>
  }

  export type OrderHistoryUpdateWithWhereUniqueWithoutOrderInput = {
    where: OrderHistoryWhereUniqueInput
    data: XOR<OrderHistoryUpdateWithoutOrderInput, OrderHistoryUncheckedUpdateWithoutOrderInput>
  }

  export type OrderHistoryUpdateManyWithWhereWithoutOrderInput = {
    where: OrderHistoryScalarWhereInput
    data: XOR<OrderHistoryUpdateManyMutationInput, OrderHistoryUncheckedUpdateManyWithoutOrderInput>
  }

  export type OrderHistoryScalarWhereInput = {
    AND?: OrderHistoryScalarWhereInput | OrderHistoryScalarWhereInput[]
    OR?: OrderHistoryScalarWhereInput[]
    NOT?: OrderHistoryScalarWhereInput | OrderHistoryScalarWhereInput[]
    id?: IntFilter<"OrderHistory"> | number
    uuid?: StringFilter<"OrderHistory"> | string
    status?: StringFilter<"OrderHistory"> | string
    description?: StringNullableFilter<"OrderHistory"> | string | null
    orderId?: IntFilter<"OrderHistory"> | number
    createdAt?: DateTimeFilter<"OrderHistory"> | Date | string
  }

  export type ProductCreateWithoutOrderItemsInput = {
    uuid: string
    name: string
    description?: string | null
    type?: string
    price: number
    free?: boolean
    status?: string
    additionalsMax?: number
    accompanimentsMax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    category: CategoryCreateNestedOneWithoutProductsInput
    enterprise: EnterpriseCreateNestedOneWithoutProductsInput
    accompaniments?: AccompanimentCreateNestedManyWithoutProductInput
    additionals?: AdditionalCreateNestedManyWithoutProductInput
    orders?: OrderCreateNestedManyWithoutProductsInput
    productTags?: ProductTagCreateNestedManyWithoutProductInput
    combos?: ComboCreateNestedManyWithoutProductsInput
    ComboProducts?: ComboProductsCreateNestedManyWithoutProductInput
    Combo?: ComboCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutOrderItemsInput = {
    id?: number
    uuid: string
    name: string
    description?: string | null
    type?: string
    price: number
    free?: boolean
    status?: string
    additionalsMax?: number
    accompanimentsMax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    categoryId: number
    enterpriseId: number
    accompaniments?: AccompanimentUncheckedCreateNestedManyWithoutProductInput
    additionals?: AdditionalUncheckedCreateNestedManyWithoutProductInput
    orders?: OrderUncheckedCreateNestedManyWithoutProductsInput
    productTags?: ProductTagUncheckedCreateNestedManyWithoutProductInput
    combos?: ComboUncheckedCreateNestedManyWithoutProductsInput
    ComboProducts?: ComboProductsUncheckedCreateNestedManyWithoutProductInput
    Combo?: ComboUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutOrderItemsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutOrderItemsInput, ProductUncheckedCreateWithoutOrderItemsInput>
  }

  export type OrderCreateWithoutOrderItemsInput = {
    uuid: string
    totalPrice: number
    status?: string
    updatedAt?: Date | string
    orderDate?: Date | string
    user: UserCreateNestedOneWithoutOrdersInput
    products?: ProductCreateNestedManyWithoutOrdersInput
    enterprise: EnterpriseCreateNestedOneWithoutOrdersInput
    orderHistories?: OrderHistoryCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutOrderItemsInput = {
    id?: number
    uuid: string
    totalPrice: number
    status?: string
    updatedAt?: Date | string
    orderDate?: Date | string
    userId: number
    enterpriseId: number
    products?: ProductUncheckedCreateNestedManyWithoutOrdersInput
    orderHistories?: OrderHistoryUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutOrderItemsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutOrderItemsInput, OrderUncheckedCreateWithoutOrderItemsInput>
  }

  export type ProductUpsertWithoutOrderItemsInput = {
    update: XOR<ProductUpdateWithoutOrderItemsInput, ProductUncheckedUpdateWithoutOrderItemsInput>
    create: XOR<ProductCreateWithoutOrderItemsInput, ProductUncheckedCreateWithoutOrderItemsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutOrderItemsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutOrderItemsInput, ProductUncheckedUpdateWithoutOrderItemsInput>
  }

  export type ProductUpdateWithoutOrderItemsInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    free?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    additionalsMax?: IntFieldUpdateOperationsInput | number
    accompanimentsMax?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: CategoryUpdateOneRequiredWithoutProductsNestedInput
    enterprise?: EnterpriseUpdateOneRequiredWithoutProductsNestedInput
    accompaniments?: AccompanimentUpdateManyWithoutProductNestedInput
    additionals?: AdditionalUpdateManyWithoutProductNestedInput
    orders?: OrderUpdateManyWithoutProductsNestedInput
    productTags?: ProductTagUpdateManyWithoutProductNestedInput
    combos?: ComboUpdateManyWithoutProductsNestedInput
    ComboProducts?: ComboProductsUpdateManyWithoutProductNestedInput
    Combo?: ComboUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutOrderItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    free?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    additionalsMax?: IntFieldUpdateOperationsInput | number
    accompanimentsMax?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categoryId?: IntFieldUpdateOperationsInput | number
    enterpriseId?: IntFieldUpdateOperationsInput | number
    accompaniments?: AccompanimentUncheckedUpdateManyWithoutProductNestedInput
    additionals?: AdditionalUncheckedUpdateManyWithoutProductNestedInput
    orders?: OrderUncheckedUpdateManyWithoutProductsNestedInput
    productTags?: ProductTagUncheckedUpdateManyWithoutProductNestedInput
    combos?: ComboUncheckedUpdateManyWithoutProductsNestedInput
    ComboProducts?: ComboProductsUncheckedUpdateManyWithoutProductNestedInput
    Combo?: ComboUncheckedUpdateManyWithoutProductNestedInput
  }

  export type OrderUpsertWithoutOrderItemsInput = {
    update: XOR<OrderUpdateWithoutOrderItemsInput, OrderUncheckedUpdateWithoutOrderItemsInput>
    create: XOR<OrderCreateWithoutOrderItemsInput, OrderUncheckedCreateWithoutOrderItemsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutOrderItemsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutOrderItemsInput, OrderUncheckedUpdateWithoutOrderItemsInput>
  }

  export type OrderUpdateWithoutOrderItemsInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    products?: ProductUpdateManyWithoutOrdersNestedInput
    enterprise?: EnterpriseUpdateOneRequiredWithoutOrdersNestedInput
    orderHistories?: OrderHistoryUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutOrderItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    enterpriseId?: IntFieldUpdateOperationsInput | number
    products?: ProductUncheckedUpdateManyWithoutOrdersNestedInput
    orderHistories?: OrderHistoryUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderCreateWithoutOrderHistoriesInput = {
    uuid: string
    totalPrice: number
    status?: string
    updatedAt?: Date | string
    orderDate?: Date | string
    user: UserCreateNestedOneWithoutOrdersInput
    products?: ProductCreateNestedManyWithoutOrdersInput
    enterprise: EnterpriseCreateNestedOneWithoutOrdersInput
    orderItems?: OrderItemCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutOrderHistoriesInput = {
    id?: number
    uuid: string
    totalPrice: number
    status?: string
    updatedAt?: Date | string
    orderDate?: Date | string
    userId: number
    enterpriseId: number
    products?: ProductUncheckedCreateNestedManyWithoutOrdersInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutOrderHistoriesInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutOrderHistoriesInput, OrderUncheckedCreateWithoutOrderHistoriesInput>
  }

  export type OrderUpsertWithoutOrderHistoriesInput = {
    update: XOR<OrderUpdateWithoutOrderHistoriesInput, OrderUncheckedUpdateWithoutOrderHistoriesInput>
    create: XOR<OrderCreateWithoutOrderHistoriesInput, OrderUncheckedCreateWithoutOrderHistoriesInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutOrderHistoriesInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutOrderHistoriesInput, OrderUncheckedUpdateWithoutOrderHistoriesInput>
  }

  export type OrderUpdateWithoutOrderHistoriesInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    products?: ProductUpdateManyWithoutOrdersNestedInput
    enterprise?: EnterpriseUpdateOneRequiredWithoutOrdersNestedInput
    orderItems?: OrderItemUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutOrderHistoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    enterpriseId?: IntFieldUpdateOperationsInput | number
    products?: ProductUncheckedUpdateManyWithoutOrdersNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type UserCreateWithoutEnterpriseInput = {
    uuid: string
    email: string
    nickname: string
    role: string
    firstName?: string | null
    lastName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    orders?: OrderCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEnterpriseInput = {
    id?: number
    uuid: string
    email: string
    nickname: string
    role: string
    firstName?: string | null
    lastName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEnterpriseInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEnterpriseInput, UserUncheckedCreateWithoutEnterpriseInput>
  }

  export type UserCreateManyEnterpriseInputEnvelope = {
    data: UserCreateManyEnterpriseInput | UserCreateManyEnterpriseInput[]
    skipDuplicates?: boolean
  }

  export type CategoryCreateWithoutEnterpriseInput = {
    uuid: string
    name: string
    description?: string | null
    status?: string
    products?: ProductCreateNestedManyWithoutCategoryInput
    promotions?: PromotionCreateNestedManyWithoutCategoryInput
    combos?: ComboCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutEnterpriseInput = {
    id?: number
    uuid: string
    name: string
    description?: string | null
    status?: string
    products?: ProductUncheckedCreateNestedManyWithoutCategoryInput
    promotions?: PromotionUncheckedCreateNestedManyWithoutCategoryInput
    combos?: ComboUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutEnterpriseInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutEnterpriseInput, CategoryUncheckedCreateWithoutEnterpriseInput>
  }

  export type CategoryCreateManyEnterpriseInputEnvelope = {
    data: CategoryCreateManyEnterpriseInput | CategoryCreateManyEnterpriseInput[]
    skipDuplicates?: boolean
  }

  export type ProductCreateWithoutEnterpriseInput = {
    uuid: string
    name: string
    description?: string | null
    type?: string
    price: number
    free?: boolean
    status?: string
    additionalsMax?: number
    accompanimentsMax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    category: CategoryCreateNestedOneWithoutProductsInput
    accompaniments?: AccompanimentCreateNestedManyWithoutProductInput
    additionals?: AdditionalCreateNestedManyWithoutProductInput
    orders?: OrderCreateNestedManyWithoutProductsInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    productTags?: ProductTagCreateNestedManyWithoutProductInput
    combos?: ComboCreateNestedManyWithoutProductsInput
    ComboProducts?: ComboProductsCreateNestedManyWithoutProductInput
    Combo?: ComboCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutEnterpriseInput = {
    id?: number
    uuid: string
    name: string
    description?: string | null
    type?: string
    price: number
    free?: boolean
    status?: string
    additionalsMax?: number
    accompanimentsMax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    categoryId: number
    accompaniments?: AccompanimentUncheckedCreateNestedManyWithoutProductInput
    additionals?: AdditionalUncheckedCreateNestedManyWithoutProductInput
    orders?: OrderUncheckedCreateNestedManyWithoutProductsInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    productTags?: ProductTagUncheckedCreateNestedManyWithoutProductInput
    combos?: ComboUncheckedCreateNestedManyWithoutProductsInput
    ComboProducts?: ComboProductsUncheckedCreateNestedManyWithoutProductInput
    Combo?: ComboUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutEnterpriseInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutEnterpriseInput, ProductUncheckedCreateWithoutEnterpriseInput>
  }

  export type ProductCreateManyEnterpriseInputEnvelope = {
    data: ProductCreateManyEnterpriseInput | ProductCreateManyEnterpriseInput[]
    skipDuplicates?: boolean
  }

  export type ConfigurationCreateWithoutEnterpriseInput = {
    uuid: string
    configKey: string
    configValue: string
    configText?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConfigurationUncheckedCreateWithoutEnterpriseInput = {
    id?: number
    uuid: string
    configKey: string
    configValue: string
    configText?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConfigurationCreateOrConnectWithoutEnterpriseInput = {
    where: ConfigurationWhereUniqueInput
    create: XOR<ConfigurationCreateWithoutEnterpriseInput, ConfigurationUncheckedCreateWithoutEnterpriseInput>
  }

  export type ConfigurationCreateManyEnterpriseInputEnvelope = {
    data: ConfigurationCreateManyEnterpriseInput | ConfigurationCreateManyEnterpriseInput[]
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutEnterpriseInput = {
    uuid: string
    totalPrice: number
    status?: string
    updatedAt?: Date | string
    orderDate?: Date | string
    user: UserCreateNestedOneWithoutOrdersInput
    products?: ProductCreateNestedManyWithoutOrdersInput
    orderItems?: OrderItemCreateNestedManyWithoutOrderInput
    orderHistories?: OrderHistoryCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutEnterpriseInput = {
    id?: number
    uuid: string
    totalPrice: number
    status?: string
    updatedAt?: Date | string
    orderDate?: Date | string
    userId: number
    products?: ProductUncheckedCreateNestedManyWithoutOrdersInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    orderHistories?: OrderHistoryUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutEnterpriseInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutEnterpriseInput, OrderUncheckedCreateWithoutEnterpriseInput>
  }

  export type OrderCreateManyEnterpriseInputEnvelope = {
    data: OrderCreateManyEnterpriseInput | OrderCreateManyEnterpriseInput[]
    skipDuplicates?: boolean
  }

  export type PromotionCreateWithoutEnterpriseInput = {
    uuid: string
    name: string
    description?: string | null
    status: string
    discountRate: number
    startDate: Date | string
    endDate: Date | string
    deletedAt?: Date | string | null
    category: CategoryCreateNestedOneWithoutPromotionsInput
    promotionTags?: PromotionTagCreateNestedManyWithoutPromotionInput
  }

  export type PromotionUncheckedCreateWithoutEnterpriseInput = {
    id?: number
    uuid: string
    name: string
    description?: string | null
    status: string
    discountRate: number
    startDate: Date | string
    endDate: Date | string
    categoryId: number
    deletedAt?: Date | string | null
    promotionTags?: PromotionTagUncheckedCreateNestedManyWithoutPromotionInput
  }

  export type PromotionCreateOrConnectWithoutEnterpriseInput = {
    where: PromotionWhereUniqueInput
    create: XOR<PromotionCreateWithoutEnterpriseInput, PromotionUncheckedCreateWithoutEnterpriseInput>
  }

  export type PromotionCreateManyEnterpriseInputEnvelope = {
    data: PromotionCreateManyEnterpriseInput | PromotionCreateManyEnterpriseInput[]
    skipDuplicates?: boolean
  }

  export type ComboCreateWithoutEnterpriseInput = {
    uuid: string
    name: string
    description?: string | null
    price: number
    status: string
    category: CategoryCreateNestedOneWithoutCombosInput
    products?: ProductCreateNestedManyWithoutCombosInput
    ComboProducts?: ComboProductsCreateNestedManyWithoutComboInput
    Product?: ProductCreateNestedOneWithoutComboInput
  }

  export type ComboUncheckedCreateWithoutEnterpriseInput = {
    id?: number
    uuid: string
    name: string
    description?: string | null
    price: number
    status: string
    categoryId: number
    productId?: number | null
    products?: ProductUncheckedCreateNestedManyWithoutCombosInput
    ComboProducts?: ComboProductsUncheckedCreateNestedManyWithoutComboInput
  }

  export type ComboCreateOrConnectWithoutEnterpriseInput = {
    where: ComboWhereUniqueInput
    create: XOR<ComboCreateWithoutEnterpriseInput, ComboUncheckedCreateWithoutEnterpriseInput>
  }

  export type ComboCreateManyEnterpriseInputEnvelope = {
    data: ComboCreateManyEnterpriseInput | ComboCreateManyEnterpriseInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutEnterpriseInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutEnterpriseInput, UserUncheckedUpdateWithoutEnterpriseInput>
    create: XOR<UserCreateWithoutEnterpriseInput, UserUncheckedCreateWithoutEnterpriseInput>
  }

  export type UserUpdateWithWhereUniqueWithoutEnterpriseInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutEnterpriseInput, UserUncheckedUpdateWithoutEnterpriseInput>
  }

  export type UserUpdateManyWithWhereWithoutEnterpriseInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutEnterpriseInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: IntFilter<"User"> | number
    uuid?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    nickname?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    deletedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    enterpriseId?: IntFilter<"User"> | number
  }

  export type CategoryUpsertWithWhereUniqueWithoutEnterpriseInput = {
    where: CategoryWhereUniqueInput
    update: XOR<CategoryUpdateWithoutEnterpriseInput, CategoryUncheckedUpdateWithoutEnterpriseInput>
    create: XOR<CategoryCreateWithoutEnterpriseInput, CategoryUncheckedCreateWithoutEnterpriseInput>
  }

  export type CategoryUpdateWithWhereUniqueWithoutEnterpriseInput = {
    where: CategoryWhereUniqueInput
    data: XOR<CategoryUpdateWithoutEnterpriseInput, CategoryUncheckedUpdateWithoutEnterpriseInput>
  }

  export type CategoryUpdateManyWithWhereWithoutEnterpriseInput = {
    where: CategoryScalarWhereInput
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyWithoutEnterpriseInput>
  }

  export type CategoryScalarWhereInput = {
    AND?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
    OR?: CategoryScalarWhereInput[]
    NOT?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
    id?: IntFilter<"Category"> | number
    uuid?: StringFilter<"Category"> | string
    name?: StringFilter<"Category"> | string
    description?: StringNullableFilter<"Category"> | string | null
    status?: StringFilter<"Category"> | string
    enterpriseId?: IntFilter<"Category"> | number
  }

  export type ProductUpsertWithWhereUniqueWithoutEnterpriseInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutEnterpriseInput, ProductUncheckedUpdateWithoutEnterpriseInput>
    create: XOR<ProductCreateWithoutEnterpriseInput, ProductUncheckedCreateWithoutEnterpriseInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutEnterpriseInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutEnterpriseInput, ProductUncheckedUpdateWithoutEnterpriseInput>
  }

  export type ProductUpdateManyWithWhereWithoutEnterpriseInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutEnterpriseInput>
  }

  export type ConfigurationUpsertWithWhereUniqueWithoutEnterpriseInput = {
    where: ConfigurationWhereUniqueInput
    update: XOR<ConfigurationUpdateWithoutEnterpriseInput, ConfigurationUncheckedUpdateWithoutEnterpriseInput>
    create: XOR<ConfigurationCreateWithoutEnterpriseInput, ConfigurationUncheckedCreateWithoutEnterpriseInput>
  }

  export type ConfigurationUpdateWithWhereUniqueWithoutEnterpriseInput = {
    where: ConfigurationWhereUniqueInput
    data: XOR<ConfigurationUpdateWithoutEnterpriseInput, ConfigurationUncheckedUpdateWithoutEnterpriseInput>
  }

  export type ConfigurationUpdateManyWithWhereWithoutEnterpriseInput = {
    where: ConfigurationScalarWhereInput
    data: XOR<ConfigurationUpdateManyMutationInput, ConfigurationUncheckedUpdateManyWithoutEnterpriseInput>
  }

  export type ConfigurationScalarWhereInput = {
    AND?: ConfigurationScalarWhereInput | ConfigurationScalarWhereInput[]
    OR?: ConfigurationScalarWhereInput[]
    NOT?: ConfigurationScalarWhereInput | ConfigurationScalarWhereInput[]
    id?: IntFilter<"Configuration"> | number
    uuid?: StringFilter<"Configuration"> | string
    configKey?: StringFilter<"Configuration"> | string
    configValue?: StringFilter<"Configuration"> | string
    configText?: StringNullableFilter<"Configuration"> | string | null
    createdAt?: DateTimeFilter<"Configuration"> | Date | string
    updatedAt?: DateTimeFilter<"Configuration"> | Date | string
    enterpriseId?: IntFilter<"Configuration"> | number
  }

  export type OrderUpsertWithWhereUniqueWithoutEnterpriseInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutEnterpriseInput, OrderUncheckedUpdateWithoutEnterpriseInput>
    create: XOR<OrderCreateWithoutEnterpriseInput, OrderUncheckedCreateWithoutEnterpriseInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutEnterpriseInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutEnterpriseInput, OrderUncheckedUpdateWithoutEnterpriseInput>
  }

  export type OrderUpdateManyWithWhereWithoutEnterpriseInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutEnterpriseInput>
  }

  export type PromotionUpsertWithWhereUniqueWithoutEnterpriseInput = {
    where: PromotionWhereUniqueInput
    update: XOR<PromotionUpdateWithoutEnterpriseInput, PromotionUncheckedUpdateWithoutEnterpriseInput>
    create: XOR<PromotionCreateWithoutEnterpriseInput, PromotionUncheckedCreateWithoutEnterpriseInput>
  }

  export type PromotionUpdateWithWhereUniqueWithoutEnterpriseInput = {
    where: PromotionWhereUniqueInput
    data: XOR<PromotionUpdateWithoutEnterpriseInput, PromotionUncheckedUpdateWithoutEnterpriseInput>
  }

  export type PromotionUpdateManyWithWhereWithoutEnterpriseInput = {
    where: PromotionScalarWhereInput
    data: XOR<PromotionUpdateManyMutationInput, PromotionUncheckedUpdateManyWithoutEnterpriseInput>
  }

  export type ComboUpsertWithWhereUniqueWithoutEnterpriseInput = {
    where: ComboWhereUniqueInput
    update: XOR<ComboUpdateWithoutEnterpriseInput, ComboUncheckedUpdateWithoutEnterpriseInput>
    create: XOR<ComboCreateWithoutEnterpriseInput, ComboUncheckedCreateWithoutEnterpriseInput>
  }

  export type ComboUpdateWithWhereUniqueWithoutEnterpriseInput = {
    where: ComboWhereUniqueInput
    data: XOR<ComboUpdateWithoutEnterpriseInput, ComboUncheckedUpdateWithoutEnterpriseInput>
  }

  export type ComboUpdateManyWithWhereWithoutEnterpriseInput = {
    where: ComboScalarWhereInput
    data: XOR<ComboUpdateManyMutationInput, ComboUncheckedUpdateManyWithoutEnterpriseInput>
  }

  export type EnterpriseCreateWithoutConfigurationsInput = {
    uuid: string
    name: string
    responsiblePerson?: string | null
    phoneNumber?: string | null
    email?: string | null
    description?: string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    users?: UserCreateNestedManyWithoutEnterpriseInput
    categories?: CategoryCreateNestedManyWithoutEnterpriseInput
    products?: ProductCreateNestedManyWithoutEnterpriseInput
    orders?: OrderCreateNestedManyWithoutEnterpriseInput
    promotions?: PromotionCreateNestedManyWithoutEnterpriseInput
    combos?: ComboCreateNestedManyWithoutEnterpriseInput
  }

  export type EnterpriseUncheckedCreateWithoutConfigurationsInput = {
    id?: number
    uuid: string
    name: string
    responsiblePerson?: string | null
    phoneNumber?: string | null
    email?: string | null
    description?: string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    users?: UserUncheckedCreateNestedManyWithoutEnterpriseInput
    categories?: CategoryUncheckedCreateNestedManyWithoutEnterpriseInput
    products?: ProductUncheckedCreateNestedManyWithoutEnterpriseInput
    orders?: OrderUncheckedCreateNestedManyWithoutEnterpriseInput
    promotions?: PromotionUncheckedCreateNestedManyWithoutEnterpriseInput
    combos?: ComboUncheckedCreateNestedManyWithoutEnterpriseInput
  }

  export type EnterpriseCreateOrConnectWithoutConfigurationsInput = {
    where: EnterpriseWhereUniqueInput
    create: XOR<EnterpriseCreateWithoutConfigurationsInput, EnterpriseUncheckedCreateWithoutConfigurationsInput>
  }

  export type EnterpriseUpsertWithoutConfigurationsInput = {
    update: XOR<EnterpriseUpdateWithoutConfigurationsInput, EnterpriseUncheckedUpdateWithoutConfigurationsInput>
    create: XOR<EnterpriseCreateWithoutConfigurationsInput, EnterpriseUncheckedCreateWithoutConfigurationsInput>
    where?: EnterpriseWhereInput
  }

  export type EnterpriseUpdateToOneWithWhereWithoutConfigurationsInput = {
    where?: EnterpriseWhereInput
    data: XOR<EnterpriseUpdateWithoutConfigurationsInput, EnterpriseUncheckedUpdateWithoutConfigurationsInput>
  }

  export type EnterpriseUpdateWithoutConfigurationsInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    responsiblePerson?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: UserUpdateManyWithoutEnterpriseNestedInput
    categories?: CategoryUpdateManyWithoutEnterpriseNestedInput
    products?: ProductUpdateManyWithoutEnterpriseNestedInput
    orders?: OrderUpdateManyWithoutEnterpriseNestedInput
    promotions?: PromotionUpdateManyWithoutEnterpriseNestedInput
    combos?: ComboUpdateManyWithoutEnterpriseNestedInput
  }

  export type EnterpriseUncheckedUpdateWithoutConfigurationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    responsiblePerson?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: UserUncheckedUpdateManyWithoutEnterpriseNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutEnterpriseNestedInput
    products?: ProductUncheckedUpdateManyWithoutEnterpriseNestedInput
    orders?: OrderUncheckedUpdateManyWithoutEnterpriseNestedInput
    promotions?: PromotionUncheckedUpdateManyWithoutEnterpriseNestedInput
    combos?: ComboUncheckedUpdateManyWithoutEnterpriseNestedInput
  }

  export type ProductTagCreateWithoutTagInput = {
    uuid: string
    product: ProductCreateNestedOneWithoutProductTagsInput
  }

  export type ProductTagUncheckedCreateWithoutTagInput = {
    id?: number
    uuid: string
    productId: number
  }

  export type ProductTagCreateOrConnectWithoutTagInput = {
    where: ProductTagWhereUniqueInput
    create: XOR<ProductTagCreateWithoutTagInput, ProductTagUncheckedCreateWithoutTagInput>
  }

  export type ProductTagCreateManyTagInputEnvelope = {
    data: ProductTagCreateManyTagInput | ProductTagCreateManyTagInput[]
    skipDuplicates?: boolean
  }

  export type PromotionTagCreateWithoutTagInput = {
    uuid: string
    promotion: PromotionCreateNestedOneWithoutPromotionTagsInput
  }

  export type PromotionTagUncheckedCreateWithoutTagInput = {
    id?: number
    uuid: string
    promotionId: number
  }

  export type PromotionTagCreateOrConnectWithoutTagInput = {
    where: PromotionTagWhereUniqueInput
    create: XOR<PromotionTagCreateWithoutTagInput, PromotionTagUncheckedCreateWithoutTagInput>
  }

  export type PromotionTagCreateManyTagInputEnvelope = {
    data: PromotionTagCreateManyTagInput | PromotionTagCreateManyTagInput[]
    skipDuplicates?: boolean
  }

  export type ProductTagUpsertWithWhereUniqueWithoutTagInput = {
    where: ProductTagWhereUniqueInput
    update: XOR<ProductTagUpdateWithoutTagInput, ProductTagUncheckedUpdateWithoutTagInput>
    create: XOR<ProductTagCreateWithoutTagInput, ProductTagUncheckedCreateWithoutTagInput>
  }

  export type ProductTagUpdateWithWhereUniqueWithoutTagInput = {
    where: ProductTagWhereUniqueInput
    data: XOR<ProductTagUpdateWithoutTagInput, ProductTagUncheckedUpdateWithoutTagInput>
  }

  export type ProductTagUpdateManyWithWhereWithoutTagInput = {
    where: ProductTagScalarWhereInput
    data: XOR<ProductTagUpdateManyMutationInput, ProductTagUncheckedUpdateManyWithoutTagInput>
  }

  export type PromotionTagUpsertWithWhereUniqueWithoutTagInput = {
    where: PromotionTagWhereUniqueInput
    update: XOR<PromotionTagUpdateWithoutTagInput, PromotionTagUncheckedUpdateWithoutTagInput>
    create: XOR<PromotionTagCreateWithoutTagInput, PromotionTagUncheckedCreateWithoutTagInput>
  }

  export type PromotionTagUpdateWithWhereUniqueWithoutTagInput = {
    where: PromotionTagWhereUniqueInput
    data: XOR<PromotionTagUpdateWithoutTagInput, PromotionTagUncheckedUpdateWithoutTagInput>
  }

  export type PromotionTagUpdateManyWithWhereWithoutTagInput = {
    where: PromotionTagScalarWhereInput
    data: XOR<PromotionTagUpdateManyMutationInput, PromotionTagUncheckedUpdateManyWithoutTagInput>
  }

  export type PromotionTagScalarWhereInput = {
    AND?: PromotionTagScalarWhereInput | PromotionTagScalarWhereInput[]
    OR?: PromotionTagScalarWhereInput[]
    NOT?: PromotionTagScalarWhereInput | PromotionTagScalarWhereInput[]
    id?: IntFilter<"PromotionTag"> | number
    uuid?: StringFilter<"PromotionTag"> | string
    promotionId?: IntFilter<"PromotionTag"> | number
    tagId?: IntFilter<"PromotionTag"> | number
  }

  export type ProductCreateWithoutProductTagsInput = {
    uuid: string
    name: string
    description?: string | null
    type?: string
    price: number
    free?: boolean
    status?: string
    additionalsMax?: number
    accompanimentsMax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    category: CategoryCreateNestedOneWithoutProductsInput
    enterprise: EnterpriseCreateNestedOneWithoutProductsInput
    accompaniments?: AccompanimentCreateNestedManyWithoutProductInput
    additionals?: AdditionalCreateNestedManyWithoutProductInput
    orders?: OrderCreateNestedManyWithoutProductsInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    combos?: ComboCreateNestedManyWithoutProductsInput
    ComboProducts?: ComboProductsCreateNestedManyWithoutProductInput
    Combo?: ComboCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutProductTagsInput = {
    id?: number
    uuid: string
    name: string
    description?: string | null
    type?: string
    price: number
    free?: boolean
    status?: string
    additionalsMax?: number
    accompanimentsMax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    categoryId: number
    enterpriseId: number
    accompaniments?: AccompanimentUncheckedCreateNestedManyWithoutProductInput
    additionals?: AdditionalUncheckedCreateNestedManyWithoutProductInput
    orders?: OrderUncheckedCreateNestedManyWithoutProductsInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    combos?: ComboUncheckedCreateNestedManyWithoutProductsInput
    ComboProducts?: ComboProductsUncheckedCreateNestedManyWithoutProductInput
    Combo?: ComboUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutProductTagsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutProductTagsInput, ProductUncheckedCreateWithoutProductTagsInput>
  }

  export type TagCreateWithoutProductTagsInput = {
    uuid: string
    name: string
    textColor: string
    backgroundColor: string
    status?: string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    description?: string | null
    promotionTags?: PromotionTagCreateNestedManyWithoutTagInput
  }

  export type TagUncheckedCreateWithoutProductTagsInput = {
    id?: number
    uuid: string
    name: string
    textColor: string
    backgroundColor: string
    status?: string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    description?: string | null
    promotionTags?: PromotionTagUncheckedCreateNestedManyWithoutTagInput
  }

  export type TagCreateOrConnectWithoutProductTagsInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutProductTagsInput, TagUncheckedCreateWithoutProductTagsInput>
  }

  export type ProductUpsertWithoutProductTagsInput = {
    update: XOR<ProductUpdateWithoutProductTagsInput, ProductUncheckedUpdateWithoutProductTagsInput>
    create: XOR<ProductCreateWithoutProductTagsInput, ProductUncheckedCreateWithoutProductTagsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutProductTagsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutProductTagsInput, ProductUncheckedUpdateWithoutProductTagsInput>
  }

  export type ProductUpdateWithoutProductTagsInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    free?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    additionalsMax?: IntFieldUpdateOperationsInput | number
    accompanimentsMax?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: CategoryUpdateOneRequiredWithoutProductsNestedInput
    enterprise?: EnterpriseUpdateOneRequiredWithoutProductsNestedInput
    accompaniments?: AccompanimentUpdateManyWithoutProductNestedInput
    additionals?: AdditionalUpdateManyWithoutProductNestedInput
    orders?: OrderUpdateManyWithoutProductsNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    combos?: ComboUpdateManyWithoutProductsNestedInput
    ComboProducts?: ComboProductsUpdateManyWithoutProductNestedInput
    Combo?: ComboUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutProductTagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    free?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    additionalsMax?: IntFieldUpdateOperationsInput | number
    accompanimentsMax?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categoryId?: IntFieldUpdateOperationsInput | number
    enterpriseId?: IntFieldUpdateOperationsInput | number
    accompaniments?: AccompanimentUncheckedUpdateManyWithoutProductNestedInput
    additionals?: AdditionalUncheckedUpdateManyWithoutProductNestedInput
    orders?: OrderUncheckedUpdateManyWithoutProductsNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    combos?: ComboUncheckedUpdateManyWithoutProductsNestedInput
    ComboProducts?: ComboProductsUncheckedUpdateManyWithoutProductNestedInput
    Combo?: ComboUncheckedUpdateManyWithoutProductNestedInput
  }

  export type TagUpsertWithoutProductTagsInput = {
    update: XOR<TagUpdateWithoutProductTagsInput, TagUncheckedUpdateWithoutProductTagsInput>
    create: XOR<TagCreateWithoutProductTagsInput, TagUncheckedCreateWithoutProductTagsInput>
    where?: TagWhereInput
  }

  export type TagUpdateToOneWithWhereWithoutProductTagsInput = {
    where?: TagWhereInput
    data: XOR<TagUpdateWithoutProductTagsInput, TagUncheckedUpdateWithoutProductTagsInput>
  }

  export type TagUpdateWithoutProductTagsInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    textColor?: StringFieldUpdateOperationsInput | string
    backgroundColor?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    promotionTags?: PromotionTagUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateWithoutProductTagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    textColor?: StringFieldUpdateOperationsInput | string
    backgroundColor?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    promotionTags?: PromotionTagUncheckedUpdateManyWithoutTagNestedInput
  }

  export type PromotionCreateWithoutPromotionTagsInput = {
    uuid: string
    name: string
    description?: string | null
    status: string
    discountRate: number
    startDate: Date | string
    endDate: Date | string
    deletedAt?: Date | string | null
    category: CategoryCreateNestedOneWithoutPromotionsInput
    enterprise: EnterpriseCreateNestedOneWithoutPromotionsInput
  }

  export type PromotionUncheckedCreateWithoutPromotionTagsInput = {
    id?: number
    uuid: string
    name: string
    description?: string | null
    status: string
    discountRate: number
    startDate: Date | string
    endDate: Date | string
    categoryId: number
    enterpriseId: number
    deletedAt?: Date | string | null
  }

  export type PromotionCreateOrConnectWithoutPromotionTagsInput = {
    where: PromotionWhereUniqueInput
    create: XOR<PromotionCreateWithoutPromotionTagsInput, PromotionUncheckedCreateWithoutPromotionTagsInput>
  }

  export type TagCreateWithoutPromotionTagsInput = {
    uuid: string
    name: string
    textColor: string
    backgroundColor: string
    status?: string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    description?: string | null
    productTags?: ProductTagCreateNestedManyWithoutTagInput
  }

  export type TagUncheckedCreateWithoutPromotionTagsInput = {
    id?: number
    uuid: string
    name: string
    textColor: string
    backgroundColor: string
    status?: string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    description?: string | null
    productTags?: ProductTagUncheckedCreateNestedManyWithoutTagInput
  }

  export type TagCreateOrConnectWithoutPromotionTagsInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutPromotionTagsInput, TagUncheckedCreateWithoutPromotionTagsInput>
  }

  export type PromotionUpsertWithoutPromotionTagsInput = {
    update: XOR<PromotionUpdateWithoutPromotionTagsInput, PromotionUncheckedUpdateWithoutPromotionTagsInput>
    create: XOR<PromotionCreateWithoutPromotionTagsInput, PromotionUncheckedCreateWithoutPromotionTagsInput>
    where?: PromotionWhereInput
  }

  export type PromotionUpdateToOneWithWhereWithoutPromotionTagsInput = {
    where?: PromotionWhereInput
    data: XOR<PromotionUpdateWithoutPromotionTagsInput, PromotionUncheckedUpdateWithoutPromotionTagsInput>
  }

  export type PromotionUpdateWithoutPromotionTagsInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    discountRate?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: CategoryUpdateOneRequiredWithoutPromotionsNestedInput
    enterprise?: EnterpriseUpdateOneRequiredWithoutPromotionsNestedInput
  }

  export type PromotionUncheckedUpdateWithoutPromotionTagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    discountRate?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    categoryId?: IntFieldUpdateOperationsInput | number
    enterpriseId?: IntFieldUpdateOperationsInput | number
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TagUpsertWithoutPromotionTagsInput = {
    update: XOR<TagUpdateWithoutPromotionTagsInput, TagUncheckedUpdateWithoutPromotionTagsInput>
    create: XOR<TagCreateWithoutPromotionTagsInput, TagUncheckedCreateWithoutPromotionTagsInput>
    where?: TagWhereInput
  }

  export type TagUpdateToOneWithWhereWithoutPromotionTagsInput = {
    where?: TagWhereInput
    data: XOR<TagUpdateWithoutPromotionTagsInput, TagUncheckedUpdateWithoutPromotionTagsInput>
  }

  export type TagUpdateWithoutPromotionTagsInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    textColor?: StringFieldUpdateOperationsInput | string
    backgroundColor?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    productTags?: ProductTagUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateWithoutPromotionTagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    textColor?: StringFieldUpdateOperationsInput | string
    backgroundColor?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    productTags?: ProductTagUncheckedUpdateManyWithoutTagNestedInput
  }

  export type CategoryCreateWithoutPromotionsInput = {
    uuid: string
    name: string
    description?: string | null
    status?: string
    products?: ProductCreateNestedManyWithoutCategoryInput
    enterprise: EnterpriseCreateNestedOneWithoutCategoriesInput
    combos?: ComboCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutPromotionsInput = {
    id?: number
    uuid: string
    name: string
    description?: string | null
    status?: string
    enterpriseId: number
    products?: ProductUncheckedCreateNestedManyWithoutCategoryInput
    combos?: ComboUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutPromotionsInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutPromotionsInput, CategoryUncheckedCreateWithoutPromotionsInput>
  }

  export type EnterpriseCreateWithoutPromotionsInput = {
    uuid: string
    name: string
    responsiblePerson?: string | null
    phoneNumber?: string | null
    email?: string | null
    description?: string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    users?: UserCreateNestedManyWithoutEnterpriseInput
    categories?: CategoryCreateNestedManyWithoutEnterpriseInput
    products?: ProductCreateNestedManyWithoutEnterpriseInput
    configurations?: ConfigurationCreateNestedManyWithoutEnterpriseInput
    orders?: OrderCreateNestedManyWithoutEnterpriseInput
    combos?: ComboCreateNestedManyWithoutEnterpriseInput
  }

  export type EnterpriseUncheckedCreateWithoutPromotionsInput = {
    id?: number
    uuid: string
    name: string
    responsiblePerson?: string | null
    phoneNumber?: string | null
    email?: string | null
    description?: string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    users?: UserUncheckedCreateNestedManyWithoutEnterpriseInput
    categories?: CategoryUncheckedCreateNestedManyWithoutEnterpriseInput
    products?: ProductUncheckedCreateNestedManyWithoutEnterpriseInput
    configurations?: ConfigurationUncheckedCreateNestedManyWithoutEnterpriseInput
    orders?: OrderUncheckedCreateNestedManyWithoutEnterpriseInput
    combos?: ComboUncheckedCreateNestedManyWithoutEnterpriseInput
  }

  export type EnterpriseCreateOrConnectWithoutPromotionsInput = {
    where: EnterpriseWhereUniqueInput
    create: XOR<EnterpriseCreateWithoutPromotionsInput, EnterpriseUncheckedCreateWithoutPromotionsInput>
  }

  export type PromotionTagCreateWithoutPromotionInput = {
    uuid: string
    tag: TagCreateNestedOneWithoutPromotionTagsInput
  }

  export type PromotionTagUncheckedCreateWithoutPromotionInput = {
    id?: number
    uuid: string
    tagId: number
  }

  export type PromotionTagCreateOrConnectWithoutPromotionInput = {
    where: PromotionTagWhereUniqueInput
    create: XOR<PromotionTagCreateWithoutPromotionInput, PromotionTagUncheckedCreateWithoutPromotionInput>
  }

  export type PromotionTagCreateManyPromotionInputEnvelope = {
    data: PromotionTagCreateManyPromotionInput | PromotionTagCreateManyPromotionInput[]
    skipDuplicates?: boolean
  }

  export type CategoryUpsertWithoutPromotionsInput = {
    update: XOR<CategoryUpdateWithoutPromotionsInput, CategoryUncheckedUpdateWithoutPromotionsInput>
    create: XOR<CategoryCreateWithoutPromotionsInput, CategoryUncheckedCreateWithoutPromotionsInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutPromotionsInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutPromotionsInput, CategoryUncheckedUpdateWithoutPromotionsInput>
  }

  export type CategoryUpdateWithoutPromotionsInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    products?: ProductUpdateManyWithoutCategoryNestedInput
    enterprise?: EnterpriseUpdateOneRequiredWithoutCategoriesNestedInput
    combos?: ComboUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutPromotionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    enterpriseId?: IntFieldUpdateOperationsInput | number
    products?: ProductUncheckedUpdateManyWithoutCategoryNestedInput
    combos?: ComboUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type EnterpriseUpsertWithoutPromotionsInput = {
    update: XOR<EnterpriseUpdateWithoutPromotionsInput, EnterpriseUncheckedUpdateWithoutPromotionsInput>
    create: XOR<EnterpriseCreateWithoutPromotionsInput, EnterpriseUncheckedCreateWithoutPromotionsInput>
    where?: EnterpriseWhereInput
  }

  export type EnterpriseUpdateToOneWithWhereWithoutPromotionsInput = {
    where?: EnterpriseWhereInput
    data: XOR<EnterpriseUpdateWithoutPromotionsInput, EnterpriseUncheckedUpdateWithoutPromotionsInput>
  }

  export type EnterpriseUpdateWithoutPromotionsInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    responsiblePerson?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: UserUpdateManyWithoutEnterpriseNestedInput
    categories?: CategoryUpdateManyWithoutEnterpriseNestedInput
    products?: ProductUpdateManyWithoutEnterpriseNestedInput
    configurations?: ConfigurationUpdateManyWithoutEnterpriseNestedInput
    orders?: OrderUpdateManyWithoutEnterpriseNestedInput
    combos?: ComboUpdateManyWithoutEnterpriseNestedInput
  }

  export type EnterpriseUncheckedUpdateWithoutPromotionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    responsiblePerson?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: UserUncheckedUpdateManyWithoutEnterpriseNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutEnterpriseNestedInput
    products?: ProductUncheckedUpdateManyWithoutEnterpriseNestedInput
    configurations?: ConfigurationUncheckedUpdateManyWithoutEnterpriseNestedInput
    orders?: OrderUncheckedUpdateManyWithoutEnterpriseNestedInput
    combos?: ComboUncheckedUpdateManyWithoutEnterpriseNestedInput
  }

  export type PromotionTagUpsertWithWhereUniqueWithoutPromotionInput = {
    where: PromotionTagWhereUniqueInput
    update: XOR<PromotionTagUpdateWithoutPromotionInput, PromotionTagUncheckedUpdateWithoutPromotionInput>
    create: XOR<PromotionTagCreateWithoutPromotionInput, PromotionTagUncheckedCreateWithoutPromotionInput>
  }

  export type PromotionTagUpdateWithWhereUniqueWithoutPromotionInput = {
    where: PromotionTagWhereUniqueInput
    data: XOR<PromotionTagUpdateWithoutPromotionInput, PromotionTagUncheckedUpdateWithoutPromotionInput>
  }

  export type PromotionTagUpdateManyWithWhereWithoutPromotionInput = {
    where: PromotionTagScalarWhereInput
    data: XOR<PromotionTagUpdateManyMutationInput, PromotionTagUncheckedUpdateManyWithoutPromotionInput>
  }

  export type CategoryCreateWithoutCombosInput = {
    uuid: string
    name: string
    description?: string | null
    status?: string
    products?: ProductCreateNestedManyWithoutCategoryInput
    enterprise: EnterpriseCreateNestedOneWithoutCategoriesInput
    promotions?: PromotionCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutCombosInput = {
    id?: number
    uuid: string
    name: string
    description?: string | null
    status?: string
    enterpriseId: number
    products?: ProductUncheckedCreateNestedManyWithoutCategoryInput
    promotions?: PromotionUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutCombosInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutCombosInput, CategoryUncheckedCreateWithoutCombosInput>
  }

  export type EnterpriseCreateWithoutCombosInput = {
    uuid: string
    name: string
    responsiblePerson?: string | null
    phoneNumber?: string | null
    email?: string | null
    description?: string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    users?: UserCreateNestedManyWithoutEnterpriseInput
    categories?: CategoryCreateNestedManyWithoutEnterpriseInput
    products?: ProductCreateNestedManyWithoutEnterpriseInput
    configurations?: ConfigurationCreateNestedManyWithoutEnterpriseInput
    orders?: OrderCreateNestedManyWithoutEnterpriseInput
    promotions?: PromotionCreateNestedManyWithoutEnterpriseInput
  }

  export type EnterpriseUncheckedCreateWithoutCombosInput = {
    id?: number
    uuid: string
    name: string
    responsiblePerson?: string | null
    phoneNumber?: string | null
    email?: string | null
    description?: string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    users?: UserUncheckedCreateNestedManyWithoutEnterpriseInput
    categories?: CategoryUncheckedCreateNestedManyWithoutEnterpriseInput
    products?: ProductUncheckedCreateNestedManyWithoutEnterpriseInput
    configurations?: ConfigurationUncheckedCreateNestedManyWithoutEnterpriseInput
    orders?: OrderUncheckedCreateNestedManyWithoutEnterpriseInput
    promotions?: PromotionUncheckedCreateNestedManyWithoutEnterpriseInput
  }

  export type EnterpriseCreateOrConnectWithoutCombosInput = {
    where: EnterpriseWhereUniqueInput
    create: XOR<EnterpriseCreateWithoutCombosInput, EnterpriseUncheckedCreateWithoutCombosInput>
  }

  export type ProductCreateWithoutCombosInput = {
    uuid: string
    name: string
    description?: string | null
    type?: string
    price: number
    free?: boolean
    status?: string
    additionalsMax?: number
    accompanimentsMax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    category: CategoryCreateNestedOneWithoutProductsInput
    enterprise: EnterpriseCreateNestedOneWithoutProductsInput
    accompaniments?: AccompanimentCreateNestedManyWithoutProductInput
    additionals?: AdditionalCreateNestedManyWithoutProductInput
    orders?: OrderCreateNestedManyWithoutProductsInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    productTags?: ProductTagCreateNestedManyWithoutProductInput
    ComboProducts?: ComboProductsCreateNestedManyWithoutProductInput
    Combo?: ComboCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutCombosInput = {
    id?: number
    uuid: string
    name: string
    description?: string | null
    type?: string
    price: number
    free?: boolean
    status?: string
    additionalsMax?: number
    accompanimentsMax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    categoryId: number
    enterpriseId: number
    accompaniments?: AccompanimentUncheckedCreateNestedManyWithoutProductInput
    additionals?: AdditionalUncheckedCreateNestedManyWithoutProductInput
    orders?: OrderUncheckedCreateNestedManyWithoutProductsInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    productTags?: ProductTagUncheckedCreateNestedManyWithoutProductInput
    ComboProducts?: ComboProductsUncheckedCreateNestedManyWithoutProductInput
    Combo?: ComboUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutCombosInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutCombosInput, ProductUncheckedCreateWithoutCombosInput>
  }

  export type ComboProductsCreateWithoutComboInput = {
    uuid: string
    product: ProductCreateNestedOneWithoutComboProductsInput
  }

  export type ComboProductsUncheckedCreateWithoutComboInput = {
    id?: number
    uuid: string
    productId: number
  }

  export type ComboProductsCreateOrConnectWithoutComboInput = {
    where: ComboProductsWhereUniqueInput
    create: XOR<ComboProductsCreateWithoutComboInput, ComboProductsUncheckedCreateWithoutComboInput>
  }

  export type ComboProductsCreateManyComboInputEnvelope = {
    data: ComboProductsCreateManyComboInput | ComboProductsCreateManyComboInput[]
    skipDuplicates?: boolean
  }

  export type ProductCreateWithoutComboInput = {
    uuid: string
    name: string
    description?: string | null
    type?: string
    price: number
    free?: boolean
    status?: string
    additionalsMax?: number
    accompanimentsMax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    category: CategoryCreateNestedOneWithoutProductsInput
    enterprise: EnterpriseCreateNestedOneWithoutProductsInput
    accompaniments?: AccompanimentCreateNestedManyWithoutProductInput
    additionals?: AdditionalCreateNestedManyWithoutProductInput
    orders?: OrderCreateNestedManyWithoutProductsInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    productTags?: ProductTagCreateNestedManyWithoutProductInput
    combos?: ComboCreateNestedManyWithoutProductsInput
    ComboProducts?: ComboProductsCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutComboInput = {
    id?: number
    uuid: string
    name: string
    description?: string | null
    type?: string
    price: number
    free?: boolean
    status?: string
    additionalsMax?: number
    accompanimentsMax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    categoryId: number
    enterpriseId: number
    accompaniments?: AccompanimentUncheckedCreateNestedManyWithoutProductInput
    additionals?: AdditionalUncheckedCreateNestedManyWithoutProductInput
    orders?: OrderUncheckedCreateNestedManyWithoutProductsInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    productTags?: ProductTagUncheckedCreateNestedManyWithoutProductInput
    combos?: ComboUncheckedCreateNestedManyWithoutProductsInput
    ComboProducts?: ComboProductsUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutComboInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutComboInput, ProductUncheckedCreateWithoutComboInput>
  }

  export type CategoryUpsertWithoutCombosInput = {
    update: XOR<CategoryUpdateWithoutCombosInput, CategoryUncheckedUpdateWithoutCombosInput>
    create: XOR<CategoryCreateWithoutCombosInput, CategoryUncheckedCreateWithoutCombosInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutCombosInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutCombosInput, CategoryUncheckedUpdateWithoutCombosInput>
  }

  export type CategoryUpdateWithoutCombosInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    products?: ProductUpdateManyWithoutCategoryNestedInput
    enterprise?: EnterpriseUpdateOneRequiredWithoutCategoriesNestedInput
    promotions?: PromotionUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutCombosInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    enterpriseId?: IntFieldUpdateOperationsInput | number
    products?: ProductUncheckedUpdateManyWithoutCategoryNestedInput
    promotions?: PromotionUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type EnterpriseUpsertWithoutCombosInput = {
    update: XOR<EnterpriseUpdateWithoutCombosInput, EnterpriseUncheckedUpdateWithoutCombosInput>
    create: XOR<EnterpriseCreateWithoutCombosInput, EnterpriseUncheckedCreateWithoutCombosInput>
    where?: EnterpriseWhereInput
  }

  export type EnterpriseUpdateToOneWithWhereWithoutCombosInput = {
    where?: EnterpriseWhereInput
    data: XOR<EnterpriseUpdateWithoutCombosInput, EnterpriseUncheckedUpdateWithoutCombosInput>
  }

  export type EnterpriseUpdateWithoutCombosInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    responsiblePerson?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: UserUpdateManyWithoutEnterpriseNestedInput
    categories?: CategoryUpdateManyWithoutEnterpriseNestedInput
    products?: ProductUpdateManyWithoutEnterpriseNestedInput
    configurations?: ConfigurationUpdateManyWithoutEnterpriseNestedInput
    orders?: OrderUpdateManyWithoutEnterpriseNestedInput
    promotions?: PromotionUpdateManyWithoutEnterpriseNestedInput
  }

  export type EnterpriseUncheckedUpdateWithoutCombosInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    responsiblePerson?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: UserUncheckedUpdateManyWithoutEnterpriseNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutEnterpriseNestedInput
    products?: ProductUncheckedUpdateManyWithoutEnterpriseNestedInput
    configurations?: ConfigurationUncheckedUpdateManyWithoutEnterpriseNestedInput
    orders?: OrderUncheckedUpdateManyWithoutEnterpriseNestedInput
    promotions?: PromotionUncheckedUpdateManyWithoutEnterpriseNestedInput
  }

  export type ProductUpsertWithWhereUniqueWithoutCombosInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutCombosInput, ProductUncheckedUpdateWithoutCombosInput>
    create: XOR<ProductCreateWithoutCombosInput, ProductUncheckedCreateWithoutCombosInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutCombosInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutCombosInput, ProductUncheckedUpdateWithoutCombosInput>
  }

  export type ProductUpdateManyWithWhereWithoutCombosInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutCombosInput>
  }

  export type ComboProductsUpsertWithWhereUniqueWithoutComboInput = {
    where: ComboProductsWhereUniqueInput
    update: XOR<ComboProductsUpdateWithoutComboInput, ComboProductsUncheckedUpdateWithoutComboInput>
    create: XOR<ComboProductsCreateWithoutComboInput, ComboProductsUncheckedCreateWithoutComboInput>
  }

  export type ComboProductsUpdateWithWhereUniqueWithoutComboInput = {
    where: ComboProductsWhereUniqueInput
    data: XOR<ComboProductsUpdateWithoutComboInput, ComboProductsUncheckedUpdateWithoutComboInput>
  }

  export type ComboProductsUpdateManyWithWhereWithoutComboInput = {
    where: ComboProductsScalarWhereInput
    data: XOR<ComboProductsUpdateManyMutationInput, ComboProductsUncheckedUpdateManyWithoutComboInput>
  }

  export type ProductUpsertWithoutComboInput = {
    update: XOR<ProductUpdateWithoutComboInput, ProductUncheckedUpdateWithoutComboInput>
    create: XOR<ProductCreateWithoutComboInput, ProductUncheckedCreateWithoutComboInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutComboInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutComboInput, ProductUncheckedUpdateWithoutComboInput>
  }

  export type ProductUpdateWithoutComboInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    free?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    additionalsMax?: IntFieldUpdateOperationsInput | number
    accompanimentsMax?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: CategoryUpdateOneRequiredWithoutProductsNestedInput
    enterprise?: EnterpriseUpdateOneRequiredWithoutProductsNestedInput
    accompaniments?: AccompanimentUpdateManyWithoutProductNestedInput
    additionals?: AdditionalUpdateManyWithoutProductNestedInput
    orders?: OrderUpdateManyWithoutProductsNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    productTags?: ProductTagUpdateManyWithoutProductNestedInput
    combos?: ComboUpdateManyWithoutProductsNestedInput
    ComboProducts?: ComboProductsUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutComboInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    free?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    additionalsMax?: IntFieldUpdateOperationsInput | number
    accompanimentsMax?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categoryId?: IntFieldUpdateOperationsInput | number
    enterpriseId?: IntFieldUpdateOperationsInput | number
    accompaniments?: AccompanimentUncheckedUpdateManyWithoutProductNestedInput
    additionals?: AdditionalUncheckedUpdateManyWithoutProductNestedInput
    orders?: OrderUncheckedUpdateManyWithoutProductsNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    productTags?: ProductTagUncheckedUpdateManyWithoutProductNestedInput
    combos?: ComboUncheckedUpdateManyWithoutProductsNestedInput
    ComboProducts?: ComboProductsUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ComboCreateWithoutComboProductsInput = {
    uuid: string
    name: string
    description?: string | null
    price: number
    status: string
    category: CategoryCreateNestedOneWithoutCombosInput
    enterprise: EnterpriseCreateNestedOneWithoutCombosInput
    products?: ProductCreateNestedManyWithoutCombosInput
    Product?: ProductCreateNestedOneWithoutComboInput
  }

  export type ComboUncheckedCreateWithoutComboProductsInput = {
    id?: number
    uuid: string
    name: string
    description?: string | null
    price: number
    status: string
    categoryId: number
    enterpriseId: number
    productId?: number | null
    products?: ProductUncheckedCreateNestedManyWithoutCombosInput
  }

  export type ComboCreateOrConnectWithoutComboProductsInput = {
    where: ComboWhereUniqueInput
    create: XOR<ComboCreateWithoutComboProductsInput, ComboUncheckedCreateWithoutComboProductsInput>
  }

  export type ProductCreateWithoutComboProductsInput = {
    uuid: string
    name: string
    description?: string | null
    type?: string
    price: number
    free?: boolean
    status?: string
    additionalsMax?: number
    accompanimentsMax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    category: CategoryCreateNestedOneWithoutProductsInput
    enterprise: EnterpriseCreateNestedOneWithoutProductsInput
    accompaniments?: AccompanimentCreateNestedManyWithoutProductInput
    additionals?: AdditionalCreateNestedManyWithoutProductInput
    orders?: OrderCreateNestedManyWithoutProductsInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    productTags?: ProductTagCreateNestedManyWithoutProductInput
    combos?: ComboCreateNestedManyWithoutProductsInput
    Combo?: ComboCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutComboProductsInput = {
    id?: number
    uuid: string
    name: string
    description?: string | null
    type?: string
    price: number
    free?: boolean
    status?: string
    additionalsMax?: number
    accompanimentsMax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    categoryId: number
    enterpriseId: number
    accompaniments?: AccompanimentUncheckedCreateNestedManyWithoutProductInput
    additionals?: AdditionalUncheckedCreateNestedManyWithoutProductInput
    orders?: OrderUncheckedCreateNestedManyWithoutProductsInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    productTags?: ProductTagUncheckedCreateNestedManyWithoutProductInput
    combos?: ComboUncheckedCreateNestedManyWithoutProductsInput
    Combo?: ComboUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutComboProductsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutComboProductsInput, ProductUncheckedCreateWithoutComboProductsInput>
  }

  export type ComboUpsertWithoutComboProductsInput = {
    update: XOR<ComboUpdateWithoutComboProductsInput, ComboUncheckedUpdateWithoutComboProductsInput>
    create: XOR<ComboCreateWithoutComboProductsInput, ComboUncheckedCreateWithoutComboProductsInput>
    where?: ComboWhereInput
  }

  export type ComboUpdateToOneWithWhereWithoutComboProductsInput = {
    where?: ComboWhereInput
    data: XOR<ComboUpdateWithoutComboProductsInput, ComboUncheckedUpdateWithoutComboProductsInput>
  }

  export type ComboUpdateWithoutComboProductsInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    category?: CategoryUpdateOneRequiredWithoutCombosNestedInput
    enterprise?: EnterpriseUpdateOneRequiredWithoutCombosNestedInput
    products?: ProductUpdateManyWithoutCombosNestedInput
    Product?: ProductUpdateOneWithoutComboNestedInput
  }

  export type ComboUncheckedUpdateWithoutComboProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    categoryId?: IntFieldUpdateOperationsInput | number
    enterpriseId?: IntFieldUpdateOperationsInput | number
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    products?: ProductUncheckedUpdateManyWithoutCombosNestedInput
  }

  export type ProductUpsertWithoutComboProductsInput = {
    update: XOR<ProductUpdateWithoutComboProductsInput, ProductUncheckedUpdateWithoutComboProductsInput>
    create: XOR<ProductCreateWithoutComboProductsInput, ProductUncheckedCreateWithoutComboProductsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutComboProductsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutComboProductsInput, ProductUncheckedUpdateWithoutComboProductsInput>
  }

  export type ProductUpdateWithoutComboProductsInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    free?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    additionalsMax?: IntFieldUpdateOperationsInput | number
    accompanimentsMax?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: CategoryUpdateOneRequiredWithoutProductsNestedInput
    enterprise?: EnterpriseUpdateOneRequiredWithoutProductsNestedInput
    accompaniments?: AccompanimentUpdateManyWithoutProductNestedInput
    additionals?: AdditionalUpdateManyWithoutProductNestedInput
    orders?: OrderUpdateManyWithoutProductsNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    productTags?: ProductTagUpdateManyWithoutProductNestedInput
    combos?: ComboUpdateManyWithoutProductsNestedInput
    Combo?: ComboUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutComboProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    free?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    additionalsMax?: IntFieldUpdateOperationsInput | number
    accompanimentsMax?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categoryId?: IntFieldUpdateOperationsInput | number
    enterpriseId?: IntFieldUpdateOperationsInput | number
    accompaniments?: AccompanimentUncheckedUpdateManyWithoutProductNestedInput
    additionals?: AdditionalUncheckedUpdateManyWithoutProductNestedInput
    orders?: OrderUncheckedUpdateManyWithoutProductsNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    productTags?: ProductTagUncheckedUpdateManyWithoutProductNestedInput
    combos?: ComboUncheckedUpdateManyWithoutProductsNestedInput
    Combo?: ComboUncheckedUpdateManyWithoutProductNestedInput
  }

  export type OrderCreateManyUserInput = {
    id?: number
    uuid: string
    totalPrice: number
    status?: string
    updatedAt?: Date | string
    orderDate?: Date | string
    enterpriseId: number
  }

  export type OrderUpdateWithoutUserInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUpdateManyWithoutOrdersNestedInput
    enterprise?: EnterpriseUpdateOneRequiredWithoutOrdersNestedInput
    orderItems?: OrderItemUpdateManyWithoutOrderNestedInput
    orderHistories?: OrderHistoryUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    enterpriseId?: IntFieldUpdateOperationsInput | number
    products?: ProductUncheckedUpdateManyWithoutOrdersNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    orderHistories?: OrderHistoryUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    enterpriseId?: IntFieldUpdateOperationsInput | number
  }

  export type ProductCreateManyCategoryInput = {
    id?: number
    uuid: string
    name: string
    description?: string | null
    type?: string
    price: number
    free?: boolean
    status?: string
    additionalsMax?: number
    accompanimentsMax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    enterpriseId: number
  }

  export type PromotionCreateManyCategoryInput = {
    id?: number
    uuid: string
    name: string
    description?: string | null
    status: string
    discountRate: number
    startDate: Date | string
    endDate: Date | string
    enterpriseId: number
    deletedAt?: Date | string | null
  }

  export type ComboCreateManyCategoryInput = {
    id?: number
    uuid: string
    name: string
    description?: string | null
    price: number
    status: string
    enterpriseId: number
    productId?: number | null
  }

  export type ProductUpdateWithoutCategoryInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    free?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    additionalsMax?: IntFieldUpdateOperationsInput | number
    accompanimentsMax?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enterprise?: EnterpriseUpdateOneRequiredWithoutProductsNestedInput
    accompaniments?: AccompanimentUpdateManyWithoutProductNestedInput
    additionals?: AdditionalUpdateManyWithoutProductNestedInput
    orders?: OrderUpdateManyWithoutProductsNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    productTags?: ProductTagUpdateManyWithoutProductNestedInput
    combos?: ComboUpdateManyWithoutProductsNestedInput
    ComboProducts?: ComboProductsUpdateManyWithoutProductNestedInput
    Combo?: ComboUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    free?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    additionalsMax?: IntFieldUpdateOperationsInput | number
    accompanimentsMax?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enterpriseId?: IntFieldUpdateOperationsInput | number
    accompaniments?: AccompanimentUncheckedUpdateManyWithoutProductNestedInput
    additionals?: AdditionalUncheckedUpdateManyWithoutProductNestedInput
    orders?: OrderUncheckedUpdateManyWithoutProductsNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    productTags?: ProductTagUncheckedUpdateManyWithoutProductNestedInput
    combos?: ComboUncheckedUpdateManyWithoutProductsNestedInput
    ComboProducts?: ComboProductsUncheckedUpdateManyWithoutProductNestedInput
    Combo?: ComboUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    free?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    additionalsMax?: IntFieldUpdateOperationsInput | number
    accompanimentsMax?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enterpriseId?: IntFieldUpdateOperationsInput | number
  }

  export type PromotionUpdateWithoutCategoryInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    discountRate?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enterprise?: EnterpriseUpdateOneRequiredWithoutPromotionsNestedInput
    promotionTags?: PromotionTagUpdateManyWithoutPromotionNestedInput
  }

  export type PromotionUncheckedUpdateWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    discountRate?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    enterpriseId?: IntFieldUpdateOperationsInput | number
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    promotionTags?: PromotionTagUncheckedUpdateManyWithoutPromotionNestedInput
  }

  export type PromotionUncheckedUpdateManyWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    discountRate?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    enterpriseId?: IntFieldUpdateOperationsInput | number
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ComboUpdateWithoutCategoryInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    enterprise?: EnterpriseUpdateOneRequiredWithoutCombosNestedInput
    products?: ProductUpdateManyWithoutCombosNestedInput
    ComboProducts?: ComboProductsUpdateManyWithoutComboNestedInput
    Product?: ProductUpdateOneWithoutComboNestedInput
  }

  export type ComboUncheckedUpdateWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    enterpriseId?: IntFieldUpdateOperationsInput | number
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    products?: ProductUncheckedUpdateManyWithoutCombosNestedInput
    ComboProducts?: ComboProductsUncheckedUpdateManyWithoutComboNestedInput
  }

  export type ComboUncheckedUpdateManyWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    enterpriseId?: IntFieldUpdateOperationsInput | number
    productId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AccompanimentCreateManyProductInput = {
    id?: number
    uuid: string
  }

  export type AdditionalCreateManyProductInput = {
    id?: number
    uuid: string
  }

  export type OrderItemCreateManyProductInput = {
    id?: number
    uuid: string
    quantity: number
    price: number
    orderId: number
  }

  export type ProductTagCreateManyProductInput = {
    id?: number
    uuid: string
    tagId: number
  }

  export type ComboProductsCreateManyProductInput = {
    id?: number
    uuid: string
    comboId: number
  }

  export type ComboCreateManyProductInput = {
    id?: number
    uuid: string
    name: string
    description?: string | null
    price: number
    status: string
    categoryId: number
    enterpriseId: number
  }

  export type AccompanimentUpdateWithoutProductInput = {
    uuid?: StringFieldUpdateOperationsInput | string
  }

  export type AccompanimentUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
  }

  export type AccompanimentUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
  }

  export type AdditionalUpdateWithoutProductInput = {
    uuid?: StringFieldUpdateOperationsInput | string
  }

  export type AdditionalUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
  }

  export type AdditionalUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
  }

  export type OrderUpdateWithoutProductsInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    enterprise?: EnterpriseUpdateOneRequiredWithoutOrdersNestedInput
    orderItems?: OrderItemUpdateManyWithoutOrderNestedInput
    orderHistories?: OrderHistoryUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    enterpriseId?: IntFieldUpdateOperationsInput | number
    orderItems?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    orderHistories?: OrderHistoryUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    enterpriseId?: IntFieldUpdateOperationsInput | number
  }

  export type OrderItemUpdateWithoutProductInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    order?: OrderUpdateOneRequiredWithoutOrderItemsNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
  }

  export type OrderItemUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
  }

  export type ProductTagUpdateWithoutProductInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    tag?: TagUpdateOneRequiredWithoutProductTagsNestedInput
  }

  export type ProductTagUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    tagId?: IntFieldUpdateOperationsInput | number
  }

  export type ProductTagUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    tagId?: IntFieldUpdateOperationsInput | number
  }

  export type ComboUpdateWithoutProductsInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    category?: CategoryUpdateOneRequiredWithoutCombosNestedInput
    enterprise?: EnterpriseUpdateOneRequiredWithoutCombosNestedInput
    ComboProducts?: ComboProductsUpdateManyWithoutComboNestedInput
    Product?: ProductUpdateOneWithoutComboNestedInput
  }

  export type ComboUncheckedUpdateWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    categoryId?: IntFieldUpdateOperationsInput | number
    enterpriseId?: IntFieldUpdateOperationsInput | number
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    ComboProducts?: ComboProductsUncheckedUpdateManyWithoutComboNestedInput
  }

  export type ComboUncheckedUpdateManyWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    categoryId?: IntFieldUpdateOperationsInput | number
    enterpriseId?: IntFieldUpdateOperationsInput | number
    productId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ComboProductsUpdateWithoutProductInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    combo?: ComboUpdateOneRequiredWithoutComboProductsNestedInput
  }

  export type ComboProductsUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    comboId?: IntFieldUpdateOperationsInput | number
  }

  export type ComboProductsUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    comboId?: IntFieldUpdateOperationsInput | number
  }

  export type ComboUpdateWithoutProductInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    category?: CategoryUpdateOneRequiredWithoutCombosNestedInput
    enterprise?: EnterpriseUpdateOneRequiredWithoutCombosNestedInput
    products?: ProductUpdateManyWithoutCombosNestedInput
    ComboProducts?: ComboProductsUpdateManyWithoutComboNestedInput
  }

  export type ComboUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    categoryId?: IntFieldUpdateOperationsInput | number
    enterpriseId?: IntFieldUpdateOperationsInput | number
    products?: ProductUncheckedUpdateManyWithoutCombosNestedInput
    ComboProducts?: ComboProductsUncheckedUpdateManyWithoutComboNestedInput
  }

  export type ComboUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    categoryId?: IntFieldUpdateOperationsInput | number
    enterpriseId?: IntFieldUpdateOperationsInput | number
  }

  export type OrderItemCreateManyOrderInput = {
    id?: number
    uuid: string
    quantity: number
    price: number
    productId: number
  }

  export type OrderHistoryCreateManyOrderInput = {
    id?: number
    uuid: string
    status: string
    description?: string | null
    createdAt?: Date | string
  }

  export type ProductUpdateWithoutOrdersInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    free?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    additionalsMax?: IntFieldUpdateOperationsInput | number
    accompanimentsMax?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: CategoryUpdateOneRequiredWithoutProductsNestedInput
    enterprise?: EnterpriseUpdateOneRequiredWithoutProductsNestedInput
    accompaniments?: AccompanimentUpdateManyWithoutProductNestedInput
    additionals?: AdditionalUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    productTags?: ProductTagUpdateManyWithoutProductNestedInput
    combos?: ComboUpdateManyWithoutProductsNestedInput
    ComboProducts?: ComboProductsUpdateManyWithoutProductNestedInput
    Combo?: ComboUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    free?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    additionalsMax?: IntFieldUpdateOperationsInput | number
    accompanimentsMax?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categoryId?: IntFieldUpdateOperationsInput | number
    enterpriseId?: IntFieldUpdateOperationsInput | number
    accompaniments?: AccompanimentUncheckedUpdateManyWithoutProductNestedInput
    additionals?: AdditionalUncheckedUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    productTags?: ProductTagUncheckedUpdateManyWithoutProductNestedInput
    combos?: ComboUncheckedUpdateManyWithoutProductsNestedInput
    ComboProducts?: ComboProductsUncheckedUpdateManyWithoutProductNestedInput
    Combo?: ComboUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    free?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    additionalsMax?: IntFieldUpdateOperationsInput | number
    accompanimentsMax?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categoryId?: IntFieldUpdateOperationsInput | number
    enterpriseId?: IntFieldUpdateOperationsInput | number
  }

  export type OrderItemUpdateWithoutOrderInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    product?: ProductUpdateOneRequiredWithoutOrderItemsNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
  }

  export type OrderItemUncheckedUpdateManyWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
  }

  export type OrderHistoryUpdateWithoutOrderInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderHistoryUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderHistoryUncheckedUpdateManyWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateManyEnterpriseInput = {
    id?: number
    uuid: string
    email: string
    nickname: string
    role: string
    firstName?: string | null
    lastName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type CategoryCreateManyEnterpriseInput = {
    id?: number
    uuid: string
    name: string
    description?: string | null
    status?: string
  }

  export type ProductCreateManyEnterpriseInput = {
    id?: number
    uuid: string
    name: string
    description?: string | null
    type?: string
    price: number
    free?: boolean
    status?: string
    additionalsMax?: number
    accompanimentsMax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    categoryId: number
  }

  export type ConfigurationCreateManyEnterpriseInput = {
    id?: number
    uuid: string
    configKey: string
    configValue: string
    configText?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderCreateManyEnterpriseInput = {
    id?: number
    uuid: string
    totalPrice: number
    status?: string
    updatedAt?: Date | string
    orderDate?: Date | string
    userId: number
  }

  export type PromotionCreateManyEnterpriseInput = {
    id?: number
    uuid: string
    name: string
    description?: string | null
    status: string
    discountRate: number
    startDate: Date | string
    endDate: Date | string
    categoryId: number
    deletedAt?: Date | string | null
  }

  export type ComboCreateManyEnterpriseInput = {
    id?: number
    uuid: string
    name: string
    description?: string | null
    price: number
    status: string
    categoryId: number
    productId?: number | null
  }

  export type UserUpdateWithoutEnterpriseInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orders?: OrderUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEnterpriseInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutEnterpriseInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CategoryUpdateWithoutEnterpriseInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    products?: ProductUpdateManyWithoutCategoryNestedInput
    promotions?: PromotionUpdateManyWithoutCategoryNestedInput
    combos?: ComboUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutEnterpriseInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    products?: ProductUncheckedUpdateManyWithoutCategoryNestedInput
    promotions?: PromotionUncheckedUpdateManyWithoutCategoryNestedInput
    combos?: ComboUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateManyWithoutEnterpriseInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type ProductUpdateWithoutEnterpriseInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    free?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    additionalsMax?: IntFieldUpdateOperationsInput | number
    accompanimentsMax?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: CategoryUpdateOneRequiredWithoutProductsNestedInput
    accompaniments?: AccompanimentUpdateManyWithoutProductNestedInput
    additionals?: AdditionalUpdateManyWithoutProductNestedInput
    orders?: OrderUpdateManyWithoutProductsNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    productTags?: ProductTagUpdateManyWithoutProductNestedInput
    combos?: ComboUpdateManyWithoutProductsNestedInput
    ComboProducts?: ComboProductsUpdateManyWithoutProductNestedInput
    Combo?: ComboUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutEnterpriseInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    free?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    additionalsMax?: IntFieldUpdateOperationsInput | number
    accompanimentsMax?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categoryId?: IntFieldUpdateOperationsInput | number
    accompaniments?: AccompanimentUncheckedUpdateManyWithoutProductNestedInput
    additionals?: AdditionalUncheckedUpdateManyWithoutProductNestedInput
    orders?: OrderUncheckedUpdateManyWithoutProductsNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    productTags?: ProductTagUncheckedUpdateManyWithoutProductNestedInput
    combos?: ComboUncheckedUpdateManyWithoutProductsNestedInput
    ComboProducts?: ComboProductsUncheckedUpdateManyWithoutProductNestedInput
    Combo?: ComboUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutEnterpriseInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    free?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    additionalsMax?: IntFieldUpdateOperationsInput | number
    accompanimentsMax?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categoryId?: IntFieldUpdateOperationsInput | number
  }

  export type ConfigurationUpdateWithoutEnterpriseInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    configKey?: StringFieldUpdateOperationsInput | string
    configValue?: StringFieldUpdateOperationsInput | string
    configText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfigurationUncheckedUpdateWithoutEnterpriseInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    configKey?: StringFieldUpdateOperationsInput | string
    configValue?: StringFieldUpdateOperationsInput | string
    configText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfigurationUncheckedUpdateManyWithoutEnterpriseInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    configKey?: StringFieldUpdateOperationsInput | string
    configValue?: StringFieldUpdateOperationsInput | string
    configText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUpdateWithoutEnterpriseInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    products?: ProductUpdateManyWithoutOrdersNestedInput
    orderItems?: OrderItemUpdateManyWithoutOrderNestedInput
    orderHistories?: OrderHistoryUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutEnterpriseInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    products?: ProductUncheckedUpdateManyWithoutOrdersNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    orderHistories?: OrderHistoryUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutEnterpriseInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type PromotionUpdateWithoutEnterpriseInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    discountRate?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: CategoryUpdateOneRequiredWithoutPromotionsNestedInput
    promotionTags?: PromotionTagUpdateManyWithoutPromotionNestedInput
  }

  export type PromotionUncheckedUpdateWithoutEnterpriseInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    discountRate?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    categoryId?: IntFieldUpdateOperationsInput | number
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    promotionTags?: PromotionTagUncheckedUpdateManyWithoutPromotionNestedInput
  }

  export type PromotionUncheckedUpdateManyWithoutEnterpriseInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    discountRate?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    categoryId?: IntFieldUpdateOperationsInput | number
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ComboUpdateWithoutEnterpriseInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    category?: CategoryUpdateOneRequiredWithoutCombosNestedInput
    products?: ProductUpdateManyWithoutCombosNestedInput
    ComboProducts?: ComboProductsUpdateManyWithoutComboNestedInput
    Product?: ProductUpdateOneWithoutComboNestedInput
  }

  export type ComboUncheckedUpdateWithoutEnterpriseInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    categoryId?: IntFieldUpdateOperationsInput | number
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    products?: ProductUncheckedUpdateManyWithoutCombosNestedInput
    ComboProducts?: ComboProductsUncheckedUpdateManyWithoutComboNestedInput
  }

  export type ComboUncheckedUpdateManyWithoutEnterpriseInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    categoryId?: IntFieldUpdateOperationsInput | number
    productId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProductTagCreateManyTagInput = {
    id?: number
    uuid: string
    productId: number
  }

  export type PromotionTagCreateManyTagInput = {
    id?: number
    uuid: string
    promotionId: number
  }

  export type ProductTagUpdateWithoutTagInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    product?: ProductUpdateOneRequiredWithoutProductTagsNestedInput
  }

  export type ProductTagUncheckedUpdateWithoutTagInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    productId?: IntFieldUpdateOperationsInput | number
  }

  export type ProductTagUncheckedUpdateManyWithoutTagInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    productId?: IntFieldUpdateOperationsInput | number
  }

  export type PromotionTagUpdateWithoutTagInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    promotion?: PromotionUpdateOneRequiredWithoutPromotionTagsNestedInput
  }

  export type PromotionTagUncheckedUpdateWithoutTagInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    promotionId?: IntFieldUpdateOperationsInput | number
  }

  export type PromotionTagUncheckedUpdateManyWithoutTagInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    promotionId?: IntFieldUpdateOperationsInput | number
  }

  export type PromotionTagCreateManyPromotionInput = {
    id?: number
    uuid: string
    tagId: number
  }

  export type PromotionTagUpdateWithoutPromotionInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    tag?: TagUpdateOneRequiredWithoutPromotionTagsNestedInput
  }

  export type PromotionTagUncheckedUpdateWithoutPromotionInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    tagId?: IntFieldUpdateOperationsInput | number
  }

  export type PromotionTagUncheckedUpdateManyWithoutPromotionInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    tagId?: IntFieldUpdateOperationsInput | number
  }

  export type ComboProductsCreateManyComboInput = {
    id?: number
    uuid: string
    productId: number
  }

  export type ProductUpdateWithoutCombosInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    free?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    additionalsMax?: IntFieldUpdateOperationsInput | number
    accompanimentsMax?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: CategoryUpdateOneRequiredWithoutProductsNestedInput
    enterprise?: EnterpriseUpdateOneRequiredWithoutProductsNestedInput
    accompaniments?: AccompanimentUpdateManyWithoutProductNestedInput
    additionals?: AdditionalUpdateManyWithoutProductNestedInput
    orders?: OrderUpdateManyWithoutProductsNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    productTags?: ProductTagUpdateManyWithoutProductNestedInput
    ComboProducts?: ComboProductsUpdateManyWithoutProductNestedInput
    Combo?: ComboUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutCombosInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    free?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    additionalsMax?: IntFieldUpdateOperationsInput | number
    accompanimentsMax?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categoryId?: IntFieldUpdateOperationsInput | number
    enterpriseId?: IntFieldUpdateOperationsInput | number
    accompaniments?: AccompanimentUncheckedUpdateManyWithoutProductNestedInput
    additionals?: AdditionalUncheckedUpdateManyWithoutProductNestedInput
    orders?: OrderUncheckedUpdateManyWithoutProductsNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    productTags?: ProductTagUncheckedUpdateManyWithoutProductNestedInput
    ComboProducts?: ComboProductsUncheckedUpdateManyWithoutProductNestedInput
    Combo?: ComboUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutCombosInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    free?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    additionalsMax?: IntFieldUpdateOperationsInput | number
    accompanimentsMax?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categoryId?: IntFieldUpdateOperationsInput | number
    enterpriseId?: IntFieldUpdateOperationsInput | number
  }

  export type ComboProductsUpdateWithoutComboInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    product?: ProductUpdateOneRequiredWithoutComboProductsNestedInput
  }

  export type ComboProductsUncheckedUpdateWithoutComboInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    productId?: IntFieldUpdateOperationsInput | number
  }

  export type ComboProductsUncheckedUpdateManyWithoutComboInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    productId?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CategoryCountOutputTypeDefaultArgs instead
     */
    export type CategoryCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = CategoryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductCountOutputTypeDefaultArgs instead
     */
    export type ProductCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = ProductCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrderCountOutputTypeDefaultArgs instead
     */
    export type OrderCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = OrderCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EnterpriseCountOutputTypeDefaultArgs instead
     */
    export type EnterpriseCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = EnterpriseCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TagCountOutputTypeDefaultArgs instead
     */
    export type TagCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = TagCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PromotionCountOutputTypeDefaultArgs instead
     */
    export type PromotionCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = PromotionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ComboCountOutputTypeDefaultArgs instead
     */
    export type ComboCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = ComboCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CategoryDefaultArgs instead
     */
    export type CategoryArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = CategoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductDefaultArgs instead
     */
    export type ProductArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = ProductDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AccompanimentDefaultArgs instead
     */
    export type AccompanimentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = AccompanimentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdditionalDefaultArgs instead
     */
    export type AdditionalArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = AdditionalDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrderDefaultArgs instead
     */
    export type OrderArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = OrderDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrderItemDefaultArgs instead
     */
    export type OrderItemArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = OrderItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrderHistoryDefaultArgs instead
     */
    export type OrderHistoryArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = OrderHistoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EnterpriseDefaultArgs instead
     */
    export type EnterpriseArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = EnterpriseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConfigurationDefaultArgs instead
     */
    export type ConfigurationArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = ConfigurationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TagDefaultArgs instead
     */
    export type TagArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = TagDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductTagDefaultArgs instead
     */
    export type ProductTagArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = ProductTagDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PromotionTagDefaultArgs instead
     */
    export type PromotionTagArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = PromotionTagDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PromotionDefaultArgs instead
     */
    export type PromotionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = PromotionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ComboDefaultArgs instead
     */
    export type ComboArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = ComboDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ComboProductsDefaultArgs instead
     */
    export type ComboProductsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = ComboProductsDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}